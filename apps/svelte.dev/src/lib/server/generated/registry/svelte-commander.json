{
	"name": "svelte-commander",
	"description": "Create command palette with robust interactions and predictable behavior.",
	"repo_url": "",
	"authors": ["oskarhane"],
	"downloads": 37,
	"updated": "2021-03-21T17:57:29.912Z",
	"tags": ["miscellaneous"],
	"typescript": true,
	"version": "1.4.0",
	"svelte_range": "^3.24.0",
	"last_rune_check_version": "1.4.0",
	"github_stars": 0,
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-commander",
				"version": "1.4.0",
				"size": 1384237
			},
			{
				"name": "nearley",
				"version": "2.20.1",
				"size": 75813
			},
			{
				"name": "commander",
				"version": "2.20.3",
				"size": 62442
			},
			{
				"name": "moo",
				"version": "0.5.2",
				"size": 32679
			},
			{
				"name": "railroad-diagrams",
				"version": "1.0.0"
			},
			{
				"name": "randexp",
				"version": "0.4.6"
			},
			{
				"name": "discontinuous-range",
				"version": "1.0.0"
			},
			{
				"name": "ret",
				"version": "0.1.15"
			},
			{
				"name": "xstate",
				"version": "4.38.3",
				"size": 793710
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2],
			[1, 3],
			[1, 4],
			[1, 5],
			[5, 6],
			[5, 7],
			[0, 8]
		],
		"circular": []
	},
	"readme": "# svelte-commander\n\n![bar](images/bar.png)\nThis repo holds a command palette with robust interactions and predictable behavior backed by a finite state machine.\nA command palette (or command bar) is a user interface that receives user input and presents the user with a list of matching commands and executes the command the user chooses.\n\nYou see this kind of UI in many application nowadays. `Ctrl/cmd + k` in Slack and Discord, `Ctrl/cmd + p` in VS Code, `cmd + Space` in MacOS etc.\n\n> I wanted to have as much as possible handled in a UI framework / library agnostic way, so gluing it to a React or Svelte component should be trivial.\n\n## Component Usage\n\nInstall it in your Svelte project with:\n\n```bash\nnpm install svelte-commander\n```\n\nand import it\n\n```svelte\nimport Commander from 'svelte-commander'\n```\n\nAs mentioned, it should be trivial to implement this in any UI framework, have a look in [src/Component.svelte](src/Component.svelte) to see how it's made using Svelte.\n\nAll props except `commands` are optional.\n\n```jsx\n<Commander\n    {commands}\n    toggleKey=\"p\"\n    placeholder=\"Type your best commands\"\n    theme={{\n        \"--color\": \"rgba(212, 208, 199, 1.00)\",\n        \"--result-description-color\": \"rgba(212, 208, 199, 1.00)\",\n        \"--background-color\": \"rgba(36, 36, 36, 1.00)\",\n        \"--active-result-background-color\": \"rgba(64, 64, 64, 1.00)\",\n        \"--active-result-description-color\": \"rgba(255, 255, 255, 1.00)\",\n        \"--active-result-title-color\": \"rgba(255, 255, 255, 1.00)\",\n        \"--scale\": \"1.3\",\n    }}\n/>\n```\n\nType definition of a command:\n\n```typescript\ntype Command = {\n    id: string;\n    title: CommandTitle;\n    description: CommandDescription;\n    exec: ExecutionFn;\n    getMatchString?: GenerateMatchStringFn;\n    requiredArgs?: string[];\n};\ntype CommandTitle = string | CommandTitleFn;\ntype CommandTitleFn = (input: ParserResult) => string;\ntype CommandDescription = string | CommandDescriptionFn;\ntype CommandDescriptionFn = (input: ParserResult) => string;\ntype ExecutionFn = (command: Command, input: ParserResult) => void;\ntype GenerateMatchStringFn = (input: ParserResult) => string;\ntype ParserResult = [string] | [string, ParserParams] | null;\ntype ParserParams = {\n    [key: string]: string;\n};\n```\n\n## Demo\n\nHere's a demo: [https://ti99l.csb.app](https://ti99l.csb.app)\n\n## States and transitions\n\n**Open / Close**\n\nThe command palette behaves as most palettes do. It's able to become visible by using a hot-key, and closed with the escape key.\n\n**Command matching and ranking**\n\nWhile open and on user input, it waits for relevant commands and rank the matching ones in a natural order (the ranking algo can be overridden) with the best match on top.\n\n**Command list selection**\n\nWith the matching command results listed, the top one is selected automatically (called auto selection). If the user would continue typing, the top one should always stay selected until the user selects one manually (with arrow keys or hover with the mouse).\n\nIf the user selects one manually (called id selection), and then continues typing, as long as the selected command is in the list it should stay selected, no matter if its position changes. When the selected result isn't available in the result list anymore (due to not matching anymore), the top result should be selected again (by position, not by id).\n\nThe user is able to step over the selection boundaries (pressing arrow down on the last result should roll over to select the top result and vice versa).\n\n**Dynamic list of commands**\n\nCommands might be added and removed at any time, and the palette should be able to handle that when opened. If a new command becomes available and it matches the current user input, it should be shown in the correct position in the result listing and should not interfere with any user selection.\n\n**Execution**\n\nThe user can execute a command in two ways: Click on it or press Enter.\nWhen a command is executed, the palette should close and the user input should be emptied.\n\n**Remember non executed input**\n\nIf the user types something in the command palette input but closes it without executing, the palette should remember it and populate the input once the user opens it again.\n\n## The Finite State Machine\n\nHave a look at [src/selection-machine.ts](src/selection-machine.ts) to see the machine and its services / actions / guards implementations.\n\nHere's a visaulization of the machine:\n![vis](images/vis.png)\n\n## Todo\n\n[ ] Make it self learning using a in memory tree that can be loaded and downloaded\n\n[ ] Commands should be able to require params\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 1],
		[3596, 16],
		[3603, 15],
		[3610, 18],
		[3617, 2],
		[3624, 1],
		[3631, 4],
		[3638, 1],
		[3652, 1],
		[3659, 2],
		[3666, 16],
		[3673, 5],
		[3680, 8],
		[3687, 18],
		[3701, 2],
		[3708, 3],
		[3715, 2],
		[3729, 16],
		[3736, 2],
		[3743, 4],
		[3750, 1],
		[3757, 2],
		[3764, 16],
		[3771, 4],
		[3778, 4],
		[3785, 7],
		[3792, 6],
		[3799, 18],
		[3806, 5],
		[3813, 7],
		[3820, 2],
		[3834, 2],
		[3841, 2],
		[3848, 2],
		[3855, 81],
		[3869, 1],
		[3876, 1],
		[3883, 4],
		[3890, 33],
		[3897, 17],
		[3904, 4],
		[3911, 5],
		[3918, 3],
		[3932, 1],
		[3939, 5],
		[3946, 2],
		[3953, 1],
		[3960, 2],
		[3974, 4],
		[3981, 5],
		[3988, 3],
		[3995, 5],
		[4002, 3],
		[4009, 1],
		[4016, 6],
		[4023, 6],
		[4030, 22],
		[4037, 25],
		[4044, 4],
		[4051, 1],
		[4058, 2],
		[4065, 2],
		[4079, 1],
		[4093, 12],
		[4100, 16],
		[4107, 5],
		[4114, 37],
		[4121, 31],
		[4128, 10]
	],
	"esm": true,
	"cjs": false
}
