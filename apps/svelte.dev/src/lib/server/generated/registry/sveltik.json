{
	"name": "sveltik",
	"description": "Build forms with validation in Svelte applications.",
	"repo_url": "https://github.com/nathancahill/sveltik",
	"authors": ["nathancahill", "mapgrid"],
	"downloads": 42,
	"updated": "2020-12-07T10:36:34.057Z",
	"tags": ["miscellaneous"],
	"github_stars": 195,
	"homepage": "",
	"typescript": false,
	"version": "0.1.16",
	"svelte_range": "^3.23.0",
	"last_rune_check_version": "0.1.16",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "sveltik",
				"version": "0.1.16",
				"size": 445578
			},
			{
				"name": "lodash-es",
				"version": "4.17.21",
				"size": 636080
			},
			{
				"name": "svelte",
				"version": "3.59.2",
				"size": 10624206
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2]
		],
		"circular": []
	},
	"readme": "# Sveltik ![CI](https://github.com/nathancahill/sveltik/workflows/CI/badge.svg)\n\nForms in Svelte, inspired by [Formik](https://jaredpalmer.com/formik/).\n\n```html\n<script>\n    import { Sveltik, Form, Field, ErrorMessage } from 'sveltik'\n\n    let initialValues = {\n        email: '',\n        password: '',\n    }\n\n    let validate = values => {\n        const errors = {}\n        if (!values.email) {\n            errors.email = 'Required'\n        } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i.test(values.email)) {\n            errors.email = 'Invalid email address'\n        }\n        return errors\n    }\n\n    let onSubmit = (values, { setSubmitting }) => {\n        setTimeout(() => {\n            alert(JSON.stringify(values, null, 2))\n            setSubmitting(false)\n        }, 400)\n    }\n</script>\n\n<Sveltik {initialValues} {validate} {onSubmit} let:isSubmitting>\n    <Form>\n        <Field type=\"email\" name=\"email\" />\n        <ErrorMessage name=\"email\" as=\"div\" />\n        <Field type=\"password\" name=\"password\" />\n        <ErrorMessage name=\"password\" as=\"div\" />\n        <button type=\"submit\" disabled={isSubmitting}>Submit</button>\n    </Form>\n</Sveltik>\n```\n\n## `<Sveltik />`\n\n`<Sveltik />` is a component for rendering forms. It is largely a port of\n[Formik](https://jaredpalmer.com/formik/docs/api/formik) to Svelte and broadly\nfollows the same API. It uses a `let:props` pattern which is generally similar to\nthe render prop pattern in React.\n\n### Example\n\n[Open in REPL](https://svelte.dev/repl/5ba56f98dc7f4911818ec5617c6b3024?version=3)\n\n```html\n<script>\n    import { Sveltik } from 'sveltik'\n</script>\n\n<div>\n    <h1>My Form</h1>\n    <Sveltik\n        initialValues={{ name: 'jared' }}\n        onSubmit={(values, actions) => {\n            setTimeout(() => {\n                alert(JSON.stringify(values, null, 2))\n                actions.setSubmitting(false)\n            }, 1000)\n        }}\n        let:props\n    >\n        <form on:submit|preventDefault={props.handleSubmit}>\n            <input\n                type=\"text\"\n                on:change={props.handleChange}\n                on:blur={props.handleBlur}\n                value={props.values.name}\n                name=\"name\"\n            />\n            {#if props.errors.name}\n                <div id=\"feedback\">{props.errors.name}</div>\n            {/if}\n            <button type=\"submit\">Submit</button>\n        </form>\n    </Sveltik>\n</div>\n```\n\n### Props\n\n- `enableReinitialize?: boolean`\n- `initialErrors?: SveltikErrors<Values>`\n- `initialStatus?: any`\n- `initialTouched?: SveltikTouched<Values>`\n- `initialValues: Values`\n- `initialWarnings?: SveltikWarnings<Values>`\n- `onReset?: (values: Values, sveltikBag: SveltikBag) => void`\n- `onSubmit: (values: Values, sveltikBag: SveltikBag) => void | Promise<any>`\n- `validate?: (values: Values, sveltikBag: SveltikBag) => SveltikErrors<Values>`\n- `validateOnBlur?: boolean`\n- `validateOnChange?: boolean`\n- `validateOnMount?: boolean`\n\n### let:props\n\n- `let:props: SveltikProps`\n- `let:isDirty: boolean`\n- `let:errors: { [field: string]: string }`\n- `let:handleBlur: (e: HTMLBlurEvent) => void`\n- `let:handleChange: (e: HTMLInputEvent) => void`\n- `let:handleReset: () => void`\n- `let:handleSubmit: (e: HTMLFormEvent) => void`\n- `let:isSubmitting: boolean`\n- `let:isValid: boolean`\n- `let:isValidating: boolean`\n- `let:resetForm: (nextInitialState?: SveltikState<Values>) => void`\n- `let:scrollFirstErrorIntoView: () => void`\n- `let:setErrors: (fields: { [field: string]: string }) => void`\n- `let:setFieldError: (field: string, errorMsg: string) => void`\n- `let:setFieldTouched: (field: string, isTouched?: boolean, shouldValidate?: boolean) => void`\n- `let:setFieldValue: (field: string, value: any, shouldValidate?: boolean) => void`\n- `let:setFieldWarning: (field: string, warning: string) => void`\n- `let:setStatus: (status?: any) => void`\n- `let:setSubmitting: (isSubmitting: boolean) => void`\n- `let:setTouched: (fields: { [field: string]: boolean }, shouldValidate?: boolean) => void`\n- `let:setValues: (fields: { [field: string]: any }, shouldValidate?: boolean) => void`\n- `let:setWarnings: (fields: { [field: string]: string }) => void`\n- `let:status: any`\n- `let:submitAttemptCount: number`\n- `let:submitFailure: () => void`\n- `let:submitFailureCount: number`\n- `let:submitForm: () => Promise`\n- `let:submitSuccess: () => void`\n- `let:submitSuccessCount: number`\n- `let:touched: { [field: string]: boolean }`\n- `let:values: { [field: string]: any }`\n- `let:validateForm: (values?: any) => void`\n- `let:validateField: (field: string) => void`\n- `let:warnings: { [field: string]: string }`\n\n### Reference\n\n#### Props\n\n##### `enableReinitialize?: boolean`\n\nDefault is false. Control whether Sveltik should reset the form if `initialValues` changes (using deep equality).\n\n##### `initialErrors?: SveltikErrors<Values>`\n\nInitial field errors of the form, Sveltik will make these values available to render methods component as `errors`.\n\n##### `initialStatus?: any`\n\nAn arbitrary value for the initial `status` of the form. If the form is reset, this value will be restored.\n\n##### `initialTouched?: SveltikTouched<Values>`\n\nInitial visitied fields of the form, Sveltik will make these values available to render methods component as `touched`.\n\n##### `initialValues: Values`\n\nInitial field values of the form, Sveltik will make these values available to render methods component as `values`.\n\nEven if your form is empty by default, you must initialize all fields with initial values.\n\n##### `onReset?: (values: Values, sveltikBag: SveltikBag) => void`\n\nYour optional form reset handler. It is passed your forms `values` and the \"SveltikBag\".\n\n##### `onSubmit: (values: Values, sveltikBag: SveltikBag) => void | Promise<any>`\n\nYour form submission handler. It is passed your forms `values` and the \"SveltikBag\", which includes an object containing a subset of the injected props and methods (i.e. all the methods with names that start with `set<Thing>` + `resetForm`) and any props that were passed to the wrapped component.\nIf `onSubmit` returns a promise, rejection automatically calls `submitFailure` and resolution automatically calls `submitSuccess`.\n\n##### `validate?: (values: Values) => SveltikErrors<Values>`\n\nValidate the form's `values` with function. Synchronous and return an `errors` object.\n\n##### `validateOnBlur?: boolean`\n\nDefault is `true`. Use this option to run validations on `blur` events. More specifically, when either `handleBlur`, `setFieldTouched`, or `setTouched` are called.\n\n##### `validateOnChange?: boolean`\n\nDefault is `true`. Use this option to tell Sveltik to run validations on `change` events and `change`-related methods. More specifically, when either `handleChange`, `setFieldValue`, or `setValues` are called.\n\n##### `validateOnMount?: boolean`\n\nDefault is `false`. Use this option to tell Sveltik to run validations when the `<Sveltik />` component mounts and/or `initialValues` change.\n\n#### let:props\n\nAll of these props are exposed individually as well as a master `let:props` prop which is an object\nof all available props.\n\n##### `let:isDirty: boolean`\n\nReturns `true` if values are not deeply equal from initial values, `false` otherwise. `dirty` is a readonly computed property and should not be mutated directly.\n\n##### `let:errors: { [field: string]: string }`\n\nForm validation errors. Should match the shape of your form's values defined in `initialValues`.\n\n##### `let:handleBlur: (e: HTMLBlurEvent) => void`\n\n`onBlur` event handler. Useful for when you need to track whether an input has been `touched` or not. This should be passed to\n`<input on:blur={handleBlur} ... />`\n\n##### `let:handleChange: (e: HTMLInputEvent) => void`\n\nGeneral input change event handler. This will update the `values[key]` where `key` is the event-emitting input's `name` attribute. If the `name` attribute is not present, `handleChange` will look for an input's `id` attribute. Note: \"input\" here means all HTML inputs.\n\n##### `let:handleReset: () => void`\n\nReset handler. Will reset the form to its initial state. This should be passed to `<button on:click={handleReset}>...</button>`\n\n##### `let:handleSubmit: (e: HTMLFormEvent) => void`\n\nSubmit handler. This should be passed to `<form on:submit|preventDefault={props.handleSubmit}>...</form>`.\n\n##### `let:isSubmitting: boolean`\n\nSubmitting state of the form. Returns `true` if submission is in progress and `false` otherwise.\n\n##### `let:isValid: boolean`\n\nReturns `true` if there are no `errors` (i.e. the `errors` object is empty) and `false` otherwise.\n\n##### `let:isValidating: boolean`\n\nReturns `true` if Sveltik is running validation during submission, or by calling `validateForm` directly false otherwise.\n\n##### `let:resetForm: (nextInitialState?: SveltikState<Values>) => void`\n\nImperatively reset the form. If `nextInitialState` is specified, Sveltik will set this state as the new \"initial state\" and use the related values of `nextInitialState` to update the form's `initialValues` as well as `initialTouched`, `initialStatus`, `initialErrors`. This is useful for altering the initial state (i.e. \"base\") of the form after changes have been made. If `nextInitialState` is not defined, then Sveltik will reset state to the original initial state.\n\n##### `let:scrollFirstErrorIntoView: () => void`\n\nScroll the first `<ScrollMarker />` with an error into view. First is calculated by the vertical distance from the top of the document.\n\n##### `let:setErrors: (fields: { [field: string]: string }) => void`\n\nSet `errors` imperatively.\n\n##### `let:setFieldError: (field: string, errorMsg: string) => void`\n\nSet the error message of a field imperatively. `field` should match the key of `errors` you wish to update. Useful for creating custom input error handlers.\n\n##### `let:setFieldTouched: (field: string, isTouched?: boolean, shouldValidate?: boolean) => void`\n\nSet the touched state of a field imperatively. `field` should match the key of `touched` you wish to update. Useful for creating custom input blur handlers. Calling this method will trigger validation to run if `validateOnBlur` is set to `true` (which it is by default). `isTouched` defaults to `true` if not specified. You can also explicitly prevent/skip validation by passing a third argument as `false`.\n\n##### `let:setFieldValue: (field: string, value: any, shouldValidate?: boolean) => void`\n\nSet the value of a `field` imperatively. `field` should match the key of `values` you wish to update. Useful for creating custom input change handlers. Calling this will trigger validation to run if `validateOnChange` is set to `true` (which it is by default). You can also explicitly prevent/skip validation by passing a third argument as `false`.\n\n##### `let:setFieldWarning: (field: string, warning: string) => void`\n\nSet the warning of a `field` imperatively. `field` should match the key of `warnings` you wish to update.\n\n##### `let:setStatus: (status?: any) => void`\n\nSet a top-level `status` to anything you want imperatively. Useful for controlling arbitrary top-level state related to your form. For example, you can use it to pass API responses back into your component in `handleSubmit`.\n\n##### `let:setSubmitting: (isSubmitting: boolean) => void`\n\nSet `isSubmitting` imperatively. You would call it with `setSubmitting(false)` in your `onSubmit` handler to finish the cycle.\n\n##### `let:setTouched: (fields: { [field: string]: boolean }, shouldValidate?: boolean) => void`\n\nSet `touched` imperatively. Calling this will trigger validation to run if `validateOnBlur` is set to `true` (which it is by default). You can also explicitly prevent/skip validation by passing a second argument as `false`.\n\n##### `let:setValues: (fields: { [field: string]: any }, shouldValidate?: boolean) => void`\n\nSet `values` imperatively. Calling this will trigger validation to run if `validateOnChange` is set to `true` (which it is by default). You can also explicitly prevent/skip validation by passing a second argument as `false`.\n\n##### `let:setWarnings: (fields: { [field: string]: string }) => void`\n\nSet `warnings` imperatively.\n\n##### `let:status: any`\n\nA top-level status object that you can use to represent form state that can't otherwise be expressed/stored with other methods. This is useful for capturing and passing through API responses to your inner component. `status` should only be modified by calling `setStatus`.\n\n##### `let:submitAttemptCount: number`\n\nNumber of times user tried to submit the form. Increases when `handleSubmit` is called, resets after calling `handleReset`.\n\n##### `let:submitFailure: () => void`\n\nIncrement `submitFailureCount` by 1 and calls `setSubmitting(false)`.\n\n##### `let:submitFailureCount: number`\n\nNumber of failed form submissions. Increases when `submitFailure` is called, resets after calling `handleReset`.\n\n##### `let:submitForm: () => Promise`\n\nTrigger a form submission. The promise will be rejected if form is invalid.\n\n##### `let:submitSuccess: () => void`\n\nIncrement `submitSuccessCount` by 1 and calls `setSubmitting(false)`.\n\n##### `let:submitSuccessCount: number`\n\nNumber of successful form submissions. Increases when `submitSuccess` is called, resets after calling `handleReset`.\n\n##### `let:touched: { [field: string]: boolean }`\n\nTouched fields. Each key corresponds to a field that has been touched/visited.\n\n##### `let:values: { [field: string]: any }`\n\nYour form's values.\n\n##### `let:validateForm: (values?: any) => void`\n\nImperatively call `validate`. You can optionally pass values to validate against and this modify Sveltik state accordingly, otherwise this will use the current `values` of the form.\n\n##### `let:validateField: (field: string) => void`\n\nImperatively call field's `validate` function if specified for given field. Sveltik will use the current field value.\n\n##### `let:warnings: { [field: string]: string }`\n\nForm warnings. Should match the shape of your form's values defined in `initialValues`.\n\n#### Differences with Formik\n\n- Validation is synchronous\n- Includes support for field warnings with `warnings`, `setWarnings`, `setFieldWarning`\n- Includes support for submission success/failure with `submitSuccess` and `submitFailure` helpers\n- Tracks `submitAttemptCount`, `submitFailureCount` and `submitSuccessCount` instead of only `submitCount`\n- If `onSubmit` returns a promise, it's rejection calls `submitFailure` and it's resolution calls `submitSuccess`\n- Does not (yet) implement Yup or `validateSchema`\n\n## `<Field />`\n\n`<Field />` will automagically hook up inputs to Sveltik. It uses the name attribute to match up with Sveltik state.\nWith no options passed, `<Field />` will default to an HTML `<input />` element.\n\n### Example\n\n[Open in REPL](https://svelte.dev/repl/47dade3d6be14be685c0347e0d525de7?version=3)\n\n**MyInput.svelte**\n\n```html\n<script>\n    export let field\n    export let props\n</script>\n\n<input {...field} {...props} on:input={field.handleInput} on:blur={field.handleBlur} />\n```\n\n**App.svelte**\n\n```html\n<script>\n    import { Sveltik, Form, Field } from 'sveltik'\n    import MyInput from './MyInput.svelte'\n</script>\n\n<div>\n    <h1>My Form</h1>\n    <Sveltik\n        initialValues={{ email: '', color: 'red', firstName: '', lastName: '' }}\n        onSubmit={(values, actions) => {\n            setTimeout(() => {\n                alert(JSON.stringify(values, null, 2))\n                actions.setSubmitting(false)\n            }, 1000)\n        }}\n    >\n        <Form>\n            <Field type=\"email\" name=\"email\" placeholder=\"Email\" />\n            <Field as=\"select\" name=\"color\">\n                <option value=\"red\">Red</option>\n                <option value=\"green\">Green</option>\n                <option value=\"blue\">Blue</option>\n            </Field>\n\n            <Field name=\"firstName\" let:field let:meta>\n                <div>\n                    <input\n                        type=\"text\"\n                        placeholder=\"Jon\"\n                        {...field}\n                        on:input={field.handleInput}\n                        on:blur={field.handleBlur}\n                    />\n                    {#if meta.touched && meta.error}\n                        <div className=\"error\">{meta.error}</div>\n                    {/if}\n                </div>\n            </Field>\n\n            <Field name=\"lastName\" placeholder=\"Doe\" as={MyInput} />\n            <button type=\"submit\">Submit</button>\n        </Form>\n    </Sveltik>\n</div>\n```\n\n### Props\n\n- `as?: string | Component`\n- `name: string`\n- `validate?: (value: any) => undefined | string`\n\n### let:props\n\n- `let:field: FieldInputProps`\n- `let:form: SveltikBag`\n- `let:meta: FieldMetaProps`\n\n### Reference\n\n#### Props\n\n##### `as?: string | Component`\n\nEither a Svelte component or the name of an HTML element to render. Supports the following:\n\n- `input`\n- `select`\n- `textarea`\n\nSvelte components must `export let` the props that they expect to be passed.\nThe available props are match the let:props (see below). Also is passed an additional prop\n`props` which contains all additional props passed to `<Field />`.\n\n##### `name: string`\n\nA field's name in Sveltik state. Required.\n\n##### `validate?: (value: any) => undefined | string`\n\nYou can run independent field-level validations by passing a function to the `validate` prop.\nThe function will respect the `validateOnBlur` and `validateOnChange` config/props specified in the `<Field>`'s parent `<Sveltik>`.\n\nIf invalid, return a `string` containing the error message or return `undefined`.\n\n#### let:props\n\n##### `let:field: FieldInputProps`\n\nAn object that contains:\n\n- `name: string` - The name of the field\n- `value: any` - The value of the field\n- `handleInput: (e: HTMLInputEvent) => void` - Input handler to be bound with `on:input`\n- `handleBlur: (e: HTMLBlurEvent) => void` - Blur handler to be bound with `on:blur`\n\n##### `let:form: SveltikBag`\n\n##### `let:meta: FieldMetaProps`\n\nAn object that contains:\n\n- `initialError?: string` - The field's initial error if the field is present in `initialErrors`\n- `initialTouched?: boolean` - The field's initial value if the field is present in `initialTouched`\n- `initialValue?: any` - The field's initial value if the field is given a value in `initialValues`\n- `initialWarning?: string` - The field's initial warning if the field is given a value in `initialWarnings`\n- `error?: string` - The field's error message\n- `touched?: boolean` - Whether the field has been visited\n- `value?: any` - The field's value\n- `warning?: string` - The field's warning message\n\n#### Differences with Formik\n\n- Validation is synchronous\n- Event handlers must be set implictly with `on:input`, `on:blur` instead of spread attributes.\n- Nested field names (paths) are not supported.\n\n## `<Form />`\n\nForm is a small wrapper around an HTML `<form>` element that automatically hooks into Sveltik's `handleSubmit` and `handleReset`.\nAll other props are passed directly through to the DOM node.\n\n```js\n// so...\n<Form />\n\n// is identical to this...\n<form on:reset={props.handleReset} on:submit={props.handleSubmit} {...props} />\n```\n\n## `<ErrorMessage />`\n\n`<ErrorMessage />` is a component that renders the error message of a given field\nif that field has been visited (i.e.`touched[name] === true`) (and there is an `error` message present).\nIt expects that all error messages are stored for a given field as a string.\n\n### Props\n\n- `as?: string | Component`\n- `name: string`\n\n### let:props\n\n- `let:msg: string`\n\n### Reference\n\n#### Props\n\n##### `as?: string | Component`\n\nEither a Svelte component or the name of an HTML element to render.\nIf not specified, `<ErrorMessage />` will just return a string.\n\nSvelte components must `export let` the props that they expect to be passed.\nThe available props are match the let:props (see below).\nAlso is passed an additional prop `props` which contains all additional props passed to `<ErrorMessage />`.\n\n##### `name: string`\n\nA field's name in Sveltik state. Required.\n\n#### let:props\n\n##### `let:msg: string`\n\nA field's error message.\n\n#### Differences with Formik\n\n- Nested field names (paths) are not supported.\n- Uses `as` prop instead of `component` for consistency with `<Field />`\n\n## `<ScrollMarker />`\n\n`<ScrollMarker />` marks the DOM scroll position of a form element in the document.\nIt renders a zero-height div. Useful for scrolling to the first field with an error.\n\n### Props\n\n- `name: string`\n\n### Reference\n\n#### Props\n\n##### `name: string`\n\nA field's name in Sveltik state. Required.\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 43],
		[3603, 74],
		[3610, 87],
		[3617, 66],
		[3624, 54],
		[3631, 53],
		[3638, 49],
		[3645, 54],
		[3652, 22],
		[3659, 63],
		[3666, 111],
		[3673, 85],
		[3680, 162],
		[3687, 101],
		[3694, 49],
		[3701, 69],
		[3708, 46],
		[3715, 63],
		[3722, 58],
		[3729, 129],
		[3736, 80],
		[3743, 90],
		[3750, 86],
		[3757, 91],
		[3764, 144],
		[3771, 109],
		[3778, 164],
		[3785, 97],
		[3792, 96],
		[3799, 160],
		[3806, 184],
		[3813, 108],
		[3820, 115],
		[3827, 56],
		[3834, 92],
		[3841, 33],
		[3848, 88],
		[3855, 74],
		[3862, 128],
		[3869, 55],
		[3876, 112],
		[3883, 68],
		[3890, 143],
		[3897, 78],
		[3904, 100],
		[3911, 121],
		[3918, 119],
		[3925, 139],
		[3932, 80],
		[3939, 110],
		[3946, 77],
		[3953, 76],
		[3960, 48],
		[3967, 52],
		[3974, 78],
		[3981, 37],
		[3988, 62],
		[3995, 32],
		[4002, 22],
		[4009, 20],
		[4016, 22],
		[4023, 62],
		[4030, 53],
		[4037, 41],
		[4044, 41],
		[4051, 61],
		[4058, 39],
		[4065, 40],
		[4072, 49],
		[4079, 28],
		[4086, 25],
		[4093, 82],
		[4100, 80],
		[4107, 37],
		[4114, 42],
		[4121, 57],
		[4128, 25],
		[4135, 38]
	],
	"esm": true,
	"cjs": false
}
