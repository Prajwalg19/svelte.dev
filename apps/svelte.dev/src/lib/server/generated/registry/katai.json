{
	"name": "katai",
	"description": "Create simple, lightweight state management for Svelte 5 applications.",
	"repo_url": "https://github.com/srav001/katai",
	"authors": ["sravan-suresh"],
	"homepage": "https://github.com/srav001/katai#readme",
	"downloads": 15,
	"updated": "2024-03-10T13:59:39.441Z",
	"tags": ["miscellaneous"],
	"github_stars": 17,
	"typescript": true,
	"version": "0.1.5",
	"svelte_range": ">=5.0.0",
	"kit_range": "^2.5.0",
	"last_rune_check_version": "0.1.5",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "katai",
				"version": "0.1.5",
				"size": 48194
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "## ❗️ In Development ❗️\n\nThe project is still in development. Hoping to release it right before Svelte 5 release. You can find usable examples in `src/routes/+page.svelte`.\n\n- [x] [Virtual Store with Runes](https://github.com/srav001/katai/blob/a9ea77e81d8155bd39d25fc3bffe1412e88f75e1/src/routes/stores.ts#L9) ( Removed to re-implement using new primitives )\n- [x] Re-factor for Primitves\n- [x] Add caching support\n- [x] Add cache adapters\n- [x] Add Basic Store\n- [x] Add Writable Store\n- [ ] Add Virtual Store\n- [ ] Sync between tabs\n\n\n# katai\n\nKaṭai (meaning store in Tamil) is a simple and lightweight store implementation for Svelte 5.\n\n## Contents\n\n- [About](#about)\n- [Primitives](#primitives)\n- [Stores](#stores)\n\n## About\n\nThe basics of Katai is a few primitives that can be used to build any type of store. You can also build the store type you need with the help of these primitives.\n\nWe also provide a few pre-built variations to choose from the Stores options. Whichever feels the most suitable can be used.\n\nWe do not wish to restrict you to a particular pattern for all your stores. You can copy the one of the current stores implementation as a base and build from on top it.\n\nBy using our primitives the stores you create will also get all the features our primitives support like caching with the help of adapters. By default we provide 2 adapters for localStorage and Index DB. \n\n## Primitives\n\n- [Core Store](#createStore)\n- [Getter Function](#getter-function)\n- [Updater Function](#updater-function)\n- [Subscriber Type](#subscriber-type)\n- [Subscribe Function](#subscribe-function)\n- [ClearCache Function](#clearcache-function)\n\n### createStore\n\nCreates a primitive store with a specified name and initial state. It optionally configures caching for the store if specified in the options.\n\n#### Parameters\n\n- `storeName` (string): The name of the store being created. This name must be unique across the application.\n- `storeState` (InferedState): The initial state or value that will be stored in the created store. This is the data that the store will manage and provide access to.\n- `options` (StoreOptions, optional): Additional configuration options for creating the store. This may include settings for caching.\n\n#### Returns\n\n- `PrimitiveStore<InferedState>`: An object representing the created store. It includes the store name and a getter function for the store value.\n\n#### Usage Example\n\n```typescript\nconst userStore = createStore('user', { name: 'John Doe', age: 30 });\nconsole.log(userStore.name); // Output: 'user'\nconsole.log(userStore.value); // Output: { name: 'John Doe', age: 30 }\n\n// Returns\nPrimitiveStore<{\n  name: string;\n  age: number;\n}>;\n```\n\n### Getter Function\n\n```typescript\nfunction get<T, U>(store: PrimitiveStore<T>, derivation: (state: T) => U): Getter<U>;\n```\n\nThe `get` function is designed to create a getter function from a store and a derivation function. It applies the derivation function to the store's value, returning a new value of type `U`.\n\n- **Parameters:**\n\n  - `store`: An instance of `PrimitiveStore<T>`.\n  - `derivation`: A function that takes the current state of type `T` and returns a value of type `U`.\n\n- **Returns:** A `Getter<U>` function that, when called, returns a value of type `U`.\n\n### Updater Function\n\n```typescript\nfunction update<T, U, C = unknown>(store: PrimitiveStore<T>, mutator: (state: T, payload: C) => U): Updater<C>;\n```\n\nThe `update` function updates the store's value using a mutator function and a payload. It also handles caching if applicable.\n\n- **Parameters:**\n\n  - `store`: A `PrimitiveStore<T>` object.\n  - `mutator`: A function that updates the state of the store based on the provided payload.\n\n- **Returns:** An `Updater<C>` function that takes a payload of type `C`.\n\n### Subscribe Function\n\n```typescript\nfunction subscribe<T, U extends Subscribers<T>>(\n  store: PrimitiveStore<T>,\n  subscribers: [...U],\n  effect: (states: MapSources<U, T>) => void\n): () => void;\n```\n\nThe `subscribe` function allows subscribing to a primitive store with specified subscribers and an effect to be executed.\n\n- **Parameters:**\n\n  - `store`: A `PrimitiveStore<T>`.\n  - `subscribers`: An array of subscriber functions.\n  - `effect`: A function that performs an action based on the states provided.\n\n- **Returns:** A cleanup function to unsubscribe the effect.\n\n### ClearCache Function\n\n```typescript\nfunction clearCache(storeName: string): void;\n```\n\nThe `clearCache` function clears the cache for a specific store if it exists.\n\n- **Parameters:**\n  - `storeName`: The name of the store to clear from the cache.\n\nThis module provides a robust solution for managing state in TypeScript applications, with features like caching and subscription to state changes, enhancing performance and reactivity.\n\n#### EXAMPLE\n\n```typescript\nexport const test = createStore('test', {\n  counter: 0\n});\n\ntype StoreType = (typeof test)['value'];\n\nexport const testStore = {\n  get $value() {\n    return test.value;\n  },\n  get: <U extends unknown>(derivation: (val: StoreType) => U) => get(test, () => derivation(test.value)),\n  subscribe: <T extends Subscribers<StoreType>>(states: [...T], effect: (states: MapSources<T, StoreType>) => void) =>\n    subscribe(test, states, effect)\n};\n\ntestStore.subscribe([(state) => state.counter], ([value]) => {\n  console.log('counter', value);\n});\n\nconst interval = setInterval(() => {\n  testStore.$value.counter = testStore.$value.counter + 1;\n}, 2000);\n\n// cleanup\nonDestroy(() => {\n  clearInterval(interval);\n});\n```\n\n## Stores\n\n### Basic Store\n\nThe `createBasicStore` function is designed to create a basic store structure in TypeScript, facilitating state management in applications. This function is part of a larger library that provides utilities for creating, managing, and interacting with stores. Below is a detailed documentation of the `createBasicStore` function, including its parameters, return type, and usage examples.\n\n## Function Signature\n\n```typescript\nfunction createBasicStore<S extends State, G extends Getters<S>, A extends Actions<S>>(\n  storeName: string,\n  options: Store<S, G, A>,\n  settings?: StoreOptions\n): BasicStore<S, G, A>;\n```\n\n### Parameters\n\n- `storeName: string`: A string that represents the name of the store being created. This name is used internally for identification and possibly for caching purposes.\n\n- `options: Store<S, G, A>`: An object that specifies the initial state, getters, and actions for the store. The `options` object must conform to the `Store` type, which is a generic type parameterized by the state `S`, getters `G`, and actions `A`.\n\n  - `state: S`: The initial state of the store. It is a record type with keys as `string` or `number` and values of any type.\n  - `getters: G`: An object containing getter functions. Each getter function takes the current state as an argument and returns a computed value based on that state.\n  - `actions: A`: An object containing action functions. Each action function is responsible for updating the state based on the given payload.\n\n- `settings?: StoreOptions` (Optional): An optional parameter that allows providing additional settings or configurations for the store creation process. These settings can include options such as the store's persistence mechanism using cache adapters.\n\n### Return Type\n\n- `BasicStore<S, G, A>`: The function returns an object of type `BasicStore<S, G, A>`, which includes the state, getters, actions, and additional methods like `clearCache` and `subscribe`. This object provides a simplified interface for interacting with the store, including performing state updates and subscribing to state changes.\n\n### Additional Methods\n\n- `clearCache`: A method that clears the cache associated with the store. Useful for resetting the store's state in scenarios involving caching.\n\n- `subscribe`: A method that allows subscribing to state changes. It takes a set of subscribers and an effect function, which is called whenever the subscribed state changes.\n\n#### Usage Example\n\n```typescript\n// Define the initial state, getters, and actions for a simple counter store.\nconst counterOptions = {\n  state: { count: 0 },\n  getters: {\n    doubleCount: (state) => state.count * 2\n  },\n  actions: {\n    increment: (state) => ({ count: state.count + 1 }),\n    decrement: (state) => ({ count: state.count - 1 })\n  }\n};\n\n// Create the counter store.\nconst counterStore = createBasicStore('counterStore', counterOptions);\n\n// Use the store's methods.\nconsole.log(counterStore.doubleCount()); // Output: 0 (double of initial count)\ncounterStore.increment();\nconsole.log(counterStore.doubleCount()); // Output: 2 (double of updated count)\n```\n\nThis example demonstrates how to create a basic store for managing a counter's state, including incrementing and decrementing actions, and a getter for computing the double of the current count.\n\n### Writable Store\n\nThe `createWritable` function is designed to create a writable store that allows for managing and tracking state changes in a structured way. It's based on the writable from Svelte.\n\n### Function Signature\n\n```typescript\nfunction createWritable<T extends Record<string, any>>(\n  initalValue: T,\n  storeName?: string,\n  storeOptions?: StoreOptions\n): {\n  get: () => T;\n  set: (val: T) => void;\n  update: (callback: (val: T) => T) => void;\n  subscribe: (subscriber: (val: T) => void) => void;\n  clearCache: () => void;\n};\n```\n\n### Parameters\n\n- `initalValue: T` - The initial value to be stored. It must be an object that extends `Record<string, any>`. This value serves as the starting point for the store's state.\n\n- `storeName: string` (optional) - A string representing the name of the store. If not provided, a random string will be generated and used as the store name. This name is used for identifying the store uniquely.\n\n- `storeOptions: StoreOptions` (optional) - Additional options for store creation. These options can include configuration settings or options specific to the underlying store implementation. Providing this parameter allows for further customization of the store's behavior.\n\n### Return Value\n\nThe function returns an object containing the following properties:\n\n- `get: () => T` - A function that retrieves the current value from the store.\n\n- `set: (val: T) => void` - A function that updates the value in the store with the provided value.\n\n- `update: (callback: (val: T) => T) => void` - A function that takes a callback function as an argument. The callback function is used to update the value in the store based on the current state.\n\n- `subscribe: (subscriber: (val: T) => void) => void` - A function that allows subscribing to changes in the store. The subscriber function is called with the new state whenever the store's value changes.\n\n- `clearCache: () => void` - A function that clears the cache associated with the store name. This is useful for resetting the store's state or when the store is no longer needed.\n\n#### Usage Example\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n}\n\n// Creating a writable store for user data\nconst userStore = createWritable<User>({ id: '123', name: 'John Doe' });\n\n// Subscribing to changes in the user store\nuserStore.subscribe((currentUser) => {\n  console.log('Current user:', currentUser);\n});\n\n// Updating the user's name\nuserStore.update((currentUser) => ({ ...currentUser, name: 'Jane Doe' }));\n\n// Setting a new user\nuserStore.set({ id: '456', name: 'Alice' });\n\n// Getting the current user\nconsole.log('Current user:', userStore.get());\n\n// Clearing the cache\nuserStore.clearCache();\n```\n\nThis documentation provides a comprehensive overview of the `createWritable` function, its parameters, return value, and usage.\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3694, 462],
		[3701, 36],
		[3708, 21],
		[3715, 369],
		[3722, 57],
		[3729, 8],
		[3736, 15],
		[3743, 4],
		[3750, 12],
		[3757, 15],
		[3764, 16],
		[3771, 2],
		[3778, 24],
		[3785, 4],
		[3792, 3],
		[3799, 3],
		[3806, 2],
		[3820, 1],
		[3834, 77],
		[3841, 5],
		[3848, 10],
		[3855, 5],
		[3862, 2],
		[3869, 3],
		[3883, 1],
		[3890, 70],
		[3897, 16],
		[3904, 2],
		[3911, 9],
		[3918, 5],
		[3925, 5],
		[3932, 4],
		[3939, 3],
		[3946, 6],
		[3953, 27],
		[3960, 5],
		[3967, 4],
		[3974, 4],
		[3981, 12],
		[3988, 5],
		[3995, 5],
		[4002, 1],
		[4016, 2],
		[4023, 20],
		[4030, 4],
		[4037, 23],
		[4044, 19],
		[4051, 4],
		[4065, 1],
		[4079, 20],
		[4086, 3],
		[4093, 2],
		[4100, 45],
		[4107, 6],
		[4114, 15],
		[4121, 16],
		[4128, 21]
	]
}
