{
	"name": "svelte-kit-isolated-stores",
	"description": "Use stores in SvelteKit during SSR without modifying server state.",
	"repo_url": "https://gitlab.com/x3ro/svelte-kit-isolated-stores",
	"authors": ["x3ro"],
	"homepage": "https://gitlab.com/x3ro/svelte-kit-isolated-stores#readme",
	"downloads": 4,
	"updated": "2022-07-18T12:59:10.550Z",
	"tags": ["miscellaneous"],
	"typescript": true,
	"version": "1.0.0-alpha.3",
	"svelte_range": "^3.44.3",
	"kit_range": "^1.0.0-next.232",
	"last_rune_check_version": "1.0.0-alpha.3",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-kit-isolated-stores",
				"version": "1.0.0-alpha.3",
				"size": 75055
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# SvelteKit Isolated Stores <!-- omit in toc -->\n\n__Use stores in SvelteKit during SSR as you are used to from Svelte* without\nmodifying server state.__\n\n<small>_* with minimal boilerplate code_</small>\n\n[![NPM version](https://img.shields.io/npm/v/svelte-kit-isolated-stores?logo=npm)](https://www.npmjs.com/package/svelte-kit-isolated-stores)\n[![NPM license](https://img.shields.io/npm/l/svelte-kit-isolated-stores)](https://gitlab.com/x3ro/svelte-kit-isolated-stores/-/blob/main/LICENSE)\n[![npm type definitions](https://img.shields.io/npm/types/svelte-kit-isolated-stores?logo=typescript)](https://www.typescriptlang.org/)\n[![Created for SvelteKit](https://img.shields.io/badge/created%20for-SvelteKit-%23ff3e00?logo=svelte)](https://kit.svelte.dev/)\n[![GitLab](https://img.shields.io/static/v1?label=GitLab&message=x3ro%2Fsvelte-kit-isolated-stores&color=%23f96424&logo=gitlab)](https://gitlab.com/x3ro/svelte-kit-isolated-stores)\n[![Emoji-Log](https://img.shields.io/badge/%F0%9F%9A%80-Emoji--Log-%238679A2)](https://github.com/ahmadawais/Emoji-Log/)\n\n\n---\n\n- [üî• The Issue](#-the-issue)\n- [üí° The Solution](#-the-solution)\n- [üíª Installation](#-installation)\n- [üöÄ Quickstart](#-quickstart)\n- [‚öôÔ∏è How does it Work (Implementation Details)](#Ô∏è-how-does-it-work-implementation-details)\n- [üìñ Documentation](#-documentation)\n  - [üè™ Defining Stores](#-defining-stores)\n    - [`defineStore()`](#definestore)\n    - [`defineWritable()`](#definewritable)\n    - [`defineReadable()`](#definereadable)\n    - [`defineDerived()`](#definederived)\n  - [üö© Extra Context for Stores (or: \"Be careful with Closures\")](#-extra-context-for-stores-or-be-careful-with-closures)\n  - [üõí Using Stores](#-using-stores)\n    - [During Component Initialization](#during-component-initialization)\n    - [In the template](#in-the-template)\n    - [During `load`ing](#during-loading)\n      - [`loadWithStores()`](#loadwithstores)\n    - [Outside Component Initializion and outside `load()`](#outside-component-initializion-and-outside-load)\n      - [In the Browser](#in-the-browser)\n      - [On the Server](#on-the-server)\n  - [‚òéÔ∏è `fetch` in Stores](#Ô∏è-fetch-in-stores)\n- [üë§ Author](#-author)\n- [üìÑ License](#-license)\n\n---\n\n\n\n## üî• The Issue\n\n[Svelte](https://svelte.dev/) is great. But even though it is very fast to\nrender a page *in the browser* with Svelte, it has some drawbacks compared to\nserver side rendered HTML:\n\n- Displaying pre-rendered HTML is faster\n- Indexing / SEO is not going to work without executing JS\n- Static pages need JS to be displayed even though they would not have to\n\n[SvelteKit](https://kit.svelte.dev/) solves these (and more) using Server Side\nRendering ([SSR](https://kit.svelte.dev/docs#appendix-ssr)). But it comes with\nit's own caveats:\n\nIf you create a [store](https://svelte.dev/tutorial/writable-stores) in a module\n(i.e. exported from a `.ts` or `.js` file) or defined globally inside a `<script\ncontext=\"module\">` tag, this store will only be created once on the server, when\nthe server loads the module for the first time\n\nIf your component uses such a store during\n[loading](https://kit.svelte.dev/docs#loading) or during component\ninitialization while rendering on the server, then your component\ndepends on the state of the store on the server side.\n\nIf yor component then also writes to the store during SSR, it alters server\nstate! This means, that for **all upcoming requests**, the value of the store\n**will be changed**. In the best case, this results in \"flickering\", when\nreloading the page, where the SSR version of the page has old data which is\nshortly displayed until the\n[hydration](https://kit.svelte.dev/docs#appendix-hydration) replaces it with the\nupdated value.\n\n**üî• In the worst case, it leaks private information of one user to other users!\nüî•**\n\n\n\n## üí° The Solution\n\nSvelteKit has a concept called the\n[session](https://kit.svelte.dev/docs#loading-input-session). It is a\nserializable JavaScript object which is used to pass data from the server to the\nclient. The session object is created on the server **per request**.\n\nThe *Isolated Stores* of this package use these session objects to tell appart\ndifferent requests, and *re-creates the stores for each new session*.\n\nAs a positive side effect, it enables\n[custom store functions](https://svelte.dev/tutorial/custom-stores) to use\nSvelteKit's [`fetch`](https://kit.svelte.dev/docs#loading-input-fetch) method,\nwhich serializes the responses of requests made during SSR and sends them along\nthe rendered page so that the client does not need to do the same request again\nduring [hydration](https://kit.svelte.dev/docs#appendix-hydration).\n\n\n\n## üíª Installation\n\n```bash\nnpm install -D svelte-kit-isolated-stores\n```\n\nBecause this package relies on SvelteKit's generated code, you have to prevent\nVite from building it in advance. To do that, add the following to your\n`svelte.config.js`:\n\n```javascript\n// svelte.config.js\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n    // ...\n    kit: {\n        // ...\n        vite: {\n            optimizeDeps: {\n                exclude: [\"svelte-kit-isolated-stores\"],    // <-- Add this line\n            },\n            ssr: {\n                noExternal: [\"svelte-kit-isolated-stores\"], // <-- Add this line\n            },\n        },\n    },\n}\n\nexport default config\n```\n\n\n\n## üöÄ Quickstart\n\nFollow the [installation guide](#-installation). Then add the following to your\ntop level `__layout.svelte` and any `__layout.reset.svelte` files:\n\n```html\n<!-- `__layout.svelte` and any `__layout.reset.svelte` -->\n\n<script lang=\"ts\" context=\"module\">\n    import { loadWithStores } from 'svelte-kit-isolated-stores'\n\n    export const load = loadWithStores()\n</script>\n\n<slot />\n```\n\nTo learn how to use a custom `load` function and how to use stores within it,\nhave a look at [`loadWithStores()`](#loadwithstores).\n\nDefine stores using [`defineWritable()`](#definewritable),\n[`defineReadable()`](#definereadable) and [`defineDerived()`](#definederived).\nThey work almost exactly like their svelte counterparts but the initial value is\nprovided through a function.\n[Custom stores](https://svelte.dev/tutorial/custom-stores) can be defined with\n[`defineStore()`](#definestore):\n\n```typescript\n// src/lib/stores.ts\n\nimport { defineStore, defineWritable, defineReadable, defineDerived } from 'svelte-kit-isolated-stores'\nimport { writable } from 'svelte/store'\n\nexport const count = defineWritable(() => 0)\n\nexport const double = defineDerived(count, $count => $count * 2)\n\nexport const time = defineReadable(\n    // The initial value creator\n    () => new Date(),\n    // The start function called when the first subscriber subscribes\n    (set) => {\n        set(new Date())\n        const interval = setInterval(() => {\n            set(new Date())\n        }, 1000)\n\n        // Return the stop function called when the last subscriber unsubscribes\n        return () => {\n            clearInterval(interval)\n        }\n    },\n)\n\n// Get SvelteKit's `fetch` by destructuring the function argument\n//       `-------------------------vvvvv\nexport const user = defineStore(({ fetch }) => {\n    const { subscribe, set, update } = writable()\n\n    async function loadUser(uid: string) {\n        // Use `fetch` -----------vvvvv\n        const data = await (await fetch(`/api/user/${uid}`)).json()\n        set(data)\n    }\n\n    return {\n        subscribe,\n        set,\n        update,\n\n        loadUser,\n    }\n})\n```\n\nOn your pages, you can use the stores in the `load` function using the\n`loadWithStores()` function. In the template, use the store as you are used to\nfrom Svelte.\n\n```html\n<!-- src/routes/users/[userUid].svelte -->\n\n<script lang=\"ts\" context=\"module\">\n    import { loadWithStores } from 'svelte-kit-isolated-stores'\n    import { user } from '$lib/stores'\n\n    export const load = loadWithStores(\n        { user },\n        async ({ user }, { params }) => {\n            await user.loadUser(params['userUid'])\n\n            return {}\n        }\n    )\n</script>\n\n<script lang=\"ts\">\n    import { count, double as useDouble, time } from './_stores'\n\n    // Get the real store instance.\n    // (Not necessary for this example. See documentation to see where it\n    // is useful.)\n    const double = useDouble()\n\n    function increment() {\n        count.update((n) => n + 1)\n    }\n\n    function decrement() {\n        count.update((n) => n - 1)\n    }\n\n    $: square = $count * $count\n\n    $count = 10\n</script>\n\n<div>\n    The current date and time is {$time.toLocaleString()}\n</div>\n\n<div>\n    <button on:click={decrement}>‚ûñ</button>\n    {$count}\n    <button on:click={increment}>‚ûï</button>\n</div>\n\n<div>\n    <div>Doubled: {$double}</div>\n    <div>Squared: {square}</div>\n</div>\n\n<div>\n    Loaded User:\n    <pre><code>{JSON.stringify($user)}</code></pre>\n</div>\n\n```\n\nTo try the above example, you may also want to create the used API endpoint at\n`src/routes/api/user/[userUid].ts` and paste the following:\n\n```typescript\nimport type { RequestHandler } from '@sveltejs/kit'\n\nexport const get: RequestHandler = ({ params }) => {\n    const userUid = params['userUid']\n\n    return {\n        body: {\n            uid: userUid,\n            name: 'M1000',\n            firstName: 'Moritz',\n            lastName: 'Zimmermann',\n        },\n    }\n}\n```\n\n\n\n## ‚öôÔ∏è How does it Work (Implementation Details)\n\nEvery store defined with `defineStore` or one of the helper functions, is\nwrapped in a\n[JS `Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\nand when a property of the store (eg. the `subscribe` or `set` function) is\naccessed, the `Proxy` looks up the store for the current session and returns the\nproperty of that store.\n\nIf the store does not exist for the current session yet, it is created and saved\nto a\n[`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\nso the store can be retrieved if it is used again during the same request.\n\nThe `WeakMap` is used to map from the *session object* to a `Map` of stores.\nDoing so makes sure, that the garbage collector can clean away stores of\nsessions that do not exist anymore, after a request is done.\n\nOn the client side, it works the same way but of course there is always only one\nsession object. It would be possible to just return the store instead of the\n`Proxy` on the client, although this would prevent the aforementioned ability to\nuse SvelteKit's `fetch` function in custom store functions. This is because with\nthe `Proxy`, the store is created lazily when needed and not when the store\nmodule is loaded, which means we can pass in `fetch` from the `load` function.\n\n\n\n## üìñ Documentation\n\n\n\n### üè™ Defining Stores\n\n\n\n#### `defineStore()`\n\nThis package provides a `defineStore()` method that takes a function, that\ncreates a [custom store](https://svelte.dev/tutorial/custom-stores).\n\nIn Svelte, a store is defined as an object that has at least a `subscribe()`\nmethod which, when executed, returns an method to unsubscribe.\n\nIt can then also have other properties or methods. Common methods are `set()`\nand `update()` which are used to set and update the value of the store.\n\nYou can also include custom methods. In the example below, the methods\n`increment()`, `decrement()` and `reset()` are also added to the store object to\nmake it more easy to use the `counter`.\n\n```typescript\n// counter.ts\n\nimport { defineStore } from 'svelte-kit-isolated-stores'\nimport { writable } from 'svelte/store'\n\nexport const counter = defineStore(() => {\n    const { subscribe, set, update } = writable(0)\n\n    function increment() {\n        update(val => val + 1)\n    }\n\n    function decrement() {\n        update(val => val - 1)\n    }\n\n    return {\n        subscribe, // You need to return at least `subscribe`\n        set,\n        update,\n\n        increment,\n        decrement,\n        reset: () => set(0),\n    }\n})\n```\n\n\n\n#### `defineWritable()`\n\nYou do however not need to create custom stores for every simple store you have.\n`defineWritable()` is a helper function, that creates a writable store with an\ninitial value.\n\nThe difference to Svelte's `writable()` function is, that you need to provide a\nfunction (arrow function in this example) to create the initial value. This is\nnecessary because the store must be re-created over and over again and if the\ninitial value is a reference type like an object or an array, different\ninstances of the same store would share this data.\n\n```typescript\n// count.ts\n\nimport { defineWritable } from 'svelte-kit-isolated-stores'\n\n// --- Initial value creator -------vvvvvvv\nexport const count = defineWritable(() => 0)\n\n```\n\n\n\n#### `defineReadable()`\n\nTo define simple readable stores use the helper function `defineReadable()`.\nLike with `defineWritable()` the initial value must be returned from a function.\n\nThe second argument is the `start` function. This should be familiar from\nSvelte's `readable()` stores.\n\n```typescript\n// time.ts\n\nimport { defineReadable } from 'svelte-kit-isolated-stores'\n\nexport const time = defineReadable(\n    // The initial value creator\n    () => new Date(),\n    // The start function called when the first subscriber subscribes\n    (set) => {\n        set(new Date())\n        const interval = setInterval(() => {\n            set(new Date())\n        }, 1000)\n\n        // Return the stop function called when the last subscriber unsubscribes\n        return () => {\n            clearInterval(interval)\n        }\n    },\n)\n```\n\n\n\n#### `defineDerived()`\n\nDerived stores change their value depending on other stores. Use the helper\nfunction `defineDerived()` to create an isolated derived store.\n\nLike with Svelte's\n[`derived()`](https://svelte.dev/docs#run-time-svelte-store-derived) method, it\nis possible to pass a single store or an array of one or more dependent stores\nto `defineDerived()`.\n\nWhen deriving from a single store, the dependent store can be provided without\nbeing encapsulated in an array. The first argument of the callback function is\nthen just the store value.\n\n```typescript\n// double.ts\n\nimport { defineWritable, defineDerived } from 'svelte-kit-isolated-stores'\n\nexport const someValue = defineWritable(() => 0)\n\nexport const double = defineDerived(someValue, $someValue => $someValue * 2)\n```\n\nMultiple stores can be derived from by passing them as an array. The first\nargument of the callback function is then an array of store values instead of\njust a single store value. The array can be destructured to arbitrary names\n(however it is convention to prefix the store names with `$` for the values).\n\n```typescript\n// rectangle.ts\n\nimport { defineWritable, defineDerived } from 'svelte-kit-isolated-stores'\n\nexport const width = defineWritable(() => 0)\nexport const height = defineWritable(() => 0)\n\nexport const area = defineDerived(\n    [width, height],\n    ([$width, $height]) => $width * $height\n)\n```\n\nContrary to Svelte's `derive()` it is also possible to pass an object containing\ndependent stores to `defineDerived()`. The first argument of the callback\nfunction is then an object of store values where each key of the stores object\nis prefixed with a `$`.\n\nThis feature is added to increase DX (developer experience), because by using\nobjects (together with TypeScript), the intellisense can help with\ndestructuring. It can can also help to reduce bugs, as swapping the positions of\nthe stores in the input object does not silently change the order of the store\nvalues (as they would in the array example above).\n\n> However, keep in mind that this adds a layer on top of the original\n> `derived()` implementation and, for *very* frequently changing stores, this\n> *might* impact performance.\n\n```typescript\n// rectangle.ts\n\nimport { defineWritable, defineDerived } from 'svelte-kit-isolated-stores'\n\nexport const width = defineWritable(() => 0)\nexport const height = defineWritable(() => 0)\n\nexport const area = defineDerived(\n    // Dependent stores are passed in as object (using object property value\n    // shorthand)\n    { width, height },\n    // The object can directly be destructured. Keep in mind, that every key has\n    // been prefixed with `$`.\n    ({ $width, $height }) => $width * $height,\n)\n\nexport const diagonal = defineDerived(\n    { width, height },\n    // Of course, you can assign different names using destructuring syntax\n    ({ $width: w, $height: h }) => Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)),\n)\n```\n\n\n\n### üö© Extra Context for Stores (or: \"Be careful with Closures\")\n\n[Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) is\nthe concept of bundling togehter a function with it's surrounding state or\n*context*. It let's you access variables that are defined in the outside scope\nof the function.\n\nWhen using stores on the server side, using closures might have some side\neffects:\n\nFor example the Svelte tutorial for\n[derived stores](https://svelte.dev/tutorial/derived-stores) uses a global\nvariable `start` which contains a `Date`. This `start` variable is initialized\nwhen the module (the file) is first being loaded. In the browser this behaves as\nexpected: `start` contains the `Date` when the page has loaded.\n\nOn the server however, this would not be re-evaluated on every request and\ntherefore would contain the date of the first request (or more precise the date\nthe module has first been loaded on the server).\n\n**üî• In the worst case, this can leak private information of one user to other\nusers! üî•**\n\nTo achieve the same behaviour as in the Svelte tutorial, you can use\n`defineStore()` and return a derived store instead of a custom store object:\n\n```typescript\n// time.ts\n\nimport { defineStore, defineReadable } from 'svelte-kit-isolated-stores'\nimport { derived } from 'svelte/store'\n\nexport const time = defineReadable(\n    () => new Date(),\n    (set) => {\n        const interval = setInterval(() => {\n            set(new Date())\n        }, 1000)\n\n        return () => { clearInterval(interval) }\n    },\n)\n\nexport const elapsed = defineStore(() => {\n    const start = new Date()\n\n    // Instead of returning an object with a `subscribe()` method, you can just\n    // return a plain Svelte store. It is safe to use sveltes `derived()` here,\n    // as it will be re-created when the store defined by `defineStore()` is\n    // recreated.\n    return derived(\n        time,\n        ($time) => Math.round(($time.getTime() - start.getTime()) / 1000),\n    )\n})\n```\n\n\n\n### üõí Using Stores\n\n\n\n#### During Component Initialization\n\nYou can use the store as if it was a normal Svelte store during component\ninitialization:\n\n```html\n<script language=\"ts\">\n    import { counter } from '$lib/stores/counter'\n\n    // Use auto-subscription syntax\n    $counter = 10\n</script>\n\n{$counter}\n```\n\n> During component initializion the store isolation mechanism has access to\n> `$app/stores` and can extract the session objectfrom there. This session is\n> crucial to be able to know which stores belong to the current request.\n\n\n\n#### In the template\n\nJust don't think about it!\n\n```html\n<script language=\"ts\">\n    import { counter } from '$lib/stores/counter'\n</script>\n\n<h1>The count is: {$counter}</h1>\n\n<div>\n    <button on:click={counter.decrement}>‚ûñ</button>\n    <button on:click={counter.increment}>‚ûï</button>\n</div>\n\n<div>\n    <label>\n        Count:\n        <input type=\"number\" bind:value={$counter} />\n    </label>\n</div>\n\n```\n\n\n\n#### During `load`ing\n\nLayouts and pages in SvelteKit can export a `load` function, which is executed\nbefore the component is initialized (a layout / page is also just a Svelte\ncomponent).\n\nWhen not in *component initialization*, the isolation mechanism does not have\naccess to the current session object through `$app/stores`. Therefore, we must\npass the `session` object of the input argument of the load function to the\nisolation logic.\n\nWe **could** do that by **calling** the store as if it was a function and we\npass in the `input` argument of the `load` function:\n\n```html\n<script lang=\"ts\" context=\"module\">\n    import { counter } from '$lib/stores/counter'\n    import type { Load } from '@sveltejs/kit'\n\n    export const load: Load = (input) => {\n        // This is now the real store instance\n        const _counter = counter(input)\n\n        // For some reason we want the counter value to be `1337` on this page ¬Ø\\_(„ÉÑ)_/¬Ø\n        _counter.set(1337)\n\n        // Don't forget to return an object, otherwise you'll get a 404\n        return {}\n    }\n</script>\n\n{$counter}\n```\n\nThis might look a bit strange at first and is also a little boilerplaty. But\ndon't worry, you will not need to do this too often thanks to another\nconvenience function:\n\n\n\n##### `loadWithStores()`\n\nThis function is used to wrap the actual `load` function. It can be used in a\nvariety of ways. But all of them include exporting the result as `load` in the\n`module` context of a layout of page component.\n\n1. You can just call it without arguments. This makes sure that the stores get\n    access to SvelteKit's `fetch` function (more on that later).\n\n    It also does some \"magic\" to make things easier for code that runs\n    exclusively in the browser (and by \"magic\" I mean, it stores the session in\n    a global variable, because in the browser there is no server state that can\n    be modified üòâ).\n\n    It is generally a good idea to do this in the top level `__layout.svelte`\n    and any `__layout.reset.svelte` files.\n\n    ```html\n    <script lang=\"ts\" context=\"module\">\n        import { loadWithStores } from 'svelte-kit-isolated-stores'\n\n        export const load = loadWithStores()\n    </script>\n\n    <slot />\n    ```\n\n    Calling without arguments will export a load function that effectively\n    returns `{}` to prevent a `404` error.\n\n2. You can also pass in a custom load function.\n\n    ```html\n    <script lang=\"ts\" context=\"module\">\n        import { loadWithStores } from 'svelte-kit-isolated-stores'\n\n        export const load = loadWithStores(({ params, fetch}) => {\n            const userId = params['id']\n            // Do some load logic here, maybe return `props` or `stuff` or whatever.\n\n            // Don't forget to return an object, otherwise you'll get a 404\n            return {}\n        })\n    </script>\n    ```\n\n3. You can pass in an object where each value is an isolated store as the first\n    argument and as the second argument, a custom `load` function. This custom\n    load function is provided with two arguments. The first is an object of\n    actual (not isolated) stores, the second is the `LoadInput` object that a\n    normal `load` function receive through the first argument.\n\n    ```html\n    <script lang=\"ts\" context=\"module\">\n        import { loadWithStores } from 'svelte-kit-isolated-stores'\n        import { counter } from '$lib/stores/counter'\n\n        export const load = loadWithStores({ counter }, ({ counter }, { params }) => {\n            // Inside this function, the `counter` variable contains the real store\n            // instance, not the isolated store\n\n            const userId = Number(params['userId'])\n\n            // For some reason we want the counter value to be the user id on this\n            // page ¬Ø\\_(„ÉÑ)_/¬Ø\n            counter.set(userId)\n\n            // Don't forget to return an object, otherwise you'll get a 404\n            return {}\n        })\n    </script>\n\n    {$counter}\n    ```\n\n\n\n#### Outside Component Initializion and outside `load()`\n\nThe isolation mechanism needs to know what the current session is. Outside\ncomponent initialization and outside `load()` there is no reliable way to access\nSvelteKit's `session` object in general.\n\n\n\n##### In the Browser\n\nConsider the following code:\n\n```html\n<script lang=\"ts\">\n    import { counter } from '$lib/stores/counter'\n    import { onMount } from 'svelte'\n    import { get } from 'svelte/store'\n\n    let counterVal\n\n    function incrementBy(n) {\n        // ERROR: Store used outside component initialization\n        counter.update((c) => {\n            counterVal = c + n\n            return counterVal\n        })\n    }\n</script>\n\n<button on:click=\"{() => incrementBy(1)}\">+1</button>\n<button on:click=\"{() => incrementBy(10)}\">+10</button>\n```\n\nThe `incrementBy()` method is executed *after* component initialization. So\nwhen it accesses the `update` property of `counter`, the isolation wrapper has\nno idea what the current session is. Normally this would fail. But there is a\nfix:\n\n**While in the browser**, there is only ever one session, so it is okay to work\nwith global variables here. Therefore, whenever the isolation mechanism first\ngets access to the `session` object, it stores a global reference to it, so it\ncan be accessed later.\n\nIf you use any isolated store during component initialization (e.g. you set\nit to some value or you subscribe to it) then the above example would work. But\n**you do not want to rely on someon else having used a store before you**.\n\nTherefore, to ensure the isolation mechanism *always* has access to the\n`session` (at least in the browser), make sure to use the `loadWithStores()`\nfunction (with or without arguments) in the top level `__layout.svelte` and any\n`__layout.reset.svelte` files:\n\n```html\n<!-- `__layout.svelte` and any `__layout.reset.svelte` -->\n<script lang=\"ts\" context=\"module\">\n    import { loadWithStores } from 'svelte-kit-isolated-stores'\n\n    export const load = loadWithStores()\n</script>\n```\n\n\n\n##### On the Server\n\nLuckily most code that runs outside component initialization and outside the\n`load` function is only ever run in the browser.\n\nFor example any event handlers do usually not run on the server and you should\navoid async code in your component initialization (outside the `load` function)\nduring SSR anyway, as it will not effect the rendered page HTML.\n\nAlso Svelte's `onMount()` function is only run in the browser.\n\nBut there is at least one situation where code runs on the server outside\ncomponent initialization:\n\nThe `onDestroy()` hook is triggert during SSR (or rather when SSR is done). And\nif you try to use an isolated store there, it will fail to access the `session`\nobject and throw an exception.\n\n> There may be other situation where this can happen, I just didn't encounter\n> others yet.\n\nTo mitigate this, you can either make sure the store is only accessed when in\nthe browser:\n\n```html\n<script lang=\"ts\">\n    import { onDestroy } from 'svelte'\n    import { browser } from '$app/env'\n    import { counter } from '$lib/stores/counter'\n\n    onDestroy(() => {\n        if (browser) {\n            counter.reset()\n        }\n    })\n</script>\n```\n\nOr you can get yourself an instance of the real store object during component\ninitialization and use it later:\n\n```html\n<script lang=\"ts\">\n    import { onDestroy } from 'svelte'\n\n    // Import the counter with an alias name (can be anything, but I like to\n    // prefix the name with `use` as a convention)\n    import { counter as useCounter } from '$lib/stores/counter'\n\n    // Get an instance of the real store object by calling the isolated store\n    const counter = useCounter()\n    // From here on, the store can be used *exactly* like in plain Svelte\n\n    onDestroy(() => {\n        counter.reset()\n    })\n</script>\n```\n\n\n\n### ‚òéÔ∏è `fetch` in Stores\n\nA positive side effect of the store isolation is, that you can use SvelteKit's\n`fetch` inside your defined stores.\n\nSvelteKit's `fetch` wrapper saves the results of requests that are executed\nduring SSR. To speed things up, SvelteKit then serializes the results and sends\nthem along with the generated page to the browser. During\n[hydration](https://kit.svelte.dev/docs#appendix-hydration), the result is\nre-used so the browser does not have to fetch the same data again. After\nhydration, it works just like the normal `fetch` function.\n\nAnother advantage of using SvelteKit's `fetch` is, that you can use relative\nURLs on the server side (i.e. you can use just the path to the API endpoint,\nwithout the `https://yourdomain.tld` part).\n\nWhen defining a custom store, you can access this `fatch` wrapper through the\nfunction arguments:\n\n```typescript\nimport { defineStore } from 'svelte-kit-isolated-stores'\nimport { writable } from 'svelte/store'\n\n// Get SvelteKit's `fetch` by destructuring the function argument\n//       `-------------------------vvvvv\nexport const user = defineStore(({ fetch }) => {\n    const { subscribe, set, update } = writable()\n\n    async function loadUser(uid: string) {\n        // Use `fetch` -----------vvvvv\n        const data = await (await fetch(`/api/user/${uid}`)).json()\n        set(data)\n    }\n\n    return {\n        subscribe,\n        set,\n        update,\n\n        // Export the `loadUser` function\n        loadUser,\n    }\n})\n```\n\n\n\n## üë§ Author\n\n<img src=\"https://i.imgur.com/4McE4JS.png\" width=\"30\"\nstyle=\"border-radius:30px; margin-bottom:-8px; margin-right:5px\" /> Bj√∂rn\nRichter (^x3ro)\n\n- Twitter: [@x3rAx](https://twitter.com/x3rAx)\n- GitLab: [@x3ro](https://gitlab.com/x3ro)\n- GitHub: [@x3rAx](https://github.com/x3rAx/)\n\n\n\n## üìÑ License\n\nCopyright ¬© 2019 Bj√∂rn Richter <<git@x3ro.dev>>  \nThis project is\n[MIT](https://gitlab.com/x3ro/svelte-kit-isolated-stores/-/blob/main/LICENSE)\nlicensed.\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 1],
		[3603, 4],
		[3617, 5],
		[3638, 7],
		[3645, 1],
		[3666, 6],
		[3694, 1],
		[3701, 1],
		[3715, 1],
		[3729, 4],
		[3743, 1],
		[3757, 3],
		[3764, 1],
		[3771, 5],
		[3792, 5],
		[3799, 1],
		[3820, 1],
		[3827, 1],
		[3841, 1],
		[3862, 1],
		[3869, 8],
		[3890, 5],
		[3911, 1],
		[3918, 1],
		[3939, 3],
		[3967, 2],
		[3981, 1],
		[3995, 1],
		[4016, 1],
		[4037, 11],
		[4044, 5],
		[4051, 2],
		[4065, 2],
		[4093, 3],
		[4100, 11],
		[4114, 4],
		[4121, 9],
		[4128, 3]
	]
}
