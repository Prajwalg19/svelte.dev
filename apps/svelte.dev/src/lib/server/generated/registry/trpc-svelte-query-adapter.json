{
	"name": "trpc-svelte-query-adapter",
	"description": "Integrate tRPC with Svelte Query for data fetching.",
	"repo_url": "https://github.com/vishalbalaji/trpc-svelte-query-adapter",
	"authors": ["vishalbalaji"],
	"homepage": "https://github.com/vishalbalaji/trpc-svelte-query-adapter#readme",
	"downloads": 230,
	"updated": "2025-03-24T10:40:20.413Z",
	"tags": ["server"],
	"github_stars": 81,
	"typescript": true,
	"version": "2.3.16",
	"svelte_range": "^5",
	"last_rune_check_version": "2.3.16",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "trpc-svelte-query-adapter",
				"version": "2.3.16",
				"size": 57988
			},
			{
				"name": "proxy-deep",
				"version": "4.0.1",
				"size": 15477
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "# `tRPC` - `svelte-query` Adapter\n\n[![NPM version][npm-image]][npm-url]\n[![License][license-image]][license-url]\n[![Last commit][last-commit-image]][repo-url]\n\n> [!NOTE]\n> The README on [npmjs](https://npmjs.com/trpc-svelte-query-adapter) might not be fully up to date. Please refer to\n> the [README on the Github Repo](https://github.com/vishalbalaji/trpc-svelte-query-adapter/#readme) for the latest setup instructions.\n\nAn adapter to call `tRPC` procedures wrapped with <code>[@tanstack/svelte-query](https://tanstack.com/query/latest/docs/svelte/overview)</code>, similar to <code>[@trpc/react-query](https://trpc.io/docs/react-query)</code>. This is made possible using <code>[proxy-deep](https://www.npmjs.com/package/proxy-deep)</code>.\n\n## Installation\n\n```sh\n# npm\nnpm install trpc-svelte-query-adapter @trpc/client @trpc/server @tanstack/svelte-query\n\n# yarn\nyarn add trpc-svelte-query-adapter @trpc/client @trpc/server @tanstack/svelte-query\n\n# pnpm\npnpm add trpc-svelte-query-adapter @trpc/client @trpc/server @tanstack/svelte-query\n```\n\nIf you are using client-side Svelte, you would need to install `@trpc/server` as a `devDependency` using `--save-dev`.\n\n## Available Functions\n\nThe following functions from `@trpc/react-query` are ported over:\n\n- `useQuery` -> `createQuery`\n- `useInfiniteQuery` -> `createInfiniteQuery`\n- `useMutation` -> `createMutation`\n- `useSubscription` -> `createSubscription`\n- `useQueries` -> `createQueries`\n- `useUtils` -> `createUtils`\n- `getQueryKey`\n\nYou can refer to <code>[tanstack-query docs](https://tanstack.com/query/latest/docs/react/overview)</code> and <code>[@trpc/react-query docs](https://trpc.io/docs/react-query)</code> for documentation on how to use them.\n\nThere are also some new procedures that are only relevant for SvelteKit:\n\n- `createServerQuery`\n- `createServerInfiniteQuery`\n- `createServerQueries`\n\nAs for these procedures, you can refer to the [Server-Side Query Pre-Fetching](#server-side-query-pre-fetching) section.\n\n## Usage\n\nThe following instructions assume the `tRPC` router to have the following procedures:\n\n```typescript\nexport const router = t.router({\n  greeting: t.procedure\n    .input((name: unknown) => {\n      if (typeof name === 'string') return name;\n\n      throw new Error(`Invalid input: ${typeof name}`);\n    })\n    .query(async ({ input }) => {\n      return `Hello, ${input} from tRPC v10 @ ${new Date().toLocaleTimeString()}`;\n    }),\n});\n\nexport type Router = typeof router;\n```\n\n### Client-Only Svelte\n\n1. Setup `@tanstack/svelte-query` as per [svelte-query docs](https://tanstack.com/query/latest/docs/svelte/overview).\n2. Setup <code>[@trpc/client](https://trpc.io/docs/client)</code> and export the `tRPC` client.\n3. Wrap the exported `tRPC` client with `svelteQueryWrapper` from `trpc-svelte-query-adapter`, as demonstrated in the example below:\n\n```typescript\n// src/lib/trpc.ts\nimport type { Router } from '/path/to/trpc/router';\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\n\nimport { svelteQueryWrapper } from 'trpc-svelte-query-adapter';\n\nconst client = createTRPCProxyClient<Router>({\n  links: [\n    httpBatchLink({\n      // Replace this URL with that of your tRPC server\n      url: 'http://localhost:5000/api/v1/trpc/',\n    }),\n  ],\n});\n\nexport const trpc = svelteQueryWrapper<Router>({ client });\n```\n\n4. The exported `tRPC` client can then be used in `svelte` components as follows:\n\n```svelte\n<script lang=\"ts\">\n  import { trpc } from \"/path/to/lib/trpc\";\n\n  const foo = trpc.greeting.createQuery('foo', { retry: false });\n</script>\n\n{#if $foo.isPending}\n  Loading...\n{:else if $foo.isError}\n  Error: {$foo.error.message}\n{:else if $foo.data}\n  {$foo.data.message}\n{/if}\n```\n\n### SvelteKit and SSR\n\nFor SvelteKit, the process is pretty much the same as for client-only svelte. However, if you intend to call queries from the server in a `load` function, you would need to setup `@tanstack/svelte-query` according to the [the ssr example in the svelte-query docs](https://tanstack.com/query/latest/docs/svelte/ssr#using-prefetchquery).\n\nUpon doing that, you would also need to pass in the `queryClient` to `svelteQueryWrapper` when initializing on the server, which you can get by calling the `event.parent` method in the `load` function. You can see an example of this in the [Server-Side Query Pre-Fetching](#server-side-query-pre-fetching) section. For this purpose, you might also want to export your client wrapped in a function that optionally takes in `queryClient` and passes it onto `svelteQueryWrapper`.\n\nHere is an example of what that might look like:\n\n```typescript\nimport type { QueryClient } from '@tanstack/svelte-query';\n\nconst client = createTRPCProxyClient<Router>({\n  links: [\n    httpBatchLink({\n      // Replace this URL with that of your tRPC server\n      url: 'http://localhost:5000/api/v1/trpc/',\n    }),\n  ],\n});\n\nexport function trpc(queryClient?: QueryClient) {\n  return svelteQueryWrapper<Router>({\n    client,\n    queryClient,\n  });\n}\n```\n\nWhich can then be used in a component as such:\n\n```svelte\n<!-- routes/+page.svelte -->\n<script lang=\"ts\">\n  import { trpc } from \"$lib/trpc/client\";\n\n  const client = trpc();\n  const foo = client.greeting.createQuery(\"foo\", { retry: false });\n</script>\n\n<p>\n  {#if $foo.isPending}\n    Loading...\n  {:else if $foo.isError}\n    Error: {$foo.error.message}\n  {:else}\n    {$foo.data}\n  {/if}\n</p>\n```\n\nThe main thing that needs to passed in to `svelteQueryWrapper` is the `tRPC` client itself. So, this adapter should support different implementations of `tRPC` for Svelte and SvelteKit. For example, if you are using <code>[trpc-sveltekit by icflorescu](https://icflorescu.github.io/trpc-sveltekit)</code>, all you would need to do after setting it up would be to change the client initialization function from something like this:\n\n```typescript\nlet browserClient: ReturnType<typeof createTRPCClient<Router>>;\n\nexport function trpc(init?: TRPCClientInit) {\n  const isBrowser = typeof window !== 'undefined';\n  if (isBrowser && browserClient) return browserClient;\n  const client = createTRPCClient<Router>({ init });\n  if (isBrowser) browserClient = client;\n  return client;\n}\n```\n\nto this:\n\n```typescript\nimport { svelteQueryWrapper } from 'trpc-svelte-query-adapter';\nimport type { QueryClient } from '@tanstack/svelte-query';\n\nlet browserClient: ReturnType<typeof svelteQueryWrapper<Router>>;\n\nexport function trpc(init?: TRPCClientInit, queryClient?: QueryClient) {\n  const isBrowser = typeof window !== 'undefined';\n  if (isBrowser && browserClient) return browserClient;\n  const client = svelteQueryWrapper<Router>({\n    client: createTRPCClient<Router>({ init }),\n    queryClient,\n  });\n  if (isBrowser) browserClient = client;\n  return client;\n}\n```\n\nWhich can then be initialized and used in the way that it is described [in its docs](https://icflorescu.github.io/trpc-sveltekit/getting-started).\n\n#### Server-Side Query Pre-Fetching\n\nThis adapter provides 3 additional procedures: `createServerQuery`, `createServerInfiniteQuery` and `createServerQueries`, which can be used to call their counterpart procedures in the `load` function in either a `+page.ts` or `+layout.ts`. These procedures return a `promise` and therefore can only really be called on the server.\n\nBy default, these 3 procedures will pre-fetch the data required to pre-render the page on the server. However, if you wish to disable this behaviour on certain queries, you can do so by setting the `ssr` option to `false`.\n\nThese procedures can be used as such:\n\n> [!NOTE] \n> [Gotta await top-level promises to pre-fetch data from SvelteKit v2](https://kit.svelte.dev/docs/migrating-to-sveltekit-2#top-level-promises-are-no-longer-awaited).\n\n```typescript\n// +page.ts\n// tRPC is setup using `trpc-sveltekit` for this example.\nimport { trpc } from '$lib/trpc/client';\nimport type { PageLoad } from './$types';\n\nexport const load = (async (event) => {\n  const { queryClient } = await event.parent();\n  const client = trpc(event, queryClient);\n\n  return {\n    foo: await client.greeting.createServerQuery('foo'),\n    queries: await client.createServerQueries(\n      (t) =>\n        ['bar', 'baz'].map((name) => t.greeting(name, { ssr: name !== 'baz' })) // pre-fetching disabled for the `baz` query.\n    ),\n  };\n}) satisfies PageLoad;\n```\n\nThen, in the component:\n\n```svelte\n<!-- +page.svelte -->\n<script lang=\"ts\">\n  import { page } from \"$app/stores\";\n  import type { PageData } from \"./$types\";\n\n  export let data: PageData;\n\n  const foo = data.foo();\n  const queries = data.queries();\n</script>\n\n{#if $foo.isPending}\n  Loading...\n{:else if $foo.isError}\n  {$foo.error}\n{:else if $foo.data}\n  {$foo.data}\n{/if}\n<br /><br />\n\n{#each $queries as query}\n  {#if query.isPending}\n    Loading...\n  {:else if query.isError}\n    {query.error.message}\n  {:else if query.data}\n    {query.data}\n  {/if}\n  <br />\n{/each}\n```\n\nYou can also optionally pass new inputs to the queries and infinite queries from the client side(see [#34](/../../issues/34), [#47]( /../../issues/47 )) like so:\n\n```svelte\n<script lang=\"ts\">\n  import { page } from \"$app/stores\";\n  import type { PageData } from \"./$types\";\n\n  import { derived, writable } from '@svelte/store';\n\n  export let data: PageData;\n\n  const name = writable('foo');\n  const newNames = writable<string[]>([]);\n\n  const foo = data.foo($name);\n\n  // You can also access the default input if you pass in a callback as the new input:\n  // const foo = data.foo((old) => derived(name, ($name) => old + name));\n\n  const queries = data.queries((t, old) => derived(newNames, ($newNames) => [...old, ...$newNames.map((name) => t.greeting(name))]));\n</script>\n\n<div>\n  {#if $foo.isPending}\n    Loading...\n  {:else if $foo.isError}\n    {$foo.error}\n    {:else if $foo.data}\n    {$foo.data}\n  {/if}\n  <input bind:value={$name} />\n</div>\n\n<br />\n\n<div>\n  {#each $queries as query}\n    {#if query.isPending}\n      Loading...\n    {:else if query.isError}\n      {query.error.message}\n      {:else if query.data}\n      {query.data}\n    {/if}\n    <br />\n  {/each}\n\n  <form on:submit|preventDefault={(e) => {\n    const data = new FormData(e.currentTarget).get('name');\n    if (typeof data === 'string') $newNames.push(data);\n    $newNames = $newNames;\n  }}>\n    <input name=\"name\" />\n    <button type=\"submit\">Submit</button>\n  </form>\n</div>\n```\n\nFor more usage examples, you can refer to the [example app provided in the repo](/@example).\n\n[npm-url]: https://npmjs.org/package/trpc-svelte-query-adapter\n[npm-image]: https://img.shields.io/npm/v/trpc-svelte-query-adapter.svg\n[license-url]: LICENSE\n[license-image]: http://img.shields.io/npm/l/trpc-svelte-query-adapter.svg\n[repo-url]: https://github.com/vishalbalaji/trpc-svelte-query-adapter\n[last-commit-image]: https://img.shields.io/github/last-commit/vishalbalaji/trpc-svelte-query-adapter\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 133],
		[3603, 868],
		[3610, 96],
		[3617, 130],
		[3624, 112],
		[3631, 181],
		[3638, 108],
		[3645, 28],
		[3652, 109],
		[3659, 241],
		[3666, 172],
		[3673, 126],
		[3680, 107],
		[3687, 115],
		[3694, 257],
		[3701, 1496],
		[3708, 1414],
		[3715, 1464],
		[3722, 1533],
		[3729, 1616],
		[3736, 1035],
		[3743, 1123],
		[3750, 1287],
		[3757, 1324],
		[3764, 1662],
		[3771, 942],
		[3778, 576],
		[3785, 918],
		[3792, 632],
		[3799, 688],
		[3806, 859],
		[3813, 962],
		[3820, 1319],
		[3827, 2230],
		[3834, 1992],
		[3841, 1560],
		[3848, 1332],
		[3855, 932],
		[3862, 1556],
		[3869, 2755],
		[3876, 4201],
		[3883, 2640],
		[3890, 3958],
		[3897, 3700],
		[3904, 3187],
		[3911, 2930],
		[3918, 3424],
		[3925, 3281],
		[3932, 3231],
		[3939, 3480],
		[3946, 1822],
		[3953, 2555],
		[3960, 1987],
		[3967, 1106],
		[3974, 1871],
		[3981, 2783],
		[3988, 3145],
		[3995, 2518],
		[4002, 2726],
		[4009, 493],
		[4016, 736],
		[4023, 1045],
		[4030, 1062],
		[4037, 1022],
		[4044, 1011],
		[4051, 1558],
		[4058, 1154],
		[4065, 919],
		[4072, 1507],
		[4079, 600],
		[4086, 454],
		[4093, 380],
		[4100, 470],
		[4107, 342],
		[4114, 230],
		[4121, 204],
		[4128, 272],
		[4135, 407]
	]
}
