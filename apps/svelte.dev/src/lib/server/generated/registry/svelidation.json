{
	"name": "svelidation",
	"description": "Validate Svelte forms with customizable rules and types.",
	"repo_url": "https://github.com/yazonnile/svelidation",
	"authors": ["yazonnile"],
	"homepage": "https://github.com/yazonnile/svelidation#readme",
	"downloads": 15,
	"updated": "2020-01-10T14:40:34.958Z",
	"tags": ["miscellaneous"],
	"github_stars": 52,
	"typescript": true,
	"version": "1.3.2",
	"svelte_range": "^3.13.0",
	"last_rune_check_version": "1.3.2",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelidation",
				"version": "1.3.2",
				"size": 745464
			},
			{
				"name": "svelte",
				"version": "3.59.2",
				"size": 10624206
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "![Svelidation](https://yazonnile.github.io/svelidation/logo.svg)\r\n\r\nEasily customizable library for `validation` scenarios in `svelte` components.\r\nNeed to validate just a few simple inputs? Or need to build a huge form with dynamic steps? No problems. Svelidation was born for it!\r\n\r\n![NPM](https://img.shields.io/npm/l/svelidation) ![npm](https://img.shields.io/npm/v/svelidation)\r\n\r\n### Something doesn\\'t work as expected? Any functionality is missing? Or, maybe, you have an idea/suggestion to make Svelidation better? Feel free to [create an issue](https://github.com/yazonnile/svelidation/issues/new) and describe your thoughts. Anything possible. Welcome!\r\n\r\n# Quick example\r\n```js\r\nimport createSvelidation from 'svelidation';\r\n\r\n// 1. create an instance\r\nconst { createForm, createEntry } = createSvelidation();\r\n\r\n// 2. create a validation model\r\nconst [ errorsStore, valueStore, useInput ] = createEntry({\r\n  type: 'string',\r\n  required: true\r\n});\r\n```\r\n```html\r\n<!-- 3. use it in template  -->\r\n<form use:createForm on:submit|preventDefault>\r\n  <input type=\"text\" use:useInput bind:value={$valueStore} />\r\n\r\n  {#if $errorsStore.includes('required')}\r\n    This field is required\r\n  {/if}\r\n\r\n  <button type=\"submit\">Submit</button>\r\n</form>\r\n```\r\nCheck more examples on the [demo page](http://yazonnile.github.io/svelidation/)\r\n\r\n# install\r\n`npm i -S svelidation`\r\n\r\n# FAQ\r\n<details>\r\n  <summary>What a dollar sign ($) means?</summary>\r\n\r\n  This is a specific Svelte reactive statements. [Check here details](https://svelte.dev/docs#3_$_marks_a_statement_as_reactive)\r\n</details>\r\n<details>\r\n  <summary>How can I use my own email regExp for validation?</summary>\r\n\r\n  Easy. Just update email type rule with [ensureType API](#ensuretypetypename-string-typerules)\r\n\r\n  ```javascript\r\nimport createValidation, { ensureType } from 'svelidation';\r\nconst { createEntry } = createValidation();\r\n\r\n// extend existing type with custom rule\r\nensureType('email', {\r\n    type: (value) => {\r\n      return value.match(YOUR_EMAIL_REG_EXP);\r\n    }\r\n});\r\n```\r\n</details>\r\n<details>\r\n  <summary>How can I create simple email+password form without all that complicated stuff?</summary>\r\n\r\n  ```html\r\n<script>\r\n    const { createForm, createEntry } = createSvelidation();\r\n\r\n    // create two validation entries\r\n    const [ emailErrors, emailValue, emailInput ] = createEntry({\r\n      type: 'email',\r\n      required: true\r\n    });\r\n    const [ passwordErrors, passwordValue, passwordInput ] = createEntry({\r\n      type: 'text',\r\n      required: true\r\n    });\r\n\r\n    // create success handler\r\n    const onSuccess = (values) => {\r\n      // send values with api\r\n    };\r\n</script>\r\n<form use:createForm={{ onSuccess }} on:submit|preventDefault>\r\n    <input type=\"email\" use:emailInput bind:value={$emailValue} />\r\n    {#if $emailErrors.length}Field is invalid{/if}\r\n    <input type=\"password\" use:passwordInput bind:value={$passwordValue} />\r\n    {#if $passwordErrors.length}Field is invalid{/if}\r\n    <button type=\"submit\">submit</button>\r\n</form>\r\n  ```\r\n</details>\r\n<details>\r\n  <summary>How to activate validation just on form submit without any side-inputs-events?</summary>\r\n\r\n  The only thing you need to do - disable input events, because submit validation works by default\r\n  ```html\r\n<script>\r\n    const { createForm } = createSvelidation({ listenInputEvents: 0 });\r\n    // ...\r\n</script>\r\n<form use:createForm>\r\n    <!-- html -->\r\n</form>\r\n```\r\n</details>\r\n<details>\r\n  <summary>How to validate multi-steps form with different inputs on each step?</summary>\r\n\r\n  Nothing special to do here. Just create all inputs entries and bind it to inputs with `use` directive, and svelidation will validates only visible (created in DOM) inputs. Check [DYNAMIC STEPS example](https://yazonnile.github.io/svelidation/)\r\n</details>\r\n<details>\r\n  <summary>What if I don't have DOM? Can I validate pure data?</summary>\r\n\r\n  Yes. You have few options\r\n  1. Use `includeAllEntries` option\r\n  ```javascript\r\nconst { validate, validateValueStore, createEntry } = createSvelidation({ includeAllEntries: true });\r\nconst [ errors1, value1 ] = createEntry(...);\r\nconst [ errors2, value2 ] = createEntry(...);\r\n\r\n// validate all created entries\r\nconst allErrors = validate();\r\n\r\n// or validate specific entry value\r\nconst firstEntryErrors = validateValueStore(value1);\r\n```\r\n\r\n  2. Use `true` as parameter in `validate` api\r\n  ```javascript\r\nconst { validate } = createSvelidation();\r\n\r\n// ...create some entries\r\n\r\n// validate all created entries\r\nconst allErrors = validate(true);\r\n```\r\n</details>\r\n<details>\r\n  <summary>How can I clear errors manually?</summary>\r\n\r\n  Use [clearErrors API](#clearerrorsincludenoformelements-boolean)\r\n</details>\r\n<details>\r\n  <summary>How do I know when validation fails?</summary>\r\n\r\n  There is `onFail` options [here](#createform)\r\n  ```html\r\n<script>\r\n    const { createForm } = createSvelidation();\r\n\r\n    // ...\r\n\r\n    // create fail handler\r\n    const onFail = (errors) => {\r\n        //\r\n    };\r\n</script>\r\n<form use:createForm|preventDefault={{ onFail }}>\r\n\r\n</form>\r\n```\r\n</details>\r\n<details>\r\n  <summary>How to customize entry errors store?</summary>\r\n\r\n  Use [useCustomErrorsStore option](#options)\r\n\r\n  Check [CUSTOM ERRORS example](https://yazonnile.github.io/svelidation/)\r\n</details>\r\n<details>\r\n  <summary>How can I get all entries values not just after success validation?</summary>\r\n\r\n  Use [getValues API](#getvaluesentries-values)\r\n</details>\r\n<details>\r\n  <summary>How to hide warnings in the console?</summary>\r\n\r\n  Use [warningsEnabled option](#options)\r\n</details>\r\n<details>\r\n  <summary>How can I create my own validation rule or custom type?</summary>\r\n\r\n  Use [ensureRule](#ensurerulerulename-string-rulefunction) / [ensureType](#ensuretypetypename-string-typerules) API\r\n</details>\r\n<details>\r\n  <summary>Do I have an option to avoid set required: true to every field?</summary>\r\n\r\n  Yes. Use [presence: 'required' option](#options)\r\n</details>\r\n<details>\r\n  <summary>Is possible to avoid false positive validation of spaces-only-strings, but still to make users possible to use spaces at the start or end of their passwords (or another specific field)?</summary>\r\n\r\n  Yes. That is why [trim option](#options) was created.\r\n\r\n  If you set `trim: true`, validator will trim all values before check. **It will not change value itself**, but trim it for check purpose.\r\n\r\n  Then, you can set `trim: false` for specific field, to avoid trim.\r\n\r\n  ```javascript\r\n  const { createEntry } = createSvelidation({ trim: true }); // trim all values before validation\r\n  const passwordEntry = createEntry({\r\n    // ...options\r\n    trim: false // don`t trim password entry before validation\r\n  });\r\n  ```\r\n\r\n  And, of course, you are able to do an opposite. Leave `trim` options default (`false), and set `trim: true`for specific field\r\n</details>\r\n<details>\r\n  <summary>This lib can't do the things what I need</summary>\r\n\r\n  Not a problem! [Create an issue](https://github.com/yazonnile/svelidation/issues/new) and describe your needs. Will check this out\r\n</details>\r\n\r\n# basic types\r\nCombination of type/rules is using in [here](#entryparams)\r\n## `string`\r\ncheck string length\r\n  - `{ type: 'string', min: 3 }`\r\n  - `{ type: 'string', max: 3 }`\r\n  - `{ type: 'string', between: [4, 10] }`\r\n## `email`\r\n  - `{ type: 'email' }`\r\n## `number`\r\ncheck number value\r\n  - `{ type: 'number', min: 3 }`\r\n  - `{ type: 'number', max: 3 }`\r\n  - `{ type: 'number', between: [4, 10] }`\r\n## `boolean`\r\n  - `{ type: 'boolean' }`\r\n## `array`\r\ncheck array length and specific element\r\n  - `{ type: 'array', min: 3 }`\r\n  - `{ type: 'array', max: 3 }`\r\n  - `{ type: 'array', includes: 3 }`\r\n\r\n# global rules\r\n## `equal`\r\nequality with value (in case of array it sorta and stringifies it), could take a function as equal value\r\n  - `{ type: 'string', equal: 'my-custrom-string' }`\r\n  - `{ type: 'string', equal: value => (value === myFunction()) }`\r\n## `match`\r\nmatch textual value form by regExp\r\n  - `{ type: 'number', match: '202\\d' }`\r\n## `required`\r\ncheck value exists\r\n  - `{ type: 'email', required: true }`\r\n\r\n# options\r\n```js\r\n// default values\r\ncreateSvelidation({\r\n  validateOnEvents: { change: true, input: false, blur: false },\r\n  clearErrorsOnEvents: { reset: true, focus: false },\r\n  listenInputEvents: 2,\r\n  presence: 'optional',\r\n  trim: false,\r\n  includeAllEntries: false,\r\n  useCustomErrorsStore: false\r\n  warningsEnabled: true\r\n  getValues: false\r\n});\r\n```\r\n- `validateOnEvents: { [key: string]: boolean }`\r\n  - object of input events to validate input value\r\n  - possible events: `change`, `input`, `blur`\r\n\r\n- `clearErrorsOnEvents: { [key: string]: boolean }`\r\n  - object of events to clear errors\r\n  - possible events: `reset`, `focus`\r\n\r\n- `listenInputEvents: number`\r\n  - specific option for control input events\r\n    - `0`: dont allow input events\r\n    - `1`: allow input events always\r\n    - `2`: allow input events after first validation run\r\n\r\n- `presence: string`\r\n  - Default inputs presence. If we set it to `required` - all inputs will be validated as required by default\r\n  - This options equals `optional` by default, this means that all fields in validation are optional and will be validated in case of having value, or having another validation rules\r\n\r\n- `trim: boolean`\r\n  - allow validator trim textual values before check\r\n  - *(!!!) it doesn't trim value itself, just for check purpose*\r\n\r\n- `includeAllEntries: boolean`\r\n  - By default validation works for entries that were assigned with inputs by `use` svelte directive. This option makes possible to validate ALL entries in validation\r\n\r\n- `useCustomErrorsStore(errorsArray, entryParams): errorsStore`\r\n  - optional method to make possible to use custom errorsStore structure. By default this is array of strings. This method can override default store with any you want\r\n  - `errorsArray` - default array of errors strings\r\n  - `entryParam` - ([check here](#entryparams))\r\n  - check `CUSTOM ERRORS` example on [demo page](http://yazonnile.github.io/svelidation/)\r\n\r\n- `warningsEnabled: boolean`\r\n  - option that makes warnings in dev mode visible. `true` by default\r\n\r\n- `getValues(): values`\r\n  - optional method to build own values result\r\n  - default `getValues` implementation returns `Map` structure `Map{ [entryParams.id || entryParams]: value }`\r\n  - example#1 `{ type: 'string' }` `getValues` result will looks like this: `Map{ { type: 'string' }: '' }`\r\n  - example#2 `{ type: 'string', id: 'login' }` `getValues` result will looks like this: `Map{ login: '' }`\r\n  - `entries` - array of entries params and values\r\n  - result of `getValues` will passed to onSuccess option for form in `createForm` API ([check here](#createform))\r\n  - check two `get values` examples on the [demo page](http://yazonnile.github.io/svelidation/)\r\n\r\n`validateOnEvents`, `clearErrorsOnEvents`, `presence` and `trim` behavior could be overrided by any input for itself in `createEntry` API ([check here](#createentryentryparams))\r\n\r\n# validation level API\r\n```js\r\nimport createSvelidation from 'svelidation';\r\nconst {\r\n  createEntry,\r\n  createEntries,\r\n  createForm,\r\n  validateValueStore,\r\n  validate,\r\n  clearErrors,\r\n  getValues\r\n} = createSvelidation();\r\n```\r\n\r\n### `createEntry(entryParams)`\r\nCreate validation entry\r\n```js\r\nconst [ errorsStore, valueStore, inputFunctionForUse ] = createEntry(entryParams);\r\n```\r\n\r\n`errorsStore`, `valueStore` used for bind errors and value stores in templates. One more time. THIS IS SVELTE STORES. You might see something like `errors[]` below in this readme - this is just a array with strings\r\n\r\n`inputFunctionForUse` function for `use` svelte directive on input, to assign its events to validation process\r\n\r\n```html\r\n<input use:inputFunctionForUse />\r\n<!-- or -->\r\n<input use:inputFunctionForUse={{ clearErrorsOnEvents, validateOnEvents }} />\r\n```\r\nThis is the place where `clearErrorsOnEvents` and `validateOnEvents` options could be overrided for specific input\r\n\r\n#### entryParams\r\nCheck list of types/rules [here](#basic-types)\r\n\r\n```js\r\n// entryParams\r\n{\r\n  type, // required\r\n  value, // initial value, required for some types of fields\r\n  id, // optional param for getValues method\r\n\r\n  // other rules, like min/max/required...\r\n\r\n  trim, // works like trim option for createSvelidation function, but on input level\r\n  required,\r\n  optional // makes possible to override presence option of createSvelidation function\r\n}\r\n```\r\n\r\n\r\n### `createEntries(entryParams[] | {[key: string]: entryParams})`\r\nAdditional way to create a few entries at the time\r\n```js\r\nconst {\r\n  first: [firstErrorsStore, firstValueStore, firstInput],\r\n  second: [secondErrorsStore, secondValueStore, secondInput]\r\n} = createEntries({\r\n  first: {\r\n    // entryParams\r\n  },\r\n  second: {\r\n    // entryParams\r\n  },\r\n})\r\n```\r\n```js\r\nconst [\r\n  [firstErrorsStore, firstValueStore, firstInput],\r\n  [secondErrorsStore, secondValueStore, secondInput]\r\n] = createEntries([\r\n  {\r\n    // entryParams\r\n  }, {\r\n    // entryParams\r\n  },\r\n])\r\n```\r\n\r\n### `createForm`\r\n\r\nFunction for form `use`\r\n\r\nThis function makes subscribe on submit/reset form events for validation/clearErrors by default\r\n```html\r\n<form use:createForm></form>\r\n<!-- or -->\r\n<form use:createForm={{ onSubmit, onFail, onSuccess }}></form>\r\n```\r\nAn object with callbacks could be used as param in `use` function\r\n\r\n`onSubmit(submitEvent, errors[])` - every form submit attempt. `errors[]` - array of all errors store values. Not array of stores, but array of store errors.\r\n\r\n`onFail(errors[])` - on every failed validation (when `errors.length > 0`)\r\n\r\n`onSuccess(values)` - when there aren't any errors. Get `values` ([check here](#options)) as result\r\n\r\n### `clearErrors(includeNoFormElements: boolean)`\r\nManually clear all errors stores\r\n```js\r\nclearErrors(includeNoFormElements = false);\r\n```\r\nOnly argument same as in `validate`\r\n\r\n### `validate(includeNoFormElements: boolean): allValidationErrors[]`\r\nManually validate stores\r\n```js\r\nconst allErrors = validate(includeNoFormElements = false);\r\n```\r\nOnly argument makes possible to validate all created entries.\r\n\r\nWithout this param validation will check inputs assigned to nodes only (`inputFunctionForUse` - check `createEntry` API)\r\n\r\nReturn array of all errors store values\r\n\r\n### `validateValueStore(valueStore): errors[]`\r\nManually validate value store\r\n```js\r\nconst [ emailErrorsStore, emailValueStore ] = createEntry({ type: 'email' });\r\nconst errors = validateValueStore(emailValueStore); // array of string, not errorsStores!!!\r\n```\r\nReturns errors store value\r\n\r\n### `getValues(entries): values`\r\n[check here](#options)\r\n\r\n# advanced API\r\n```js\r\nimport {\r\n  ensureRule,\r\n  resetRule,\r\n  ensureType,\r\n  resetType,\r\n  addSpy,\r\n  removeSpies\r\n} from 'svelidation';\r\n```\r\n### `ensureRule(ruleName: string, ruleFunction)`\r\n  - `ruleFunction: (value, entryParams): boolean`\r\nAllows to add your own global (will be available for any type) rules\r\n```js\r\nimport createValidation, { ensureRule } from 'svelidation';\r\nconst { createEntry, validate } = createValidation();\r\n\r\nconst myRuleFunction = (value, entryParams) => {\r\n  // entryParams === { type: 'string'... }\r\n  // entryParams.myRule === 'my rule value...'\r\n  return entryParams.type === 'string';\r\n}\r\n\r\nensureRule('myRule', myRuleFunction);\r\n\r\nconst [ stringErrors, stringValue ] = createEntry({\r\n  type: 'string',\r\n  myRule: 'my rule value for string'\r\n});\r\n\r\nconst [ numberErrors, numberValue ] = createEntry({\r\n  type: 'number',\r\n  myRule: 'my rule value for email'\r\n});\r\n\r\nconsole.log(validate(true)); // [{ number: ['myRule'] }]\r\n```\r\n### `resetRule(ruleName?: string)`\r\nRemove custom rule. If calls without `ruleName` - it will remove all custom global rules\r\n```js\r\nimport createValidation, { ensureRule, resetRule } from 'svelidation';\r\nconst { createEntry, validate } = createValidation();\r\n\r\nensureRule('myRule', (value, { myRule, type }) => {\r\n  // myRule === 'my rule value...'\r\n  return type === 'string';\r\n});\r\n\r\nconst [ numberErrors, numberValue ] = createEntry({\r\n  type: 'number',\r\n  myRule: 'my rule value for email'\r\n});\r\n\r\nconsole.log(validate(true)); // [{ number: ['myRule'] }]\r\nresetRule('myRule');\r\nconsole.log(validate(true)); // [] - there in no rule like myRule, so no validation, no errors\r\n```\r\n### `ensureType(typeName: string, typeRules)`\r\n  - `typeRules: { [key: string]: ruleFunction }`\r\n    - `ruleFunction: (value, entryParams): boolean`\r\n\r\nExtend existing/add new type to validator. In case of creating new type, there is one clause. `typeRules` has to have method named `type`. This is a basic and required method for every type and it calls everytime we validate type. And if it return `false` - current entry validation stops with `type` error\r\n```js\r\nimport createValidation, { ensureType } from 'svelidation';\r\nconst { createEntry, validate, validateValueStore } = createValidation();\r\n\r\n// extend existing type with custom rule\r\nensureType('string', {\r\n  between5and10: (value) => {\r\n    console.log('extended!');\r\n    return value.length >= 5 && value.length <= 10;\r\n  }\r\n});\r\n\r\nconst [ stringErrors, stringValue ] = createEntry({\r\n  type: 'string',\r\n  between5and10: true,\r\n  value: 'asdf'\r\n});\r\n\r\nconsole.log(validateValueStore(stringValue)); // ['between5and10']\r\n\r\n// create new type with its own rules\r\nensureType('myNewType', {\r\n  type: (value) => {\r\n    return value === 'custom!!!';\r\n  },\r\n  anotherRule: (value, { anotherRule }) => {\r\n    return false;\r\n  },\r\n  min: 'string.min' // yes, we can take some existing rules from another types\r\n});\r\n\r\nconst [ myErrors, myValue ] = createEntry({\r\n  type: 'myNewType',\r\n  anotherRule: 'something',\r\n  min: 10,\r\n  value: 'custom!!!'\r\n});\r\n\r\nconsole.log(validateValueStore(myValue)); // ['anotherRule', 'min']\r\n```\r\n### `resetType(typeName?: string)`\r\nWork same as `resetRule`, but on the type level\r\n\r\n-----------\r\n\r\n~~omg :) I hope noone will need to use methods below~~\r\n### Ok, so what are you saying? Spies? O_o\r\n\r\nYes. Spies. Spy.\r\n\r\nBy design, this is a function to observe validation process and get into it.\r\n\r\nSpy can observe types, global rules, specific rule of specific type. Spy can observe everything! Literally. Just create a global spy and it will observe every validation. Every rule, every type, everything will be in its hands.\r\n\r\nIf you need to prevent something, or update value somehow - special spy is the place.\r\n\r\nYou need to know just one thing. Spy has god power, but it has to give this power to the next spy. And there will always be **next** spy, even if its not your spy.\r\n\r\nSo, lets dive into examples\r\n\r\n### `addSpy(spyFunction, spyParams?): removeSpyFunction`\r\nMethod to add spy in the validation process\r\n\r\n  - `spyFunction(value, entryParams, next, abort): errors[]`\r\n    - `next(nextValue, mixedParams?: entryParamsLike)`\r\n    - `abort()`\r\n  - `spyParams?: { ruleName?: string, type?: string }`\r\n\r\n```js\r\nimport createValidation, { addSpy } from 'svelidation';\r\nconst { createEntry, validateValueStore } = createValidation();\r\n\r\nconst [ stringErrors, stringValue ] = createEntry({\r\n  type: 'string',\r\n  value: '...',\r\n  min: 5,\r\n  max: 10,\r\n});\r\n\r\nconst removeSpy = addSpy((value, params, next, abort) => {\r\n  console.log('spying!');\r\n  next(value);\r\n}, { type: 'string', ruleName: 'min' });\r\n\r\nvalidateValueStore(stringValue);\r\n// LOG: >> 'spying!'\r\n```\r\n\r\nFirst of all, take a look at the line with `next(value)` call. This is **VERY IMPORTANT LINE** in spies paradigm. Remember? Spy has god power, but it has to give this power to next spy. This.\r\n\r\n`next(value, params)` - is the function witch spy have to call with any value spy wants. This new value will be taken by next validation rules or another spies (until type validation ends). Almost same with the params. But params will be merged with original for next validators. So the value will replace the original one, params will be merged\r\n\r\nAnd it can returns errors, that will be merged with validation errors\r\n\r\n```js\r\nimport createValidation, { addSpy, ensureType } from 'svelidation';\r\nconst { createEntry, validateValueStore } = createValidation();\r\n\r\nconst [ stringErrors, stringValue ] = createEntry({\r\n  type: 'string',\r\n  value: '...',\r\n  myRule: 'hello'\r\n});\r\n\r\nconst removeSpy = addSpy((value, params, next, abort) => {\r\n  console.log('spying!');\r\n  next(value, { somethingFromSpy: 'world' });\r\n  return ['error-from-spy'];\r\n}, { type: 'string', ruleName: 'myRule' });\r\n\r\nensureType('string', {\r\n  myRule: (value, { myRule, somethingFromSpy }) => {\r\n    console.log(myRule, somethingFromSpy); // 'hello', 'world'\r\n    return false;\r\n  }\r\n});\r\n\r\nconsole.log(validateValueStore(stringValue));\r\n// [\"error-from-spy\", \"myRule\"]\r\n// first is from spy, second from our rule, that always return false\r\n```\r\n\r\nWhat happens if we will not call `next`? Validation process will stop and return existing errors for the moment.\r\n\r\n`abort()` method - its an emergency brake. If it calls - validation stop and return nothing.\r\n\r\nAnd last, but not least `spyParams?: { ruleName?: string, type?: string }`. This is an optional object to describe spy's field of responsibilty.\r\n  - `{ ruleName: 'min', type: 'string' }` - spy for specific rule in specific type. Will be called each time, when current pair rule-type check\r\n  - `{ ruleName: 'match' }` - spy for specific rule. Will be called with each `ruleName` check\r\n  - `{ type: 'array' }` - spy for EVERY validation of specific type. Will be called once per `type`.\r\n  - `undefined` - spy for everything. Will be called once before every validation.\r\n\r\nSo, for example if you create spies:\r\n```js\r\naddSpy(() => {}); // 1\r\naddSpy(() => {}, { type: 'string' }); // 2\r\naddSpy(() => {}, { type: 'string', ruleName: 'min' }); // 3\r\naddSpy(() => {}, { ruleName: 'min' }); // 4\r\n\r\n// run validation for a { type: 'string', min: 5 }\r\n// each spy will be called once\r\n\r\n// run validation for a { type: 'string', min: 5 }, { type: 'string', max: 5 }\r\n// 3 and 4 will be called once.\r\n// 1 and 2 - twice, because we validate 2 entries (1st spy), and 2 strings (2nd spy)\r\n\r\n// run validation for a { type: 'string', min: 5 }, { type: 'email', required: true }\r\n// 1 - twice, because we validate 2 entries\r\n// 2, 3 and 4 will be called once\r\n```\r\n\r\nLast thing about the spies.\r\n\r\nIf you create a spy that will observe `type` method of any type - remember, that returning an error from that spy will stop current entry validation because `type` method fails, so there is no point to continue validation\r\n\r\nTo remove your spy - just call `removeSpyFunction` that returns `addSpy` method.\r\n\r\nAnd to remove all spies...\r\n\r\n### `removeSpies(params?: { type?: string, ruleName?: string })`\r\nThis is an easy one after `addSpy` :). It just removes all spies depends on params.\r\n  - `{type: 'string', ruleName: 'min'}` - remove all spies for specific rule in specific type\r\n  - `{runeName: 'match'}` - remove all spies for specific global rule\r\n  - `{type: 'string'}` - remove all spies for specific type\r\n  - `undefined` - remove all spies at all\r\n\r\n# scripts\r\n- `npm run build` - build demo and library files into `dist`\r\n- `npm run dev` - run dev server from dist folder with demo page by default\r\n- `npm run test` - run all tests on production version of build\r\n- `npm run e2e` - e2e testing of lib file from `dist`\r\n- `npm run e2e:dev` - dev server from `e2e/dist` folder with tests name in params\r\n- `npm run unit` - unit testing of `spec.js` files in `lib`\r\n- `npm run unit:dev` - dev server for unit testing\r\n- `npm run eslint` - lint source code\r\n\r\n# TODO\r\n- [x] demo examples\r\n- [x] complete readme\r\n- [x] unit tests\r\n- [x] e2e tests\r\n- [x] builder demo\r\n- [x] eslint\r\n- [ ] add comments in the code\r\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 2],
		[3596, 58],
		[3603, 30],
		[3610, 37],
		[3617, 12],
		[3624, 4],
		[3631, 6],
		[3638, 25],
		[3645, 14],
		[3652, 12],
		[3659, 14],
		[3666, 36],
		[3673, 17],
		[3680, 16],
		[3687, 13],
		[3694, 6],
		[3701, 8],
		[3708, 12],
		[3715, 2],
		[3722, 1],
		[3729, 26],
		[3736, 8],
		[3743, 12],
		[3750, 2],
		[3757, 3],
		[3764, 9],
		[3771, 17],
		[3778, 3],
		[3785, 11],
		[3792, 18],
		[3799, 4],
		[3806, 6],
		[3813, 3],
		[3820, 1],
		[3827, 2],
		[3834, 6],
		[3841, 6],
		[3848, 8],
		[3855, 8],
		[3862, 140],
		[3869, 5],
		[3876, 2],
		[3883, 10],
		[3890, 25],
		[3897, 3],
		[3904, 1],
		[3911, 27],
		[3918, 3],
		[3925, 5],
		[3932, 3],
		[3939, 4],
		[3946, 6],
		[3953, 9],
		[3960, 6],
		[3967, 5],
		[3974, 9],
		[3981, 2],
		[3988, 11],
		[3995, 3],
		[4002, 4],
		[4009, 4],
		[4016, 9],
		[4023, 8],
		[4030, 27],
		[4037, 18],
		[4044, 26],
		[4051, 6],
		[4058, 2],
		[4065, 8],
		[4072, 4],
		[4079, 3],
		[4086, 2],
		[4093, 26],
		[4100, 29],
		[4107, 17],
		[4114, 15],
		[4121, 24],
		[4128, 31]
	],
	"esm": false,
	"cjs": true
}
