{
	"name": "svero",
	"description": "Simple router for Svelte 3 applications.",
	"repo_url": "https://github.com/kazzkiq/svero",
	"authors": ["kazzkiq"],
	"homepage": "https://github.com/kazzkiq/svero",
	"downloads": 45,
	"updated": "2019-07-23T15:09:43.502Z",
	"tags": ["router"],
	"github_stars": 200,
	"typescript": false,
	"version": "1.0.0",
	"svelte_range": "3.x",
	"last_rune_check_version": "1.0.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svero",
				"version": "1.0.0",
				"size": 51280
			},
			{
				"name": "abstract-nested-router",
				"version": "0.1.21",
				"size": 30296
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "[![npm version](https://badge.fury.io/js/svero.svg)](https://www.npmjs.com/package/svero)\n[![Build Status](https://travis-ci.org/kazzkiq/svero.svg?branch=master)](https://travis-ci.org/kazzkiq/svero)\n\n<p align=\"center\">\n  svero (<b>Sve</b>lte <b>Ro</b>uter): A simple router for Svelte 3.\n</p>\n\n## First things first\n\nsvero is intented to be used in SPA (Single Page Applications) making usage of `pushState` and History API. We're assuming that you already know how to configure your front-end server (being it dev or production) to serve all path requests to `index.html`.\n\nIf you're not familiar with the terms SPA, `pushState` or History API, you should probably be reading these first:\n\n<small>http://krasimirtsonev.com/blog/article/deep-dive-into-client-side-routing-navigo-pushstate-hash</small><br>\n<small>https://css-tricks.com/using-the-html5-history-api/</small><br>\n<small>https://diveinto.html5doctor.com/history.html</small><br>\n<small>https://developer.mozilla.org/pt-BR/docs/Web/API/History</small><br>\n\n## Installation\n\nSince it's exported in CommonJS format, you should be using it with a module bundler such as [Rollup](https://github.com/sveltejs/template/tree/v3) or Webpack.\n\nYou can install svero via npm:\n\n```\nnpm install --save svero\n```\n\n## Usage\n\nThe usage is super simple:\n\n```html\n<!-- ./App.svelte -->\n<script>\n  import { Router, Route } from 'svero';\n\n  import Index from './pages/Index.svelte';\n  import About from './pages/About.svelte';\n  import Employees from './pages/Employees.svelte';\n\n  let employees = [{ id: 1, name: 'Bill'}, { id:2, name: 'Sven' }];\n</script>\n\n<Router>\n  <Route path=\"*\" component={Index} />\n  <Route path=\"/about\" component={About} />\n  <Route path=\"/about/:who/123/:where\" component={About} />\n  <Route path=\"/employees\">\n    <Employees {employees}/>\n  </Route>\n</Router>\n```\n\nThe `*` wildcard simply works as a fallback. If a route fails to meet any other path, it then loads the path with the `*`. If there is no wildcard route and the route did not meet any other path, nothing is loaded.\n\nYour custom props can be passed by putting your component in the Route `slot` (Employees example above).\n\nPaths with parameters (`:param`) are passed to components via props: `router.params`.\n\n> Parameters like `*param` will capture the rest of segments. You can access them as `router.params._` like other params.\n\nA component loaded by `<Route>` receives a property with route details:\n\n```html\n<!-- ./pages/About.svelte -->\n<script>\n  export let router = {};\n\n  // Those contains useful information about current route status\n  router.path; // /test\n  router.route; // Route Object\n  router.params; // /about/bill/123/kansas { who: 'bill', where: 'kansas' }\n</script>\n```\n\nAdditional properties are passed to the mounted component, e.g.\n\n```html\n<Route component={Test} title=\"Some description\" />\n```\n\nAlso, you can pass an object:\n\n```html\n<Route component={Test} props={myProps} />\n```\n\n> `Route` props are omitted, but all remaining ones are passed to `Test`.\n\nRoutes can also render any given markup when they're active, e.g.\n\n```html\n<Route path=\"/static-path\">\n  <h1>It works!</h1>\n</Route>\n```\n\n> You can access `router` within `<slot />` renders by declaring `let:router` on `<Router />` or `<Route />` components (see below).\n\nIf you're building an SPA or simply want to leverage on hash-based routing for certain components try the following:\n\n```html\n<Route path=\"#g/:gistId/*filePath\" let:router>\n  <p>Info: {JSON.stringify(router.params)}</p>\n</Route>\n```\n\nStandard anchors and `<Link />` components will work as usual:\n\n```html\n<a href=\"#g/1acf21/path/to/README.md\">View README.md</a>\n```\n\nDeclaring a component `<Route path=\"#\" />` will serve as fallback when `location.hash` is empty.\n\n### Nesting\n\nYou can render `svero` components inside anything, e.g.\n\n```html\n<Router nofallback path=\"/sub\">\n  <Route>\n    <fieldset>\n      <legend>Routing:</legend>\n      <Router nofallback path=\"/sub/:bar\">\n        <Route let:router>{router.params.bar}!</Route>\n      </Router>\n      <Route path=\"/foo\">Foo</Route>\n      <Route fallback path=\"*\" let:router>\n        <summary>\n          <p>Not found: {router.params._}</p>\n          <details>{router.failure}</details>\n        </summary>\n      </Route>\n      <Router nofallback path=\"/sub/nested\">\n        <Route>\n          [...]\n          <Route fallback path=\"*\">not found?</Route>\n          <Route path=\"/a\">A</Route>\n          <Route path=\"/b/:c\">C</Route>\n          <Route path=\"/:value\" let:router>{JSON.stringify(router.params)}</Route>\n        </Route>\n      </Router>\n    </fieldset>\n  </Route>\n</Router>\n```\n\nProperties determine how routing will match and render routes:\n\n- Use the `nofallback` prop for telling `<Router />` to disable the _fallback_ mechanism by default\n- Any route using the `fallback` prop will catch unmatched routes or potential look-up errors\n- Use the `exact` prop to skip this route from render just in case it does not matches\n- A `<Route />` without `path` will render only if `<Router path=\"...\" />` is active!\n\n> Note that all `<Router />` paths MUST begin from the root as `/sub` and `/sub/nested` in the example.\n\n### Redirects\n\nSometimes you just want a route to send user to another place. You can use the `redirect` attribute for that.\n\nA redirect should always be a string with a path. It uses the same pattern as `path` attribute. For a redirect to run, there must be a Route with the equivalent path.\n\n```html\n<Router>\n  <Route path=\"/company\" redirect=\"/about-us\">\n  <Route path=\"/about-us\" component={AboutUs}>\n</Router>\n```\n\n### Conditions\n\nIf you need to meet a condition in order to run a route, you can use the `condition` attribute. Conditions can also be used with `redirect` for graceful route fallback.\n\nA condition should be either `boolean` or a function returning `boolean`. There is no support for asynchronous conditions at the moment (so keep it simple).\n\n```html\n<Router>\n  <Route path=\"/admin/settings\" condition={isAdminLogged} redirect=\"/admin/login\">\n</Router>\n```\n\nThink of it as a simpler middleware. A condition will run *before* the route loads your component, so there is no wasteful component mounting, and no screen blinking the unwanted view.\n\n### Link Component\n\nThere is also an useful `<Link>` component that overrides `<a>` elements:\n\n```html\n<Link href=\"path/here\" className=\"btn\">Hello!</Link>\n```\n\nThe difference between `<Link>` and `<a>` is that it uses `pushState` whenever possible, with fallback to `<a>` behavior. This means that when you use `<Link>`, svero can update the view based on your URL trigger, without reloading the entire page.\n\n> Given `href` values will be normalized (on-click) if they don't start with a slash, e.g. when `location.pathname === '/foo'` then `#bar` would become `/foo#bar` as result.\n\n### navigateTo()\n\nIn some cases you want to navigate to routes programatically instead of letting user click on links. For this scenario we have `navigateto()` which takes a route as parameter and navigates imediatelly to said route.\n\n`navigateTo()` receives the same treatment as `<Link>`: It will always try to use `pushState` for better performance, fallbacking to a full page redirect if it isn't supported.\n\nUsage:\n\n```html\n<script>\n  import { onMount } from 'svelte';\n  import { navigateTo } from 'svero';\n\n  onMount(() => {\n    if (localStorage.getItem('logged')) {\n      navigateTo('/admin');\n    }\n  });\n</script>\n```\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 112],
		[3603, 70],
		[3610, 83],
		[3617, 39],
		[3624, 56],
		[3631, 69],
		[3638, 85],
		[3645, 70],
		[3652, 38],
		[3659, 45],
		[3666, 105],
		[3673, 69],
		[3680, 66],
		[3687, 50],
		[3694, 29],
		[3701, 57],
		[3708, 41],
		[3715, 44],
		[3722, 75],
		[3729, 76],
		[3736, 27],
		[3743, 52],
		[3750, 48],
		[3757, 43],
		[3764, 51],
		[3771, 69],
		[3778, 51],
		[3785, 58],
		[3792, 21],
		[3799, 23],
		[3806, 27],
		[3813, 21],
		[3820, 18],
		[3827, 5],
		[3834, 23],
		[3841, 35],
		[3848, 8],
		[3855, 14],
		[3862, 134],
		[3869, 10],
		[3876, 29],
		[3883, 9],
		[3890, 35],
		[3897, 32],
		[3904, 14],
		[3911, 6],
		[3918, 14],
		[3925, 8],
		[3932, 13],
		[3939, 4],
		[3946, 16],
		[3953, 4],
		[3960, 3],
		[3967, 7],
		[3974, 4],
		[3981, 6],
		[3988, 42],
		[3995, 16],
		[4002, 15],
		[4009, 16],
		[4016, 10],
		[4023, 6],
		[4030, 32],
		[4037, 31],
		[4044, 9],
		[4051, 26],
		[4058, 11],
		[4065, 14],
		[4072, 31],
		[4079, 18],
		[4086, 19],
		[4093, 12],
		[4100, 27],
		[4107, 20],
		[4114, 45],
		[4121, 80],
		[4128, 17],
		[4135, 19]
	],
	"esm": false,
	"cjs": true
}
