{
	"name": "svelte-pathfinder",
	"description": "Create state-based, advanced router for SvelteJS.",
	"repo_url": "https://github.com/sveltetools/svelte-pathfinder",
	"authors": ["paulmaly"],
	"homepage": "https://github.com/sveltetools/svelte-pathfinder#readme",
	"downloads": 817,
	"updated": "2024-07-04T09:03:48.158Z",
	"tags": ["router"],
	"github_stars": 132,
	"typescript": true,
	"version": "4.8.1",
	"svelte_range": ">=3 <5",
	"last_rune_check_version": "4.8.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-pathfinder",
				"version": "4.8.1",
				"size": 521413
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# Tiny, state-based, advanced router for SvelteJS.\n\n[![NPM version](https://img.shields.io/npm/v/svelte-pathfinder.svg?style=flat)](https://www.npmjs.com/package/svelte-pathfinder) [![NPM downloads](https://img.shields.io/npm/dm/svelte-pathfinder.svg?style=flat)](https://www.npmjs.com/package/svelte-pathfinder)\n\nA completely different approach of routing. State-based router suggests that routing is just another global state and History API changes are just an optional side-effects of this state.\n\n## üí° Features\n\n- Zero-config! \n- Just another global state. Ultimate freedom how to apply this state to your app! \n- Juggling of different parts of URL (path/query/hash) effective and granularly. \n- Automatic parsing of the `query` params, optional parsing `path` params.\n- Helpers to work with navigation, links, and even html forms.\n\n![preview](https://user-images.githubusercontent.com/4378873/220714832-e1aefab3-7cfa-4f4a-9a02-3e280257388c.png)\n\n## üì¶ Install\n\n```bash\nnpm i svelte-pathfinder --save-dev\n```\n\n```bash\nyarn add svelte-pathfinder\n```\n\nCDN: [UNPKG](https://unpkg.com/svelte-pathfinder/) | [jsDelivr](https://cdn.jsdelivr.net/npm/svelte-pathfinder/) (available as `window.Pathfinder`)\n\n```html\n<script src=\"https://unpkg.com/svelte-pathfinder/dist/pathfinder.min.js\"></script>\n\n<!-- OR in modern browsers -->\n\n<script type=\"module\" src=\"https://unpkg.com/svelte-pathfinder/dist/pathfinder.min.mjs\"></script>\n```\n\n## üìå URL schema\n\n`/path`?`query`#`fragment`\n\n## ü§ñ API\n\n### Stores\n\n`path` - represents path segments of the URL as an array.\n\n```javascript\npath: Writable<[]>\n```\n\n`query` - represents query params of the URL as an object.\n\n```javascript\nquery: Writable<{}>\n```\n\n`fragment` - represents fragment (hash) string of URL.\n\n```javascript\nfragment: Writable<string>\n```\n\n`state` - represents state object associated with the new history entry created by pushState().\n\n```javascript\nstate: Writable<{}>\n```\n\n`url` - represents full URL string.\n\n```javascript\nurl: Readable<string>\n```\n\n`pattern` - function to match path patterns and return read-only `params` object or `null`.\n\n```javascript\npattern: Readable<<T extends {}>(pattern?: string | RegExp, options?: ParseParamsOptions) => T | null>\n```\n\n`paramable` - constructor of custom `params` stores to parse path patterns and manipulate path parameters.\n\n```javascript\nparamable: <T extends {}>(pattern?: string, options?: ParseParamsOptions): Writable<T>;\n```\n\n### Helpers\n\n`goto` - perform navigation to the next router state by URL.\n\n```javascript\ngoto(url: string | URL, state?: {});\n```\n\n`back` - perform navigation to the previous router state.\n\n```javascript\nback(url?: string | URL)\n```\n\n`redirect` - update current url without new history record.\n\n```javascript\nredirect(url: string | URL, state?: {})\n```\n\n`click` - handle click event from the link and perform navigation to its targets.\n\n```javascript\nclick(event: MouseEvent)\n```\n\n`submit` - handle submit event from the GET-form and perform navigation using its inputs.\n\n```javascript\nsubmit(event: SubmitEvent)\n```\n\n### Configuration\n\n- `prefs` - preferences object\n    - `sideEffect` - manually disable/enable History API usage (changing URL) (default: auto).\n    - `hashbang` - manually activate hashbang-routing.\n    - `base` - set base path if web app is located within a nested basepath.\n    - `convertTypes` - disable converting types when parsing query/path parameters (default: true).\n    - `nesting` - number of levels when pasring nested objects in query parameters (default: 3).\n    - `array.format` - format for arrays in query parameters (possible values: 'bracket' (default), 'separator').\n    - `array.separator` - if format is `separator` this field give you speficy which separator you want to use (default: ',').\n    - `breakHooks` - whether or not hooks execution should be stopped immediately after first fail or all hooks should be performed in any case (default: true).\n    - `anchor` - whether or not router should respect fragment (hash) value as an anchor if DOM element with appropriate id attribute is found (default: false).\n    - `scroll` - whether or not router should restore scroll position upon the navigation (default: false).\n    - `focus` - whether or not router should restore last focus on DOM element upon the navigation (default: false).\n\nTo change the preferences, just import and change them somewhere on top of your code:\n\n```javascript\nimport { prefs } from 'svelte-pathfinder';\n\nprefs.scroll = true;\nprefs.convertTypes = false;\nprefs.array.format = 'separator';\n```\n\n#### ParseParamsOptions\n\nUsually, you don't need to use second argument in `$pattern()` function and `paramable` store constructor, but in some cases its options can be useful for your goals:\n\n- `loose` - should the pattern match paths that are longer than the pattern itself? (default: false)\n- `blank` - should blank params object (with undeifned values) returned if pattern not match? (default: false)\n- `sensitive` - should be pattern case sensitive? (default: false)\n- `decode` - you can provide you own function to decode URL parameters. (default: decodeURIComponent will be used)\n\n## üïπ Usage\n\n### Changing markup related to the router state\n\n```svelte\n{#if params = $pattern('/products/:id')} <!-- eg. /products/1 -->\n    <ProductView productId={params.id} />\n{:else if params = $pattern('/products')} <!-- eg. /products?page=2&q=Apple -->\n    <ProductsList page={$query.page} search={$query.q} />\n{:else}\n    <NotFound path={$path} />\n{/if}\n\n<Modal open={$fragment === '#login'}>\n    <LoginForm />\n</Modal>\n\n<script>\n    import { path, query, fragment, pattern } from 'svelte-pathfinder';\n    let params;\n</script>\n```\n\n#### Changing logic related to the router state\n\n```svelte\n{#if page}\n    <svelte:component this={page.component} {params} />\n{/if}\n\n<script>\n    ...\n    import { path, pattern } from 'svelte-pathfinder';\n    import routes from './routes.js'; // [{ pattern: '/products', component: ProductsList }, ...]\n    ...\n    let params;\n    $: page = routes.find((route) => params = $pattern(route.pattern)) || null; // match path pattens and get parsed params\n    ...\n    $: if ($path[0] === 'admin' && ! isAuthorized) { // check any specific segment of the path\n        $path = '/forbidden'; // re-write whole path\n    }\n</script>\n```\n\nAlso, you able to use custom RegExp pattern instead of regular path-to-regexp pattern in `$pattern()` function. In this case, if you want to interprent some part of this RegExp pattern as an path parameter you need to use RegExp's [named groups](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Backreferences#using_named_groups). For example, you need to make sure that path includes numeric identifier in second segment of the path:\n\n```svelte\n{#if params = $pattern(/^\\/todos\\/(?<id>\\d+)/)} <!-- will be matched only if second segment is a number -->\n    <TodoDetail id={params.id} />\n{:else if params = $pattern('/todos/:action')} <!-- will be matched if second segment is NOT a number but any other value -->\n    <TodoAction action={params.action} />\n{:else if $pattern('/todos')}\n    <TodoList  />\n{/if}\n\n<script>\n    import { pattern } from 'svelte-pathfinder';\n    let params;\n</script>\n```\n\n> ‚ö†Ô∏è Note: `paramable` stores still not support custom RegExp patterns. If you'll try to pass RegExp to `paramable` constructor it'll cause exception. Maybe similar support will be added in the future.\n\n### Performing updates of router state with optional side-effect to URL\n\n```svelte\n<script>\n    ...\n    $query.page = 10; // set ?page=10 without changing or loose other query params\n    ...\n    $path[1] = 4; // set second segment of the path, e.g. /products/4\n    ...\n    $fragment = 'login'; // set url hash to #login \n    ...\n    $state = { restoreOnBack: 'something' }; // set history record related state object\n</script>\n```\n\n#### Directly bind & assign values to stores\n\n```svelte\n<input bind:value={$query.q} placeholder=\"Search product...\">\n...\n<button on:click={() => $fragment = 'login'}>Login</button>\n...\n<a href=\"/products/{product.id}\" on:click|preventDefault={e => $path[1] = product.id}>\n    {product.title}\n</a>\n```\n\n### Creating stores to manipulating path parameters\n\n```javascript\n// ./stores/params.js\n\nimport { paramable } from 'svelte-pathfinder';\n\nexport const productPageParams = paramable('/products/:category/:productId?');\n...\n```\n\n```svelte\n<select bind:value={$params.category}>\n    <option value=\"all\">All</option>\n    {#each categories as category}\n        <option value={category.slug}>{category.name}</option>\n    {/each}\n</select>\n...\n{#each products as product} \n    <a href=\"/products/{product.id}\" on:click|preventDefault={e => $params.productId = product.id}>\n        {product.title}\n    </a>\n{/each}\n\n<script>\n    import { productPageParams as params } from './store/params';\n</script>\n```\n\n### Use with the other stores\n\n```javascript\nimport { derived } from 'svelte/store';\nimport asyncable from 'svelte-asyncable';\nimport { path, query } from 'svelte-pathfinder';\n\n import { productPageParams } from './store/params';\n\n// with regular derived store\n\nexport const productData = derived(productPageParams, ($params, set) => {\n    if ($params.productId}) {\n        fetch(`/api/products/${$params.productId}`)\n            .then(res => res.json())\n            .then(set);\n    }\n}, {});\n\n// with svelte-asyncable\n\nexport const productsList = asyncable(async $query => {\n    const res = await fetch(`/api/products${$query}`)\n    return res.json();\n}, undefined, [ query ]);\n\n```\n\n### Using helper `click`\n\nAuto-handling all links in the application.\n\n```svelte\n<svelte:window on:click={click} />\n\n<!-- links below will be handled by `click` helper -->\n\n<nav class=\"navigate\">\n    <a href=\"/\">Home</a>\n    <a href=\"/products\">Products</a>\n    <a href=\"/about\">About</a>\n</nav>\n\n<!-- links below will be EXCLUDED from the navigation -->\n\n<nav class=\"not-navigate\">\n    <a href=\"http://google.com\">External links</a>\n    <a href=\"/shortlink/2hkjhrfwgsd\" rel=\"external\">Links with external rel</a>\n    <a href=\"/products\" target=\"_blank\">Any links with target</a>\n    <a href=\"/\" target=\"_self\">Any links with target even to _self</a>\n    <a href=\"/path/prices.zip\" download>Download links</a>  \n    <a href=\"mailto:mail@example.com\">Mailto links</a>\n    <a href=\"tel:+432423535\">Tel links</a>\n    <a href=\"/cart\" on:click|preventDefault|stopPropagation={doSomething}>\n        Just stop click event bubbling\n    </a>\n    <a href=\"javascript:void(0)\">Old style JS links</a>\n    <a href=\"#hashOnly\">Hash-only links</a>\n</nav>\n\n<script>\n    import { click } from 'svelte-pathfinder';\n</script>\n```\n\n### Using helpers `goto` and `back`\n\n```svelte\n<button on:click={() => back()}>Back</button> \n<button on:click={() => goto('/cart?tab=overview')}>Open cart</button>\n\n<script>\n    import { goto, back } from 'svelte-pathfinder';\n</script>\n```\n\n### Using helper `submit`\n\n```svelte\n<!-- handle GET-forms -->\n<form on:submit={submit} action=\"/products\" method=\"GET\">\n    <!-- all hidden fields will be propagated to $state by name attributes -->\n\n    <input type=\"hidden\" name=\"uid\" value={$state.uid}>\n\n    <!-- all visible fields will be propagated to $query by name attributes -->\n\n    <input name=\"q\" value={$query.q} placeholder=\"Title...\">\n\n    <select name=\"option\" value={$query.option}>\n        <option>1</option>\n        <option>2</option>\n        <option>3</option>\n    </select>\n\n    <!-- even pushed submit button will be propagated to $query by name attribute -->\n\n    <button name=\"type\" value=\"quick\">Quick search</button>\n    <button name=\"type\" value=\"fulltext\">Fulltext search</button>\n</form>\n\n<script>\n    import { submit, query, state } from 'svelte-pathfinder';\n</script>\n```\n\n### Using hooks\n\nHook is a callback function which will be executed before actual router state update to perform some side-effects. Callback function receives 3 arguments: (1) upcoming store value, (2) current store value and (3) name of the store (simple 'path', 'query' or 'fragment' string).\n\nIf callback function return explicit `false`, specific router state update and subsequent navigation will be skipped. It can be useful for some kind of guards for specific router states.\n\nHooks applicable only for major stores such as path, query or fragment. Hook can be added using `hook` method of particular store which is returns `cancel` function:\n\n```javascript\nonDestroy(path.hook(($path, $currentPath, name) => {\n\n    if ($path[0] === 'my' && ! isAuthorized()) return false; // skip router state update\n\n    // do some additional side-effect\n\n    console.log(`Hook of ${name} performed`); // output: Hook of path performed\n}));\n```\n\n> ‚ö†Ô∏è Note: hooks are not pre-defined thing that's why it matters when and in what order the hooks are created in your app. When the hook is just added, the callback function will be executed instantly with upcoming value (first argument) equals `null` which means not actual state update, but that the hook was just cocked. You able to use this fact in some way:\n\n```javascript\nonDestroy(query.hook(($query, $currentQuery, name) => {\n    if ($query === null) {\n        console.log(`Hook for ${name} is just added`);\n    }   \n}));\n```\n\nMultiple hooks can be added to each particular store and they will be executed in order of adding hooks to the store. By default, if some hook returns explicit false value, execution process will be stoped immediately which is more optimized. If you need to perform all hooks in any case, just use `prefs.breakHooks = false`. In this case, all hooks will be executed but state still won't be updated and navigation won't be performed.\n\n## üîñ SSR support (highly experimental)\n\n```javascript\nrequire('svelte/register');\n\nconst express = require('express');\n\nconst app = express();\n...\n/* any other routes */\n...\napp.get('*', (req, res) => {\n    const router = require('svelte-pathfinder/ssr')();\n    const App = require('./App.svelte').default;\n\n    router.goto(req.url);\n\n    const { html, head, css } = App.render({ router });\n\n    res.send(`\n        <!DOCTYPE html>\n        <html>\n            <head>\n                ${head}\n                ${css}\n            </head>\n            <body>\n                ${html}\n            </body>\n        </html>\n    `);\n});\n```\n\n> ‚ö†Ô∏è Note: you can't use `pathfinder` stores by just directly import it in SSR rendered applications (just like the other Svelte stores), because, in-fact, they're global to the entire server instance. To avoid it, just pass `pathfinder` instance to root component via props and use it in all components of application. For example using context:\n\n```svelte\n<!-- App.svelte -->\n<svelte:window on:click={router.click}/>\n<script>\n    import { setContext } from 'svelte';\n\n    export let router;\n    setContext('router', router);\n</script>\n```\n\n```svelte\n<!-- Nested.svelte -->\n<script>\n    import { getContext } from 'svelte';\n\n    const { path } = getContext('router');\n\n    function gotoSomething() {\n        $path = '/something';\n    }\n</script>\n```\n\n## üö© Assumptions\n\n### Optional side-effect (changing browser history and URL)\n\nRouter will automatically perform `pushState` to browser History API and listening `popstate` event if the following conditions are valid:\n\n* router works in browser and global objects are available (window & history).\n* router works in browser which is support `pushState/popstate`.\n* router works in top-level window and has no parent window (eg. iframe, frame, object, window.open).\n\nIf any condition is not applicable, the router will work properly but without side-effect (changing URL).\n\n### `hashbang` routing (`#!`)\n\nRouter will automatically switch to `hashbang` routing in the following conditions:\n\n* `History API` is not available.\n* web app has launched under `file:` protocol.\n* initial path contain exact file name with extension.\n\n## ¬© License\n\nMIT &copy; [PaulMaly](https://github.com/PaulMaly)\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 160],
		[3596, 311],
		[3603, 387],
		[3610, 311],
		[3617, 362],
		[3624, 347],
		[3631, 340],
		[3638, 214],
		[3645, 122],
		[3652, 203],
		[3659, 237],
		[3666, 218],
		[3673, 224],
		[3680, 262],
		[3687, 278],
		[3694, 245],
		[3701, 379],
		[3708, 269],
		[3715, 338],
		[3722, 383],
		[3729, 376],
		[3736, 265],
		[3743, 288],
		[3750, 351],
		[3757, 497],
		[3764, 584],
		[3771, 349],
		[3778, 410],
		[3785, 461],
		[3792, 299],
		[3799, 277],
		[3806, 324],
		[3813, 393],
		[3820, 319],
		[3827, 385],
		[3834, 341],
		[3841, 562],
		[3848, 386],
		[3855, 582],
		[3862, 491],
		[3869, 478],
		[3876, 490],
		[3883, 556],
		[3890, 526],
		[3897, 563],
		[3904, 514],
		[3911, 678],
		[3918, 563],
		[3925, 628],
		[3932, 556],
		[3939, 449],
		[3946, 579],
		[3953, 620],
		[3960, 670],
		[3967, 706],
		[3974, 849],
		[3981, 579],
		[3988, 690],
		[3995, 884],
		[4002, 727],
		[4009, 134],
		[4016, 86],
		[4023, 529],
		[4030, 590],
		[4037, 605],
		[4044, 973],
		[4051, 646],
		[4058, 680],
		[4065, 489],
		[4072, 877],
		[4079, 712],
		[4086, 788],
		[4093, 780],
		[4100, 943],
		[4107, 826],
		[4114, 817],
		[4121, 954],
		[4128, 815]
	],
	"esm": true,
	"cjs": false
}
