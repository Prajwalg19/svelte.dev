{
	"name": "@svelstack/state",
	"description": "Manage Svelte Promise/Future states with AsyncableFutureState.",
	"repo_url": "https://github.com/svelstack/state",
	"authors": ["martk"],
	"homepage": "https://github.com/svelstack/state",
	"downloads": 82,
	"updated": "2025-04-07T13:40:55.159Z",
	"tags": ["miscellaneous"],
	"github_stars": 0,
	"typescript": true,
	"version": "1.3.0",
	"svelte_range": "^5.0.0",
	"kit_range": "^2.7.3",
	"last_rune_check_version": "1.3.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@svelstack/state",
				"version": "1.3.0",
				"size": 53534
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# The only Svelte Promise/Future states you will need\n\n```shell\nnpm i @svelstack/state\n```\n\n<!-- TOC -->\n* [The only Svelte Promise/Future states you will need](#the-only-svelte-promisefuture-states-you-will-need)\n  * [FutureState](#futurestate)\n  * [Usage](#usage)\n    * [Is $effect() calling safe and fast?](#is-effect-calling-safe-and-fast)\n    * [Lazy loading](#lazy-loading)\n    * [Server side rendering](#server-side-rendering)\n    * [Side effects](#side-effects)\n    * [Deep reactivity](#deep-reactivity)\n    * [Load everything or nothing](#load-everything-or-nothing)\n    * [My API is very fast and I want to avoid flickering](#my-api-is-very-fast-and-i-want-to-avoid-flickering)\n    * [I want to display more helpful error messages to the user](#i-want-to-display-more-helpful-error-messages-to-the-user)\n    * [Extending functionality of FutureState](#extending-functionality-of-futurestate)\n* [Best Practices](#best-practices)\n  * [Await as component](#await-as-component)\n* [Examples](#examples)\n  * [Search](#search)\n  * [Infinite scroll](#infinite-scroll)\n  * [Load more](#load-more)\n<!-- TOC -->\n\n\n## FutureState\n\nBase class for all future states.\n\n```typescript\nexport abstract class FutureState<TValue = any> {\n    /** \n     * The current value of the state.\n     * \n     * @throws UninitializedStateError if the state has not yet loaded or is undefined.\n     */\n    abstract readonly value: TValue;\n\n    /** The current value of the state, or `undefined` if not yet loaded. */\n    abstract readonly valueOrUndefined: TValue | undefined;\n\n    /** Indicates if the state is currently in the loading process. */\n    abstract readonly loading: boolean;\n\n    /** Indicates if the value has successfully loaded and is not undefined. */\n    abstract readonly loaded: boolean;\n\n    /** Indicates if the state is currently in the refreshing process. */\n    abstract readonly refreshing: boolean;\n\n    /**\n\t * Holds an error message if an error occurred during loading or refreshing, otherwise `undefined`.\n\t */\n\tabstract readonly error: FutureStateError | undefined;\n\n    protected options: FutureStateOptions;\n\n    constructor(options?: Partial<FutureStateOptions>);\n\n    /**\n     * Clears the current states. Resetting `value`, `error`, and indicators.\n     */\n    abstract clear(): void;\n\n    /**\n     * Initiates the loading process to retrieve the state value.\n     * @returns A promise that resolves with the loaded value.\n     */\n    abstract load(): Promise<TValue>;\n\n    /**\n     * Refreshes the state. If `clear` is true, the state will be cleared and\n     * loading will start instead of refreshing.\n     *\n     * Default value is `false` if not provided.\n     * @param clear If true, clears the state before starting the loading process.\n     */\n    abstract refresh(clear?: boolean): Promise<void>;\n\n    /**\n     * Effect handler, replacing `load()`, `mount()`, and `unmount()` methods in a Svelte component.\n     *\n     * Usage: `$effect(state.effect())`\n     * Usage: `$effect(state.effect(() => mounted))`\n     *\n     * @param conditionFn Optional condition function; if provided, the effect will only execute if this function returns true.\n     * @returns A function that can be called to stop the effect.\n     */\n    effect(conditionFn?: () => boolean): () => void;\n\n    /**\n     * Starts listening to subscribers, such as an invoker, and manages state updates in response.\n     * In Svelte components, call the `effect()` method instead.\n     * @returns A function to stop listening to subscribers.\n     */\n    abstract mount(): () => void;\n\n    /**\n     * Configures global options for all instances of `FutureState`.\n     * @param options Partial options to set or override default settings.\n     */\n    static configure(options: Partial<FutureStateOptions>): void;\n}\n```\n\n`AsyncableFutureState` is likely the most frequently used class, and you will use it to create custom future states.\nOther classes are provided for more specific use cases.\n\n`AppendableFutureState` allows you to append new values to the existing value.\n`ComposableFutureState` is a more advanced class that allows you to compose multiple future states into a single state.\n`ExtendableFutureState` allows you to create a future state with custom actions.\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n    const store = new AsyncableFutureState(() => fetch('...'));\n    \n    $effect(store.effect());\n</script>\n\n{#if store.loading}\n    <p>Loading...</p>\n{:else if store.error}\n    <p>{store.error.message}</p>\n{:else}\n    <p>{store.value}</p>\n{/if}\n```\n\n### Is $effect() calling safe and fast?\n\nAbsolutely! Technically speaking, the effect method automatically subscribes to the explicitly defined subscribers, \ntracks state changes, and automatically unsubscribes them.\n\nIt's the same as using this:\n\n```typescript\nif (!ssrEnabled) {\n    const umnount = store.mount();\n\n    // ...\n\n    unmount();\n}\n```\n\nNo side effects!\n\n```svelte\n\n<script lang=\"ts\">\n    let id = $state(0);\n    const store = new AsyncableFutureState(\n        () => fetch(`${id}`) // <--- notice\n    );\n        \n    $effect(store.effect());\n</script>\n```\n\nThis can be like shooting yourself in the foot if not used properly, so side effects are disabled. The method is called only once, no matter how many times the variable `id` changes. If you need to use side effects, read the section `Invokers`.\n\n\n### Lazy loading\n\nSometimes you want to load the state only when it's needed. You can use the condition function in the `effect()` method to achieve this.\n\n```svelte\n<script lang=\"ts\">\n    let mounted = $state(false);\n    const store = new AsyncableFutureState(() => fetch('...'));\n    \n    $effect(store.effect(() => mounted)); // <--- notice\n</script>\n```\nThe state will be loaded/refreshed only when `mounted` is `true`.\n\n### Server side rendering\n\nIf you want to load a state on the server side, you can use the `setValue(...)` method.\n\n```svelte\n<script lang=\"ts\">\n    /** @type {{ data: import('./$types').PageData }} */\n    let { data } = $props();\n\n    const store = new AsyncableFutureState(() => fetch('...'))\n      .setValue(data.valueForStore);\n    \n    $effect(store.effect());\n</script>\n```\n\n### Side effects\n\nIf you need to use side effects, you can use the `FutureRunesInvoker`\n\n```svelte\n<script lang=\"ts\">\n    let variableWithoutSideEffect = $state(0);\n    let id = $state(1);\n    let page = $state(1);\n    \n    const store = new AsyncableFutureState(new FutureRunesInvoker(\n        (id, page) => fetch(`${id}/${page}/${variableWithoutSideEffect}`),\n        () => [id, page],\n    ));\n    $effect(store.effect());\n</script>\n```\n\nThe state will be refreshed every time `id` or `page` changes. The `variableWithoutSideEffect` will not trigger a refresh.\n\n### Deep reactivity\n\nBy default, values are not deeply reactive for performance reasons.\n\n```svelte\n<script>\n    import { AsyncableFutureState } from '$lib';\n\n    let store = new AsyncableFutureState(\n        () => Promise.resolve([{ label: 'foo', checked: false }, { label: 'bar', checked: false }])\n    );\n    $effect(store.effect());\n</script>\n\n{#if store.loaded}\n    {#each store.value as item}\n        <div>\n            Checked: {item.checked} <!-- Always false -->\n            <input type=\"checkbox\" bind:checked={item.checked}>\n            {item.label}\n        </div>\n    {/each}\n{/if}\n```\n\nIf you want to make them deeply reactive\n\n```svelte\n<script>\n    import { AsyncableFutureState } from '$lib';\n\n    let store = new AsyncableFutureState(\n        () => Promise.resolve([{ label: 'foo', checked: false }, { label: 'bar', checked: false }]),\n        { deepReactivity: true }, // <--- notice\n    );\n    $effect(store.effect());\n</script>\n\n{#if store.loaded}\n    {#each store.value as item}\n        <div>\n            Checked: {item.checked} <!-- Changing -->\n            <input type=\"checkbox\" bind:checked={item.checked}>\n            {item.label}\n        </div>\n    {/each}\n{/if}\n```\n\n### Load everything or nothing\n\nIf you have multiple states that need to be loaded before rendering, you can use the `ComposableFutureState` class.\n\n```svelte\n\n<script lang=\"ts\">\n    const store = new ComposableFutureState([\n        new AsyncableFutureState(() => fetch('...')),\n        new AsyncableFutureState(() => fetch('...')),\n    ]);\n    $effect(store.effect());\n</script>\n\n{#if store.loaded}\n    <p>{store.value[0]}</p> <!-- First store -->\n    <p>{store.value[1]}</p> <!-- Second store -->\n{/if}\n```\n\n### My API is very fast and I want to avoid flickering\n\nSolution is very simple, look at the example below:\n\n```typescript\nconst store = new AsyncableFutureState(() => fetch('...'), {\n    indicatorsDelay: 300, // <--- notice\n});\n```\n\nor globally:\n\n```typescript\nFutureState.configure({\n    indicatorsDelay: 300,\n});\n```\n\n### I want to display more helpful error messages to the user\n\nYou can use the `exceptionHandler` option to handle errors.\n\n```typescript\nfunction myExceptionHandler(error: any) {\n    let message = 'An error occurred';\n    let details = {} as Record<string, any>;\n\t\n    if (error instanceof ClientSafeError) {\n        message = error.message;\n        details = error.details;\n    }\n\n    return { original: error, message, details };\n}\n```\n\n```typescript\nconst store = new AsyncableFutureState(() => fetch('...'), {\n    exceptionHandler: myExceptionHandler,\n});\n```\n\nor globally:\n\n```typescript\nFutureState.configure({\n    exceptionHandler: myExceptionHandler,\n});\n```\n\n### Extending functionality of FutureState\n\nIf you need to add custom actions to a state, you can use the `ExtendableFutureState` class. For advanced use cases, you can extend `FutureState` or `AsyncableFutureState` class.\n\n```typescript\nclass FavoriteArticlesState extends ExtendableFutureState<number[]> {\n    \n    constructor(\n        private articleRepository: ArticleRepository,\n    ) {\n        super(() => this.articleRepository.getFavoriteArticles());\n    }\n        \n    async toggle(id: number) {\n        if (!this.loaded) {\n            return;\n        }\n\n        if (this.has(id)) {\n            await this.articleRepository.removeFromFavourites(id);\n\n            this.remove(id);\n        } else {\n            await this.articleRepository.addToFavorites(id);\n\n            this.add(id);\n        }\n    }\n\n    add(id: string) {\n        this.modify((favorites) => {\n            return [...favorites, id];\n        });\n    }\n\n    remove(id: string) {\n        this.modify((favorites) => {\n            const index = favorites.indexOf(id);\n\n            if (index !== -1) {\n                favorites.splice(index, 1);\n            }\n\n            return [...favorites];\n        });\n    }\n\n    has(id: string) {\n        return this.valueOrUndefined?.includes(id) ?? false;\n    }\n        \n}\n```\n\nThe `modify()` method is used to update the state value. It runs only if the state is loaded. Always return a new array or object to trigger a state update.\n\n# Best Practices\n\n## Await as component\n\nAwaitAsyncable.svelte\n```svelte\n<script lang=\"ts\" generics=\"T extends FutureState\">\n    import { AppendableFutureState, FutureState } from '@svelstack/state';\n    import { type Snippet } from 'svelte';\n\n    interface Props {\n        store: T;\n        children: Snippet<[ T extends FutureState<infer U> ? U : never ]>;\n        indicators?: boolean;\n    }\n\n    let { store, children, indicators = true }: Props = $props();\n\n    let appending = $derived(store instanceof AppendableFutureState ? store.appending : false);\n</script>\n\n{#if indicators && store.refreshing}\n    Refreshing...\n{/if}\n\n{#if indicators && store.loading}\n    Loading...\n{:else if store.loaded}\n    {@render children(store.value)}\n{:else if store.error}\n    {store.error.message}\n{/if}\n\n{#if appending}\n    Appending...\n{/if}\n```\n\nUsage:\n    \n```svelte\n<script lang=\"ts\">\n    const store = new AsyncableFutureState(() => fetch('...'));\n    \n    $effect(store.effect());\n</script>\n\n<AwaitAsyncable {store}>\n    {store.value}\n</AwaitAsyncable>\n\n<!-- or -->\n\n<AwaitAsyncable {store}>\n    {#snippet children(item)}\n        {item} \n    {/snippet}\n</AwaitAsyncable>\n```\n\n# Examples\n\n## Search\n\nFor search functionality we need to debounce the input value. We can use the `DebouncedFutureInvoker` to achieve this.\n\n```svelte\n\n<script lang=\"ts\">\n    let term = $state('');\n    let normalizedTerm = $derived(term.trim());\n\n    const debounceTime = 300;\n    const invoker = new DebouncedFutureInvoker(new FutureRunesInvoker(\n        (term) => fetch(`${ term }`),\n        () => [normalizedTerm],\n    ), debounceTime);\n    const store = new AsyncableFutureState(invoker);\n    \n    $effect(store.effect(() => {\n        return normalizedTerm.length > 0; // Send request only when the term is not empty\n    }));\n</script>\n\n<AwaitAsyncable {store}>\n  <!-- Render the results -->\n</AwaitAsyncable>\n```\n\n## Infinite scroll\n\nFor infinite scroll functionality we need to know when the user has reached the bottom of the page. We can use the `IntersectionObserver` to achieve this.\n\n```svelte\n<script lang=\"ts\" generics=\"T extends any[]\">\n    import type { AppendableFutureState } from '@svelstack/state';\n    import { untrack } from 'svelte';\n\n    interface Props {\n        store: AppendableFutureState<T>;\n        /**\n         * The threshold in pixels from the bottom of the container at which the loadMore event is triggered.\n         */\n        threshold?: number;\n    }\n\n    let { store, threshold = 400 }: Props = $props();\n\n    let anchor: HTMLElement;\n\n    function loadMore() {\n        store.next();\n    }\n\n    function observe(threshold: number, anchor: HTMLElement, finished: boolean) {\n        return untrack(() => {\n            if (finished) return () => {};\n\n            const observer = new IntersectionObserver((entries) => {\n                if (entries[0].isIntersecting) {\n                    loadMore();\n                }\n            }, {\n                root: getScrollParent(anchor.parentElement),\n                rootMargin: `${threshold}px`,\n                threshold: 0,\n            });\n\n            observer.observe(anchor);\n\n            return () => {\n                observer.disconnect();\n            };\n        });\n    }\n\n    function getScrollParent(node: Element | null) {\n        if (node == null) {\n            return null;\n        }\n\n        if (node.scrollHeight > node.clientHeight) {\n            return node;\n        } else {\n            return getScrollParent(node.parentElement);\n        }\n    }\n\n    $effect(() => {\n        return observe(threshold, anchor, store.finished);\n    });\n</script>\n\n<div bind:this={anchor}></div>\n```\n\nAnd the usage:\n\n```svelte\n<script lang=\"ts\">\n    const store = new AppendableFutureState(\n        (pointer) => {\n            const data = getData(pointer.page);\n            // With PagePointer you can manually set the page and finished state (optional)\n            pointer.setNextPage(data.page || pointer.page + 1, data.isLastPage);\n          \n            return data.values;\n        },\n        new PagePointer(), // or use new PredictablePagePointer() for better predictability if each page has the same number of items.\n    );\n    $effect(store.effect());\n</script>\n\n<AwaitAsyncable {store}>\n    {#each store.value as item}\n        <!-- Render the item -->\n    {/each}\n  \n    <InfiniteScroll {store} />\n</AwaitAsyncable>\n```\n\n## Load more\nLoad more functionality is very common. We can use the `AppendableFutureState` to achieve this.\n\n```svelte\n<script lang=\"ts\" generics=\"T extends any[]\">\n\timport type { AppendableFutureState } from '@svelstack/state';\n\n\tinterface Props {\n\t\tstore: AppendableFutureState<T>;\n\t}\n\n\tlet { store }: Props = $props();\n\n\tlet appending = $state(false); // a bit faster than store.appending, but you can use only store.appending if you want\n\n\tasync function loadMore() {\n\t\tappending = true;\n\n\t\ttry {\n\t\t\tawait store.next();\n\t\t} finally {\n\t\t\tappending = false;\n\t\t}\n\t}\n</script>\n\n{#if !store.finished}\n\t<button type=\"button\" disabled={appending || store.appending} onclick={loadMore}>\n\t\t{#if appending || store.appending}\n\t\t\tLoading...\n\t\t{:else}\n\t\t\tLoad More\n\t\t{/if}\n\t</button>\n{/if}\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 4],
		[3596, 30],
		[3603, 31],
		[3610, 115],
		[3617, 30],
		[3624, 14],
		[3631, 15],
		[3638, 7],
		[3645, 7],
		[3652, 32],
		[3659, 21],
		[3666, 37],
		[3673, 34],
		[3680, 7],
		[3687, 15],
		[3694, 9],
		[3701, 37],
		[3708, 10],
		[3715, 25],
		[3722, 9],
		[3729, 14],
		[3736, 7],
		[3743, 9],
		[3750, 13],
		[3757, 8],
		[3764, 11],
		[3771, 5],
		[3778, 53],
		[3785, 2],
		[3799, 2],
		[3806, 27],
		[3813, 17],
		[3820, 21],
		[3827, 2],
		[3834, 13],
		[3841, 84],
		[3848, 3],
		[3855, 5],
		[3862, 41],
		[3869, 18],
		[3876, 1],
		[3883, 19],
		[3890, 5],
		[3897, 26],
		[3904, 11],
		[3911, 13],
		[3918, 15],
		[3925, 9],
		[3932, 6],
		[3939, 4],
		[3946, 11],
		[3953, 261],
		[3960, 446],
		[3967, 19],
		[3974, 31],
		[3981, 23],
		[3988, 31],
		[3995, 20],
		[4002, 11],
		[4009, 5],
		[4016, 22],
		[4023, 29],
		[4030, 106],
		[4037, 29],
		[4044, 57],
		[4051, 53],
		[4058, 9],
		[4065, 21],
		[4072, 17],
		[4079, 6],
		[4086, 11],
		[4093, 43],
		[4100, 86],
		[4107, 16],
		[4114, 82],
		[4121, 14],
		[4128, 26]
	],
	"esm": true,
	"cjs": false
}
