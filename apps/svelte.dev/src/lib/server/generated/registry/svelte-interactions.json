{
	"name": "svelte-interactions",
	"description": "Provides Svelte actions for consistent press, hover, and long press interactions.",
	"repo_url": "https://github.com/huntabyte/svelte-interactions",
	"authors": ["huntabyte"],
	"homepage": "https://github.com/huntabyte/svelte-interactions#readme",
	"downloads": 88,
	"updated": "2024-01-10T01:18:25.606Z",
	"tags": ["ui"],
	"github_stars": 122,
	"typescript": true,
	"version": "0.2.0",
	"svelte_range": "^4.0.0",
	"kit_range": "^2.0.0",
	"last_rune_check_version": "0.2.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-interactions",
				"version": "0.2.0",
				"size": 119703
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# Svelte Interactions\n\nAt surface level, interactions may seem like a simple concept, but once you start peeling back the onion they are quite complex. For something as simple as a button to behave properly across all browsers and devices, you need more than just a `click` event handler.\n\nIf you aren't convinced, it's highly recommended to read [this three-part blog post](https://react-spectrum.adobe.com/blog/building-a-button-part-1.html), which goes into detail about the complexities of interactions.\n\nThis project is heavily inspired by that article and contains a ton of code derived from [React Aria's](https://react-spectrum.adobe.com) Interactions packages. It aims to provide a similar API for Svelte, in the form of [Svelte Actions](https://svelte.dev/docs/svelte-action) and eventually spreadable event attributes (once Svelte 5 is released).\n\nWhile this project is still in its infancy, it'll be documented here. It will eventually get a dedicated website, but for now this will have to do.\n\n## Installation\n\n```bash\nnpm install svelte-interactions\n```\n\n## Press Interaction\n\nThe `press` interaction is used to implement buttons, links, and other pressable elements. It handles mouse, touch, and keyboard interactions, and ensures that the element is accessible to screen readers and keyboard users.\n\nNo more having to wrangle all those event handlers yourself! Just and use the `press` action along with the different `PressEvents` to provide a consistent experience across all browsers and devices.\n\n#### Basic Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { createPress } from 'svelte-interactions';\n\n\tconst { pressAction } = createPress();\n</script>\n\n<button\n\tuse:pressAction\n\ton:press={(e) => {\n\t\tconsole.log('you just pressed a button!', e);\n\t}}\n>\n\tPress Me\n</button>\n```\n\n### createPress\n\nCreates a new `press` interaction instance. Each element should have its own instance, as it maintains state for a single element. For example, if you had multiple buttons on a page:\n\n```svelte\n<script lang=\"ts\">\n\timport { createPress } from 'svelte-interactions';\n\n\tconst { pressAction: pressOne } = createPress();\n\tconst { pressAction: pressTwo } = createPress();\n</script>\n\n<button use:pressOne on:press> Button One </button>\n<button use:pressTwo on:press> Button Two </button>\n```\n\n#### PressConfig\n\n`createPress` takes in an optional `PressConfig` object, which can be used to customize the interaction.\n\n```ts\nimport { createPress } from 'svelte-interactions';\n\nconst { pressAction } = createPress({ isDisabled: true });\n```\n\n```ts\ntype PressConfig = PressHandlers {\n\t/**\n\t * Whether the target is in a controlled press state\n\t * (e.g. an overlay it triggers is open).\n\t *\n\t * @default false\n\t */\n\tisPressed?: boolean;\n\n\t/**\n\t * Whether the press events should be disabled.\n\t *\n\t * @default false\n\t */\n\tisDisabled?: boolean;\n\n\t/**\n\t * Whether the target should not receive focus on press.\n\t *\n\t * @default false\n\t */\n\tpreventFocusOnPress?: boolean;\n\n\t/**\n\t * Whether press events should be canceled when the pointer\n\t * leaves the target while pressed. By default, this is\n\t * `false`, which means if the pointer returns back over\n\t * the target while pressed, `pressstart`/`onPressStart`\n\t * will be fired again. If set to `true`, the press is\n\t * canceled when the pointer leaves the target and\n\t * `pressstart`/`onPressStart` will not be fired if the\n\t * pointer returns.\n\t *\n\t * @default false\n\t */\n\tshouldCancelOnPointerExit?: boolean;\n\n\t/**\n\t * Whether text selection should be enabled on the pressable element.\n\t */\n\tallowTextSelectionOnPress?: boolean;\n};\n```\n\nThe `PressConfig` object also includes handlers for all the different `PressHandlers`. These are provided as a convenience, should you prefer to handle the events here rather than the custom `on:press*` events dispatched by the element with the `pressAction`.\n\nBe aware that event if you use these handlers, the custom `on:press*` events for whatever handlers you use will not be dispatched to the element. We only dispatch the events that aren't handled by the `PressHandlers`.\n\n```ts\ntype PressHandlers = {\n\t/**\n\t * Handler called when the press is released over the target.\n\t */\n\tonPress?: (e: PressEvent) => void;\n\n\t/**\n\t * Handler called when a press interaction starts.\n\t */\n\tonPressStart?: (e: PressEvent) => void;\n\n\t/**\n\t * Handler called when a press interaction ends, either over\n\t * the target or when the pointer leaves the target.\n\t */\n\tonPressEnd?: (e: PressEvent) => void;\n\n\t/**\n\t * Handler called when the press state changes.\n\t */\n\tonPressChange?: (isPressed: boolean) => void;\n\n\t/**\n\t * Handler called when a press is released over the target,\n\t * regardless of whether it started on the target or not.\n\t */\n\tonPressUp?: (e: PressEvent) => void;\n};\n```\n\n### PressResult\n\nThe `createPress` function returns a `PressResult` object, which contains the `pressAction` action, and the `isPressed` state. More returned properties may be added in the future if needed.\n\n```ts\ntype PressResult = {\n\t/** Whether the target is currently pressed. */\n\tisPressed: Readable<boolean>;\n\t/** A Svelte Action which handles applying the event listeners to the element. */\n\tpressAction: (node: HTMLElement | SVGElement) => PressActionReturn;\n};\n```\n\n### Custom Events\n\nWhen you apply the `pressAction` to an element, it will dispatch custom `on:press*` events. You can use these or the `PressHandlers` to handle the various press events.\n\n```ts\ntype PressActionReturn = ActionReturn<\n\tundefined,\n\t{\n\t\t/**\n\t\t * Dispatched when the press is released over the target.\n\t\t */\n\t\t'on:press'?: (e: CustomEvent<PressEvent>) => void;\n\n\t\t/**\n\t\t * Dispatched when a press interaction starts.\n\t\t */\n\t\t'on:pressstart'?: (e: CustomEvent<PressEvent>) => void;\n\n\t\t/**\n\t\t * Dispatched when a press interaction ends, either over\n\t\t * the target or when the pointer leaves the target.\n\t\t */\n\t\t'on:pressend'?: (e: CustomEvent<PressEvent>) => void;\n\n\t\t/**\n\t\t * Dispatched when a press is released over the target,\n\t\t * regardless of whether it started on the target or not.\n\t\t */\n\t\t'on:pressup'?: (e: CustomEvent<PressEvent>) => void;\n\t}\n>;\n```\n\n#### PressEvent\n\nThis is the event object dispatched by the custom `on:press*` events, and is also passed to the `PressHandlers` should you choose to use them.\n\n```ts\ntype PointerType = 'mouse' | 'pen' | 'touch' | 'keyboard' | 'virtual';\n\ninterface PressEvent {\n\t/** The type of press event being fired. */\n\ttype: 'pressstart' | 'pressend' | 'pressup' | 'press';\n\n\t/** The pointer type that triggered the press event. */\n\tpointerType: PointerType;\n\n\t/** The target element of the press event. */\n\ttarget: Element;\n\n\t/** Whether the shift keyboard modifier was held during the press event. */\n\tshiftKey: boolean;\n\n\t/** Whether the ctrl keyboard modifier was held during the press event. */\n\tctrlKey: boolean;\n\n\t/** Whether the meta keyboard modifier was held during the press event. */\n\tmetaKey: boolean;\n\n\t/** Whether the alt keyboard modifier was held during the press event. */\n\taltKey: boolean;\n\n\t/**\n\t * By default, press events stop propagation to parent elements.\n\t * In cases where a handler decides not to handle a specific event,\n\t * it can call `continuePropagation()` to allow a parent to handle it.\n\t */\n\tcontinuePropagation(): void;\n}\n```\n\n## Long Press Interaction\n\nThe `hover` interaction provides an API for consistent long press behavior across all browsers and devices, with support for a custom time threshold and accessible description.\n\n#### Basic Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { createLongPress } from 'svelte-interactions';\n\n\tconst { longPressAction } = createLongPress();\n</script>\n\n<button\n\tuse:longPressAction\n\ton:longpress={(e) => {\n\t\tconsole.log('you just long pressed a button!', e);\n\t}}\n>\n\tLong Press Me\n</button>\n```\n\n### createLongPress\n\nCreates a new `longpress` interaction instance. Each element should have its own instance, as it maintains state for a single element. For example, if you had multiple buttons on a page:\n\n```svelte\n<script lang=\"ts\">\n\timport { createLongPress } from 'svelte-interactions';\n\n\tconst { longPressAction: longPressOne } = createLongPress();\n\tconst { longPressAction: longPressTwo } = createLongPress();\n</script>\n\n<button use:longPressOne on:longpress> Button One </button>\n<button use:longPressTwo on:longpress> Button Two </button>\n```\n\n#### LongPressConfig\n\n`createLongPress` takes in an optional `LongPressConfig` object, which can be used to customize the interaction.\n\n```ts\nimport { createLongPress } from 'svelte-interactions';\n\nconst { pressLongAction } = createPress({ isDisabled: true, threshold: 1000 });\n```\n\n```ts\ntype LongPressConfig = LongPressHandlers & {\n\t/**\n\t * Whether the long press events should be disabled\n\t */\n\tisDisabled?: boolean;\n\n\t/**\n\t * The amount of time (in milliseconds) to wait before\n\t * triggering a long press event.\n\t */\n\tthreshold?: number;\n\n\t/**\n\t * A description for assistive techology users indicating that a\n\t * long press action is available, e.g. \"Long press to open menu\".\n\t */\n\taccessibilityDescription?: string;\n};\n```\n\nThe `LongPressConfig` object also includes handlers for all the different `LongPressHandlers`. These are provided as a convenience, should you prefer to handle the events here rather than the custom `on:longpress*` events dispatched by the element with the `longPressAction`.\n\nBe aware that event if you use these handlers, the custom `on:longpress*` events for whatever handlers you use will not be dispatched to the element. We only dispatch the events that aren't handled by the `LongPressHandlers`.\n\n```ts\nexport type LongPressHandlers = {\n\t/**\n\t * Handler that is called when a long press interaction starts.\n\t */\n\tonLongPressStart?: (e: LongPressEvent) => void;\n\n\t/**\n\t * Handler that is called when a long press interaction ends, either\n\t * over the target or when the pointer leaves the target.\n\t */\n\tonLongPressEnd?: (e: LongPressEvent) => void;\n\n\t/**\n\t * Handler that is called when the threshold time is met while\n\t * the press is over the target.\n\t */\n\tonLongPress?: (e: LongPressEvent) => void;\n};\n```\n\n### LongPressResult\n\nThe `createLongPress` function returns a `LongPressResult` object, which contains the `longPressAction` action, and the `description` state. More returned properties may be added in the future if needed.\n\n```ts\ntype LongPressResult = {\n\t/**\n\t * A Svelte action which handles applying the event listeners\n\t * and dispatching events to the element\n\t */\n\tlongPressAction: (node: HTMLElement | SVGElement) => LongPressActionReturn;\n\n\t/**\n\t * A writable store to manage the accessible description for the long\n\t * press action. It's initially populated with the value passed to the\n\t * `accessibilityDescription` config option, but can be updated at any\n\t * time by calling `description.set()`, and the new description will\n\t * reflect in the DOM.\n\t */\n\taccessibilityDescription: Writable<string | undefined>;\n};\n```\n\n### Custom Events\n\nWhen you apply the `longPressAction` to an element, it will dispatch custom `on:longpress*` events for events you aren't handling via the `LongPressConfig` props. You can use these or the `LongPressHandlers` to handle the various `longpress` events.\n\n```ts\ntype LongPressActionReturn = ActionReturn<\n\tundefined,\n\t{\n\t\t/**\n\t\t * Dispatched when the threshold time is met while\n\t\t * the press is over the target.\n\t\t */\n\t\t'on:longpress'?: (e: CustomEvent<LongPressEvent>) => void;\n\n\t\t/**\n\t\t * Dispatched when a long press interaction starts.\n\t\t */\n\t\t'on:longpressstart'?: (e: CustomEvent<LongPressEvent>) => void;\n\n\t\t/**\n\t\t * Dispatched when a long press interaction ends, either\n\t\t * over the target or when the pointer leaves the target.\n\t\t */\n\t\t'on:longpressend'?: (e: CustomEvent<LongPressEvent>) => void;\n\t}\n>;\n```\n\n#### PressEvent\n\nThis is the event object dispatched by the custom `on:press*` events, and is also passed to the `PressHandlers` should you choose to use them.\n\n```ts\ntype PointerType = 'mouse' | 'pen' | 'touch' | 'keyboard' | 'virtual';\n\ninterface PressEvent {\n\t/** The type of longpress event being fired. */\n\ttype: 'longpressstart' | 'longpressend' | 'longpress';\n\n\t/** The pointer type that triggered the press event. */\n\tpointerType: PointerType;\n\n\t/** The target element of the press event. */\n\ttarget: Element;\n\n\t/** Whether the shift keyboard modifier was held during the press event. */\n\tshiftKey: boolean;\n\n\t/** Whether the ctrl keyboard modifier was held during the press event. */\n\tctrlKey: boolean;\n\n\t/** Whether the meta keyboard modifier was held during the press event. */\n\tmetaKey: boolean;\n\n\t/** Whether the alt keyboard modifier was held during the press event. */\n\taltKey: boolean;\n}\n```\n\n## Hover Interaction\n\nThe `hover` interaction provides an API for consistent hover behavior across all browsers and devices, ignoring emulated mouse events on touch devices.\n\n#### Basic Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { createHover } from 'svelte-interactions';\n\n\tconst { hoverAction } = createHover();\n</script>\n\n<button\n\tuse:hoverAction\n\ton:hoverstart={(e) => {\n\t\tconsole.log('you just hovered me!', e);\n\t}}\n\ton:hoverstart={(e) => {\n\t\tconsole.log('you just unhovered me!', e);\n\t}}\n>\n\tPress Me\n</button>\n```\n\n### createHover\n\nCreates a new `hover` interaction instance. Each element should have its own instance, as it maintains state for a single element. For example, if you had multiple elements you wanted to apply hover state to on a page:\n\n```svelte\n<script lang=\"ts\">\n\timport { createPress } from 'svelte-interactions';\n\n\tconst { hoverAction: hoverOne } = createHover();\n\tconst { hoverAction: hoverTwo } = createHover();\n</script>\n\n<div use:hoverOne on:hoverstart>Hoverable element one</div>\n<div use:hoverTwo on:hoverstart>Hoverable element two</div>\n```\n\n#### HoverConfig\n\nThe `createHover` function takes in an optional `HoverConfig` object, which can be used to customize the interaction.\n\n```ts\nimport { createHover } from 'svelte-interactions';\n\nconst { hoverAction } = createHover({ isDisabled: true });\n```\n\n```ts\ntype HoverConfig = HoverHandlers & {\n\t/**\n\t * Whether the hover events should be disabled\n\t */\n\tisDisabled?: boolean;\n};\n```\n\nThe `HoverConfig` object also includes handlers for all the different `HoverHandlers`. These are provided as a convenience, should you prefer to handle the events here rather than the custom `on:hover*` events dispatched by the element with the `hoverAction`.\n\nBe aware that event if you use these handlers, the custom `on:hover*` events for whatever handlers you use will not be dispatched to the element. We only dispatch the events that aren't handled by the `HoverHandlers`.\n\n```ts\ntype HoverHandlers = {\n\t/**\n\t * Handler called when a hover interaction starts.\n\t */\n\tonHoverStart?: (e: HoverEvent) => void;\n\n\t/**\n\t * Handler called when a hover interaction ends.\n\t */\n\tonHoverEnd?: (e: HoverEvent) => void;\n\n\t/**\n\t * Handler called when the hover state changes.\n\t */\n\tonHoverChange?: (isHovering: boolean) => void;\n};\n```\n\n### HoverResult\n\nThe `createHover` function returns a `HoverResult` object, which contains the `hoverAction` action, and the `isHovering` state. More returned properties may be added in the future if needed.\n\n```ts\nexport type HoverResult = {\n\t/**\n\t * Whether the element is currently being hovered\n\t */\n\tisHovered: Readable<boolean>;\n\n\t/**\n\t * A Svelte action which handles applying the event listeners\n\t * to the element and dispatching the custom `on:hover*` events.\n\t */\n\thoverAction: (node: HTMLElement | SVGElement) => HoverActionReturn;\n};\n```\n\n### Custom Events\n\nWhen you apply the `hoverAction` to an element, it will dispatch custom `on:hover*` events. You can use these or the `HoverHandlers` to handle the various hover events.\n\n```ts\ntype HoverActionReturn = ActionReturn<\n\tundefined,\n\t{\n\t\t/**\n\t\t * Dispatched when a hover interaction starts.\n\t\t */\n\t\t'on:hoverstart'?: (e: CustomEvent<HoverEvent>) => void;\n\n\t\t/**\n\t\t * Dispatched when a hover interaction ends.\n\t\t */\n\t\t'on:hoverend'?: (e: CustomEvent<HoverEvent>) => void;\n\t}\n>;\n```\n\n#### HoverEvent\n\nThis is the event object dispatched by the custom `on:hover*` events, and is also passed to the `HoverHandlers` should you choose to use them.\n\n```ts\ninterface HoverEvent {\n\t/** The type of hover event being fired. */\n\ttype: 'hoverstart' | 'hoverend';\n\t/** The pointer type that triggered the hover event. */\n\tpointerType: 'mouse' | 'pen';\n\t/** The target element of the hover event. */\n\ttarget: Element;\n}\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3652, 109],
		[3659, 160],
		[3666, 33],
		[3673, 57],
		[3680, 29],
		[3687, 40],
		[3694, 94],
		[3701, 9],
		[3708, 8],
		[3715, 10],
		[3722, 7],
		[3729, 55],
		[3736, 17],
		[3743, 17],
		[3750, 62],
		[3757, 26],
		[3764, 25],
		[3771, 32],
		[3778, 29],
		[3785, 7],
		[3792, 14],
		[3799, 72],
		[3806, 170],
		[3813, 73],
		[3820, 79],
		[3827, 190],
		[3834, 34],
		[3841, 72],
		[3848, 108],
		[3855, 167],
		[3862, 50],
		[3869, 25],
		[3876, 33],
		[3883, 60],
		[3890, 159],
		[3897, 151],
		[3904, 128],
		[3911, 50],
		[3918, 48],
		[3925, 38],
		[3932, 43],
		[3939, 21],
		[3946, 15],
		[3953, 20],
		[3960, 75],
		[3967, 142],
		[3974, 209],
		[3981, 112],
		[3988, 130],
		[3995, 151],
		[4002, 115],
		[4009, 1257],
		[4016, 245],
		[4023, 681],
		[4030, 200],
		[4037, 137],
		[4044, 122],
		[4051, 145],
		[4058, 128],
		[4065, 103],
		[4072, 122],
		[4079, 131],
		[4086, 138],
		[4093, 112],
		[4100, 102],
		[4107, 120],
		[4114, 88],
		[4121, 121],
		[4128, 62]
	]
}
