{
	"name": "@playbyteinc/svelte-schema-form",
	"description": "Generate forms from JSON Schema in Svelte applications.",
	"repo_url": "https://github.com/playbyteinc/svelte-schema-form",
	"authors": ["matthewrobb"],
	"homepage": "https://github.com/playbyteinc/svelte-schema-form#readme",
	"downloads": 5,
	"updated": "2023-01-06T19:29:58.981Z",
	"tags": ["tooling"],
	"github_stars": 0,
	"typescript": true,
	"version": "0.1.5",
	"svelte_range": "^3.54.0",
	"kit_range": "^1.0.0",
	"last_rune_check_version": "0.1.5",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@playbyteinc/svelte-schema-form",
				"version": "0.1.5",
				"size": 118254
			},
			{
				"name": "@exodus/schemasafe",
				"version": "1.3.0",
				"size": 139033
			},
			{
				"name": "lodash-es",
				"version": "4.17.21",
				"size": 636080
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2]
		],
		"circular": []
	},
	"readme": "# Svelte Schema Form\r\n\r\nThis is a Svelte implementation of a form generator from JSON Schema. It supports subforms, lists with reordering of items, custom renderer components, and customisable CSS skinning separating layout and look-and-feel.\r\n\r\nJSON Schema is a powerful validation/type definition language for JSON data. See this for more information on [JSON Schema](https://cswr.github.io/JsonSchema/spec/introduction/)\r\n\r\n## How to use\r\n\r\nInstall with npm\r\n\r\n\tnpm install @restspace/svelte-schema-form\r\n\r\nUse in a component\r\n\r\n\t<script>\r\n\t  import { SubmitForm } from '@restspace/svelte-schema-form';\r\n\t  import '@restspace/svelte-schema-form/css/layout.css';\r\n\t  import '@restspace/svelte-schema-form/css/basic-skin.css';\r\n\r\n\t  let schema = {\r\n\t\t  type: \"object\",\r\n\t\t  properties: {\r\n\t\t\t  \"x\": { \"type\": \"string\" }\r\n\t\t  }\r\n\t  };\r\n\t  let value = {};\r\n\r\n\t  const submit = (e) => {\r\n\t\t  alert(JSON.stringify(e.detail.value, undefined, 2));\r\n\t  }\r\n\t</script>\r\n\r\n\t<SubmitForm {schema} {value} on:submit={submit} />\r\n\r\nThe `layout.css` file creates a standard form layout. `basic-skin.css` adds a very simple skin with fonts, colours etc on top of that. Note, you'll likely need to configure your bundler to interpret importing css to make this work.\r\n\r\nThe `SubmitForm` component manages validation of the entered data using the full JSON Schema spec and renders any error messages beside the relevant components. Standard behaviour is that errors are not shown until the Submit button has been clicked at least once.\r\n\r\n## JSON Schema support\r\n\r\n| Feature | Support |\r\n|---|---|\r\n|title|This property is used to label a field or fieldset, if it's absent a conversion from camel case (myFieldName) to proper case (My Field Name) is done. Newlines in the string are converted to br tags in HTML|\r\n|description|This property is shown beside the label as a tooltip using the HTML title attribute or as a subheading for arrays/objects.|\r\n|readOnly|This property if present and set to `true` will disable the editor for this field, only using it for display. All children of this field will also be read only|\r\n|type=\"string\"|By default, renders as an input element with type=\"text\"|\r\n|minLength, maxLength|Supported in validation|\r\n|pattern|Supported in validation|\r\n|format|Support for `password`, `email`, `date`, `time` and `date-time` via HTML input type|\r\n|type=\"number\"|By default, renders as an input element with type=\"number\"|\r\n|minimum, maximum|Supported in validation|\r\n|exclusiveMinimum, exclusiveMaximum|Supported in validation|\r\n|enum|A field with the enum property is instead rendered as a Select element with all the enum options given|\r\n|enumText|Custom property to supply display labels for the Select element as an array of strings, one for each enum value|\r\n|type=\"object\"|Every object is rendered within an HTML Fieldset element with a form field for each property|\r\n|required|Object fields named in the `required` list have to have a value entered to be valid. Required fields have the `required` class added to their labels to enable this to be displayed.\r\n|type=\"array\"|Every array is rendered within an HTML Fieldset element with controls for adding, deleting, moving and duplicating array items (based on the `items` property)|\r\n|emptyDisplay|Custom property which determines how the array displays if it has no items. `false` means don't show a header or wrapper. `true` means show the header and wrapper with no items. A string value means display this message in the wrapper.\r\n|controls|Custom property which is a comma separated list of controls including `delete`, `duplicate`, `reorder`, `add`. Default is all these. A readOnly array has no controls.| \r\n|editor|Custom property that lets you pick a custom editor for a schema.|\r\n|||\r\n\r\n## Components\r\n\r\n### SchemaForm\r\nA group of based on a schema, no submit functionality\r\n\r\n    import {SchemaForm} from \"@restspace/svelte-schema-form\";\r\n\r\n\t<SchemaForm\r\n\t  schema // REQUIRED: JSON schema as an object\r\n\t  value // REQUIRED: JSON value to initialise the form with, for an empty form use {}\r\n\t  uploadFiles // Map with keys as property paths to upload editors, values as File objects in those editors\r\n\t  dirty // Whether the form is dirty i.e. the user has changed it from its initial value\r\n\t  showErrors // Whether the form should show errors\r\n\t  components // Map with keys as editor names (value of editor property in schema), values as constructors of editor components\r\n\t  collapsible // Whether objects and arrays are shown with collapsers which can hide them (default = false)\r\n\t  componentContext // Data for custom editors\r\n\t/>\r\n\r\n### SubmitForm\r\nAn HTML form with a submit button and a submit flow\r\n\r\n    import {SubmitForm} from \"@restspace/svelte-schema-form\";\r\n\r\n\t<SubmitForm\r\n\t  schema // REQUIRED: JSON schema as an object\r\n\t  value // REQUIRED: JSON value to initialise the form with, for an empty form use {}\r\n\t  uploadFiles // Map with keys as property paths to upload editors, values as File objects in those editors\r\n\t  uploadBaseUrl // A base URL to which uploaded files are PUT on submit. Subpaths are chosen to be unique.\r\n\t  uploadNamePattern // A substition pattern for the unique name of this record, e.g. this might be '${email}' for a person's details with a property/field named `email`\r\n\t  dirty // Whether the form is dirty i.e. the user has changed it from its initial value\r\n\t  components // Map with keys as editor names (value of editor property in schema), values as constructors of editor components\r\n\t  collapsible // Whether objects and arrays are shown with collapsers which can hide them (default = false)\r\n\t  submitText // Text shown in the submit button (defaults to 'Submit')\r\n\t  submitRequiresDirty // Whether the submit button requires the form to be dirty to submit (default = true)\r\n\t  componentContext // Data for custom editors\r\n\t/>\r\n\r\n## Custom editors\r\n\r\n### Currency\r\n\r\nSetting `editor=\"currency\"` on a `type=\"number\"` subschema renders it as a currency field. This automatically inserts a currency symbol in the input field, by default this is a `$` but can be changed to another symbol via setting the `currencySymbol` property on the object passed in to the `componentContext` prop, to e.g. 'Â£'. You can also specify a custom formatting function which takes a value of type number and returns a string and set the `formatCurrency` property on `componentContext` to this function.\r\n\r\n### Radio\r\n\r\nSetting `editor=\"radio\"` on a subschema with `enum` set renders the enum as radio buttons instead of a select.\r\n\r\n### Upload\r\n\r\nSetting `editor=\"upload\"` on a `type=\"string\"` subschema means that this property will be rendered as a file uploader. This component requies a `SubmitForm`. The file uploader allows files to be dragged onto it, or to be clicked to open a file dialog. Files are sent on submit via a PUT request to a path composed:\r\n\r\n    <uploadBaseUrl>/<uploadName>/<path>/<filename of file>\r\n\r\n- `uploadBaseUrl` is the prop on `SubmitForm`\r\n- `uploadName` is the `uploadNamePattern` with form field value(s) substituted in for `${<property path>}` codes so as to create a name that will be unique for each stored record\r\n- `path` is the property path of the upload control with dot separators and array poitions just being an index with no square brackets e.g. `profilePics.3.image`\r\n  \r\nAfter successful submit, the property value for the editor is set to the url where the file was uploaded. The uploader has a button at the right bottom to switch modes to show a text input field with the url of the stored file.\r\n\r\n### Autocomplete\r\n\r\nSetting `editor=\"autocomplete\"` on a `type=\"string\"` subschema means this property will be rendered as an autocomplete dropdown. The autocomplete component is a text box which on each keystroke sends the entered text to a remote url to get a list of matching items which are then shown as a dropdown. The user can choose one of the displayed items at any point.\r\n\r\nThe schema needs an additional property `url` set to the base url for remote querying. Example subschema:\r\n\r\n    {\r\n\t\t\"type\": \"string\",\r\n\t\t\"editor\": \"autocomplete\",\r\n\t\t\"url\": \"https://mysite.com/autocompletes\"\r\n\t}\r\n\r\n\r\nTo this url is added the query string item `match=xyz` where xyz is the current text in the search box to match on. A `GET` request is made to the result. The url should respond with an `application/json` body which can either be\r\n\r\n    [ \"dropdown item 1\", \"dropdown item 2\", ... ]\r\n\r\nor\r\n\r\n    [\r\n\t\t{\r\n\t\t\t\"id\": \"1234\",\r\n\t\t\t\"text\": \"An item title\",\r\n\t\t\t\"image\": \"https://images.com/an-image.jpg\"\r\n\t\t}, ...\r\n\t]\r\n\r\nIn the latter case, the `id` field is returned as the value of the editor, the `text` field determines the text shown in the field, and the optional `image` url gives an image to display alongside the text.\r\n\r\n### List Detail\r\n\r\nSetting `editor=\"list-detail\"` on a `type=\"array\"` subschema whose items are `type=\"object\"` shows the list of objects in a listing grid which when a row is selected, switches to the normal editor for the object selected. It also provides heading-click view ordering (without mutating the order of the underlying data list). It responds to the `emptyDisplay` and\r\n`controls` custom properties defined for an array.\r\n\r\nThe `type=\"object\"` subschema can have two optional custom schema properties:\r\n- `headings`: an array of property names which are included as columns in the list. Defaults to all columns.\r\n- `defaultSort`: an object with properties `field` which specifies the default heading field to sort on, and `direction` which can be `\"asc\"` or `\"desc\"` to specify the direction of the default sort.\r\n\r\n## Custom rendering components\r\n\r\nSvelte Schema Form can override or add rendering components at any level by supplying a map of component type names and component classes.\r\n\r\nFor example components, look in the /src/lib/editors directory. As an illustration, consider the Number.svelte default editor:\r\n\r\n\t<script lang=\"ts\">\r\n\t\timport type { CommonComponentParameters } from \"../types/CommonComponentParameters\";\r\n\t\texport let params: CommonComponentParameters;\r\n\t\texport let schema: any;\r\n\t\texport let value: any;\r\n\t</script>\r\n\r\n\t<!-- event which calls pathChanged should be after all bindings so 'value' will have been updated -->\r\n\t<svelte:component this={params.components['fieldWrapper']} {params} {schema}>\r\n\t\t<input id={params.path.join('.')} name={params.path.join('.')}\r\n\t\t\ttype=\"number\" value={value || ''}\r\n\t\t\tdisabled={schema.readOnly}\r\n\t\t\ton:input={ev => {\r\n\t\t\t\tlet val = parseFloat(ev.currentTarget.value);\r\n\t\t\t\tparams.pathChanged(params.path, isNaN(val) ? undefined : val);\r\n\t\t\t}}\r\n\t\t/>\r\n\t</svelte:component>\r\n\r\nThe component needs to have the 3 props shown in this component. `schema` and `value` are the local parts of the full schema and value which need to be rendered by this component. `params` contains a number of constant values defining the component including `params.pathChanged` which is a function that needs to be called with the property path to the value the component is rendering (this is `params.path`) and the new value when the value of the form field is changed.\r\n\r\nNote how the editor supports the `readOnly` attribute by disabling the editor if set.\r\n\r\nThe `<svelte:component>` component wrapping the markup renders the default FieldWrapper.svelte component around the actual editor: this adds the field's standard label and error message.\r\n\r\nAn example of how to configure a custom component:\r\n\r\n\t<script>\r\n\t  import MyEditor from \"./MyComponent.svelte\";\r\n\r\n\t  let components = {\r\n\t\t  \"myEditor\": MyEditor\r\n\t  };\r\n\t  ...\r\n\t</script>\r\n\r\n\t<SubmitForm {schema} {value} on:submit={submit} {components} />\r\n\r\nYou'd then make use of this custom editor component in a schema like this:\r\n\r\n\t{\r\n\t\t\"type\": \"object\",\r\n\t\t\"properties\": {\r\n\t\t\t\"myField\": {\r\n\t\t\t\t\"type\": \"string\", \r\n\t\t\t\t\"editor\": \"myEditor\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nThe key in the `components` map is matched to, in priority order, the `editor` property, then the `format` property, then the `type` property. This means you can also substitute editors for field groupings, which is more tricky. Work from the Array.svelte and Object.svelte default editor components in the repo.",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 2],
		[3596, 2],
		[3603, 1],
		[3617, 1],
		[3624, 1],
		[3638, 3],
		[3659, 1],
		[3666, 2],
		[3694, 1],
		[3715, 1],
		[3736, 1],
		[3743, 3],
		[3764, 2],
		[3778, 2],
		[3785, 1],
		[3792, 7],
		[3806, 1],
		[3813, 1],
		[3820, 2],
		[3834, 2],
		[3841, 6],
		[3862, 2],
		[3869, 1],
		[3876, 1],
		[3883, 1],
		[3890, 1],
		[3918, 1],
		[3932, 2],
		[3939, 2],
		[3967, 2],
		[3995, 1],
		[4016, 3],
		[4030, 1],
		[4037, 4],
		[4044, 8],
		[4051, 1],
		[4058, 2],
		[4072, 1],
		[4093, 4],
		[4100, 4],
		[4114, 5],
		[4121, 5],
		[4128, 2]
	],
	"esm": true,
	"cjs": false
}
