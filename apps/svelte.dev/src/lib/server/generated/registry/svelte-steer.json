{
	"name": "svelte-steer",
	"description": "Router with lazy-loading and nested routes for Svelte apps.",
	"repo_url": "https://github.com/emedware/svelte-steer",
	"authors": ["eeddow"],
	"homepage": "https://github.com/emedware/svelte-steer",
	"downloads": 6,
	"updated": "2022-03-28T15:15:32.344Z",
	"tags": ["router"],
	"github_stars": 0,
	"typescript": true,
	"version": "0.0.3",
	"svelte_range": "^3.44.3",
	"last_rune_check_version": "0.0.3",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-steer",
				"version": "0.0.3",
				"size": 130001
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# svelte-steer\r\n\r\n[![npm](https://img.shields.io/npm/v/svelte-steer.svg)](https://www.npmjs.com/package/svelte-steer)\r\n\r\nAs there is curently no dedicated nor even suitable router for svelte, and as we needed a powerful and flexible one, we decided to make one and make it a dedicated package.\r\n\r\nJust released [2021-12-29], it is still highly to be tested, corrected and receive suggestions/PRs - Beta mode.\r\n\r\n## Installation / usage\r\n\r\n```sh\r\nnpm i -S svelte-steer\r\n```\r\n\r\n```typescript\r\nimport { Router, Route, Link, link } from \"svelte-steer\";\r\nconst router = <Routing>getContext('router');\r\n----\r\n$:    myLink = router.link('user', {id: 42});\r\n----\r\n$:    myLink = router.link('/user/42');  // Don't laugh - if we are in a nested router, this might become `/en/user/42` or `/de/user/42` depending of the parent router\r\n```\r\n\r\n```html\r\n<Router {routes} >\r\n    ...\r\n    <Link route=\"user\" parms={{id: 42}}>  <!-- named route -->\r\n    ----\r\n    <Link route=\"/user/42\">  <!-- url path -->\r\n    ...\r\n    <Route>404</Route>\r\n    ...\r\n</Router>\r\n```\r\n\r\n### Main difference with common routers\r\n\r\nThe `Router` object contains only the state of the routing. On the HTML generation level, it just forwards the content. It manages every routing-related activity/elements (`Route`, `Link`, `getContext('router')`, &c.) that happen inside.\r\n\r\nThe `Route` element effectively displays the selected route.\r\n\r\n## Elements\r\n\r\n### `Router`\r\n\r\n#### Properties\r\n\r\n`variableMarker`\r\n: `/^\\:/` : Variables in the path are written `\":variable-name\"`\r\n\r\n`routes`\r\n: Gives the [`Route`](#route-definition)`[]` tree of routes to serve\r\n\r\n`history`\r\n: History mode to use. Two modes are defined by default.\r\n\r\n- `H5History` uses the Html5 history mode : `http://mysite/my/route/path`\r\n- `HashHistory` uses the hash as history mode : `http://mysite/#my/route/path`\r\n\r\nBy default, `H5History` is used.\r\n\r\nHint: If you don't use a SPA server, for example serving the app from the file system, the hash history is required. Changing to hash happens like this :\r\n\r\n```html\r\n<Router history={HashHistory} ...>\r\n...\r\n</Router>\r\n<script lang=\"ts\">\r\n    import { HashHistory } from \"svelte-steer\";\r\n    ...\r\n</script>\r\n```\r\nAlso, changing the history mode requires nothing else. All the `<Link ...>` and calls to [Routing](#routing) will act accordingly.\r\n### `Route`\r\n\r\n#### Slot\r\n\r\nThe slot is displayed if no route is found. The `error` value can be used to display more information.\r\n\r\n#### Properties\r\n\r\nA route can be forced (and hence the router state ignored) if this is specified :\r\n\r\n- `route`: `RouteMatch`\r\n: Either the path (begins with a '/') or the name of the route to point to\r\n- `params`: `Record<string, string>`\r\n: If a route name is provided, this is the dictionary of the properties to give.\r\n\r\nState feedbacks :\r\n\r\n- `loading`: `Writable<boolean>`\r\n: Set to true when waiting a lazy-load\r\n- `error`: `Writable<Error>`\r\n: Set (or unset if value is `undefined`) to the the route-related error. In error state, the slot is displayed. The slot is displayed without error when the route is not found.\r\n\r\n### Link\r\n\r\n#### Properties\r\n\r\n`route`\r\n: Either the path (begins with a '/') or the name of the route to point to\r\n\r\n`params`\r\n: If a route name is provided, this is the dictionary of the properties to give.\r\n\r\n## Annex\r\n\r\n### Route determination\r\n\r\nWhen a `(route: string, params: Record<string, string>)` is used, like the attributes of the `<Link>` element or the parameters to the `match` function, either the route begins with a '/' - in which case the `params` part is ignored and the route string is analyzed as a path, either it does not begin with a '/' and is therefore used as a route name.\r\n\r\nIf two routes have the name \"details\", one under the route \"author\" and one under the route \"book\", the name \"details\" will raise an ambiguity error. The names `\"author/details\"` and `\"book/details\"` (where both \"author\", \"book\" and \"details were given as route names) are valid and non-ambiguous.\r\n\r\n### Contexts\r\n\r\n#### `\"router\"`\r\n\r\nInterface to interract with the router - see [Routing](#routing).\r\n\r\n#### `\"route\"`\r\n\r\nGive the `Readable<`[`RouteMatch`](#route-match)`>` directly contained in this route.\r\n\r\n### Structures\r\n\r\n#### Routing\r\n\r\nWhen in a router, the context `\"router\"` is the following interface :\r\n\r\n```ts\r\ninterface Routing {\r\n    link(path: string | RouteMatch, props?: Record<string, string>): string;\r\n    match(path: string, props?: Record<string, string>): RouteMatch;\r\n    navigate(path: string, props?: Record<string, string>, push: boolean = true);\r\n    replace(path: string, props?: Record<string, string>);\r\n    go(delta: number);\r\n}\r\n```\r\n\r\nExample:\r\n\r\n```ts\r\nlet router = <Routing>getContext('router');\r\n\r\nrouter.navigate('/new/url');\r\n```\r\n\r\n#### Route definition\r\n\r\n```ts\r\ninterface RouteDesc {\r\n    name?: string;\r\n    path: string;\r\n    component?: Lazy<SvelteComponent>;\r\n    nested?: RouteDesc[];\r\n    async enter?(route: RouteMatch): Promise<boolean | void>;\r\n    async properties?(props: Record<string, string>, route: RouteMatch): Promise<boolean | void>;\r\n    leave?(route: RouteMatch): string | void;\r\n    meta?: any;\r\n}\r\n```\r\n\r\n- `name` is only used to refer to this route by its name. Some function can take the name of a route to refer to it.\r\n- `path` refer to the whole path of the route. Each part begining with a `:` defines a parameter (like every router: `/user/:id`).\r\n- `component` is the component to display (lazy-loaded). Optional: if there are nested routes, not specifying a component is equivalent to specify a component containing only `<Route />` and hence displaying directly the nested route.\r\n- `nested` is an array of nested routes.\r\n- `meta` is not used internally and is meant to be used by the user.\r\n\r\nCall-backs :\r\n\r\n- `enter` is called when a route is entered. Explicitely returning false cancels the navigation.\r\n- `leave` is called when a route is exited. Returning a string will raise a prompt with that string to ask user's confirmation of leaving.\r\n- `properties` is called when properties are changed or just after `enter` if there are properties. Explicitely returning false cancels the navigation.\r\n\r\n#### Route match\r\n\r\n```ts\r\ninterface RouteMatch {\r\n  spec: RouteSpec;\r\n  parent?: RouteMatch;\r\n  nested?: RouteMatch;\r\n  props: Record<string, string>;\r\n}\r\n```\r\n\r\n- `spec` gives all the indication of the generic route (without match). (Note, it inherits from [Routes](#route-definition))\r\n- `parent` and `nested` give both the match of the parent and nested route (if any)\r\n- `props` contains all the parameters given to the route. The prototype of this object are the parameters given to the parent route (chained)\r\n\r\n## Nesting\r\n\r\nA router routes is defined with an array of `Route` : `<Router {routes}>` - Except when it is a nested router. Nesting can be done in two ways, illustrated here : available routes are `a`, `a/c`, `a/d`.\r\n\r\n`index.svelte`\r\n\r\n```html\r\n<script>\r\n  import { Router, Route } from \"svelte-steer\";\r\n  import A from \"./a.svelte\";\r\n  import C from \"./c.svelte\";\r\n  import D from \"./d.svelte\";\r\n\r\n  let routes = [{\r\n    path: 'a',\r\n    component: A,\r\n    nested: [{\r\n      path: 'c', component: C\r\n    }, {\r\n      path: 'd', component: D\r\n    }]\r\n  }]\r\n</script>\r\n<Router {routes}><Route/></Router>\r\n```\r\n\r\n`a.svelte`\r\n\r\n```html\r\n<script>\r\n  import { Route } from \"svelte-steer\";\r\n</script>\r\na/ ... <Route />\r\n```\r\n\r\nIf route `a` does not define a component, the sub-component (`C` or `D`) will be directly used.\r\n\r\n## TODOs & participation\r\n\r\nFixes:\r\n\r\n- generate a bundled .d.ts\r\n- test & fix w/ SSR\r\n\r\nFunctionalities:\r\n\r\n- lazy loading - add a default behaviour for \"Loading...\" ? Dim old page? youtube-like \"progress\" on the screen-top?\r\n- transitions?\r\n- page preservation/destruction mgt\r\n- path i18n: \"/login\"|en, \"/connexion\"|fr, \"/autentificare\"|ro, ...\r\n- multi-parts routes : menu, center, toolbox, ....\r\n\r\nManagement of \"remaining route\", either:\r\n\r\n- Plan lazy-loaded nested route\r\n- Exception when some part of the path is not used (perhaps optionally?)\r\n- Both\r\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 5],
		[3603, 4],
		[3610, 5],
		[3624, 1],
		[3631, 1],
		[3652, 1],
		[3659, 2],
		[3666, 5],
		[3673, 1],
		[3680, 1],
		[3708, 2],
		[3722, 1],
		[3729, 5],
		[3757, 2],
		[3771, 4],
		[3778, 4],
		[3785, 1],
		[3792, 2],
		[3799, 1],
		[3806, 2],
		[3834, 1],
		[3848, 2],
		[3855, 21],
		[3869, 1],
		[3883, 1],
		[3890, 4],
		[3904, 2],
		[3911, 3],
		[3932, 1],
		[3939, 1],
		[3960, 1],
		[3981, 2],
		[4023, 3],
		[4030, 5],
		[4037, 8],
		[4044, 11],
		[4051, 1],
		[4058, 1],
		[4065, 1],
		[4093, 9],
		[4100, 10],
		[4107, 5],
		[4114, 6],
		[4121, 5],
		[4128, 2],
		[4135, 10]
	]
}
