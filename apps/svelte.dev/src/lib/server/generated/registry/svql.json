{
	"name": "svql",
	"description": "GraphQL client for Svelte 3, simplifies API interactions.",
	"repo_url": "https://github.com/pateketrueke/svql",
	"authors": ["pateketrueke"],
	"homepage": "https://github.com/pateketrueke/svql#readme",
	"downloads": 29,
	"updated": "2021-08-21T22:08:49.690Z",
	"tags": ["server"],
	"github_stars": 61,
	"typescript": false,
	"version": "0.0.35",
	"svelte_range": "3.x",
	"last_rune_check_version": "0.0.35",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svql",
				"version": "0.0.35",
				"size": 176849
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "> The _easiest_ way to consume GraphQL APIs in Svelte3\n>\n> ![Build status](https://github.com/pateketrueke/svql/workflows/build/badge.svg)\n> [![NPM version](https://badge.fury.io/js/svql.svg)](http://badge.fury.io/js/svql)\n> [![Known Vulnerabilities](https://snyk.io/test/npm/svql/badge.svg)](https://snyk.io/test/npm/svql)\n\n```html\n<script>\n  import { Out, query, setupClient } from 'svql';\n\n  setupClient({\n    url: 'https://graphql-pokemon2.vercel.app/',\n  });\n\n  const GET_POKEMON_INFO = `\n    query($name: String!) {\n      pokemon(name: $name) {\n        id name image number\n      }\n    }\n  `;\n\n  query(GET_POKEMON_INFO, { name: 'Pikachu' });\n</script>\n\n<Out nostatus from={GET_POKEMON_INFO} let:data>\n  <h3>{data.pokemon.number}. {data.pokemon.name}</h3>\n  <img alt={data.pokemon.name} src={data.pokemon.image} />\n</Out>\n```\n\n## How it works.\n\n`svql` uses a [fetchql]() singleton to talk to GraphQL. You can configure it through the `setupClient()` method.\n\nBoth `query` and `mutation` helpers will take the GQL and return a promise (or function that returns a promise, respectively).\n\n### `query(gql[, data[, callback]]): Promise`\n\n> Queries are indexed so you can refer to them as `from={MY_GQL_QUERY}`. `data` is optional, as is the `callback` function. Any truthy value returned by this callback will be used in-place of the regular response.\n\nAccessing those values can be done through `<Out />` components as shown above, or by watching the returned promises:\n\n```html\n<script>\n  // ...imports\n  let promise = query(GET_POKEMON_INFO, { name: 'Bulbasaur' });\n</script>\n<!-- we can use {#await promise}...{/await} -->\n```\n\nRefetching of queries can be done through reactive statements:\n\n```html\n<script>\n  // ...imports\n  export let name = '';\n  $: query(GET_POKEMON_INFO, { name });\n</script>\n```\n\nEach time `name` changes, the query re-executes.\n\n### `mutation(gql[, callback]): Function`\n\n> The callback will receive a `commit` function that accepts variables-input as first argument, and optionally a second function to handle the response. Values returned by this function are also promises.\n\nMutations are functions that could result in more work, so you need to be sure and `commit` once you're ready for the actual request:\n\n```html\n<script>\n  // ...imports\n  export let email = '';\n  let password;\n  let promise;\n  const doLogin = mutation(LOGIN_REQUEST, commit => function login() {\n    promise = commit({ email, password }, data => {\n      saveSession(data.login);\n      location.href = '/';\n    });\n  });\n</script>\n<p>Email: <input type=\"email\" bind:value={email} /></p>\n<p>Password: <input type=\"password\" bind:value={password} /></p>\n<button on:click={doLogin}>Log in</button>\n```\n\nSince `mutation()` returns a function, there's no need to setup reactive statements to _refetch_ it. Just calling the generated function is enough.\n\n## Components\n\nYou can access `svql` stores as `conn` and `state` respectively.  However, it is better to use the following components to handle state. :sunglasses:\n\n### `<Failure ... />`\n\nNo longer shipped, use a separate `Failure` component from [smoo](https://github.com/pateketrueke/smoo).\n\n### `<Status {from} {label} {pending} {otherwise} />`\n\nThis takes a `from={promise}` value, then renders its progress, catches the failure, etc.\n\nAvailable props:\n\n- `{from}` &mdash; Promise-like value to handle status changes\n- `{label}` &mdash; Label used for `{:catch error}` handling with `<Failure />`\n- `{fixed}` &mdash; Setup `<Status />` container as fixed, positioned at `left:0;bottom:0` by default\n- `{pending}` &mdash; Message while the promise is being resolved...\n- `{otherwise}` &mdash; Message while once promise has resolved successfully\n\n> With `fixed` you can provide offsets, e.g. `<Status fixed=\"{{ top: '10vh' }}\" />`\n\nAvailable slots:\n\n- `pending` &mdash; Replace the `{:await}` block, default is an `<h3 />`\n- `otherwise` &mdash; Replace the `{:then}` block, default is an `<h3 />`; it receives `let:result`\n- `exception` &mdash; Replace the  `{:catch}` block, default is `<Failure />`; it receives `let:error`\n\n### `<Out {nostatus} {loading} {...} let:data />`\n\nUse this component to access data `from={promise}` inside, or `from={GQL}` to extract it from resolved state.\n\nAvailable props:\n\n- `{nostatus}` &mdash; Boolean; its presence disables the `<Status />` render\n- `{loading}` &mdash; Message while the promise is being resolved...\n- `{...}` &mdash; Same props from `<Status />`\n- `let:data` &mdash; Unbound `data` inside\n\nAvailable slots:\n\n- `status` &mdash; Replaces the `<Status />` render with custom markup; it receives the same props as `<Status />`\n- `loading` &mdash; Replace the `{:then}` block, default is an `<h3 />`; it receives `let:result`\n- `failure` &mdash; Replace the `{:catch}` block, default is `<Failure />`; it receives `let:error`\n\n### `<In ... />`\n\nNo longer shipped, use a separate `Fence` component from [smoo](https://github.com/pateketrueke/smoo).\n\n> Loading states should be bound as `<Fence loading={$conn.loading}>...</Fence>` to properly block the UI.\n\n## Public API\n\n- `setupClient(options[, key])` &mdash; Configure a `FetchQL` singleton with the given `options`, `key` is used for session loading\n- `useClient(options[, key])` &mdash; Returns a `FetchQL` instance with the given `options`, `key` is used for session loading\n- `useToken(value[, key])` &mdash; Update the session-token used for Bearer authentication, `key` is used for session loading\n- `saveSession(data[, key])` &mdash; Serializes any given value as the current session, it MUST be a plain object or null\n- `read(gql|key)` &mdash; Retrieve current value from `state` by key, a shorthand for `$state[key]` values\n- `key(gql)` &mdash; Returns a valid `key` from GQL-strings, otherwise the same value is returned\n- `$state` &mdash; Store with all resolved state by the `fetchql` singleton\n- `$conn` &mdash; Store with connection details during `fetchql` requests\n\n> `sqvl` use **Bearer authentication** by default, so any token found in the session will be sent forth-and-back.\n\nIf you want to change your client's authorization token, you may call `client.setToken()` &mdash; or `useToken()` globally.\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 147],
		[3603, 48],
		[3610, 140],
		[3617, 126],
		[3624, 42],
		[3631, 59],
		[3638, 46],
		[3645, 54],
		[3652, 39],
		[3659, 71],
		[3666, 71],
		[3673, 16],
		[3680, 39],
		[3687, 80],
		[3694, 61],
		[3701, 43],
		[3708, 23],
		[3715, 66],
		[3722, 65],
		[3729, 41],
		[3736, 28],
		[3743, 33],
		[3750, 57],
		[3757, 47],
		[3764, 75],
		[3771, 70],
		[3778, 61],
		[3785, 79],
		[3792, 48],
		[3799, 25],
		[3806, 26],
		[3813, 16],
		[3820, 41],
		[3827, 12],
		[3834, 25],
		[3841, 24],
		[3848, 14],
		[3855, 57],
		[3862, 152],
		[3869, 21],
		[3876, 56],
		[3883, 31],
		[3890, 72],
		[3897, 82],
		[3904, 57],
		[3911, 18],
		[3918, 16],
		[3925, 16],
		[3932, 19],
		[3939, 18],
		[3946, 68],
		[3953, 21],
		[3960, 20],
		[3967, 37],
		[3974, 25],
		[3981, 35],
		[3988, 37],
		[3995, 41],
		[4002, 38],
		[4009, 28],
		[4016, 31],
		[4023, 14],
		[4030, 66],
		[4037, 49],
		[4044, 75],
		[4051, 41],
		[4058, 35],
		[4065, 89],
		[4072, 44],
		[4079, 25],
		[4086, 28],
		[4093, 32],
		[4100, 48],
		[4107, 31],
		[4114, 29],
		[4121, 42],
		[4128, 37],
		[4135, 33]
	]
}
