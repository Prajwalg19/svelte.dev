{
	"name": "svelte-querystring-router",
	"description": "Serialize Svelte app state to querystring without full routing.",
	"repo_url": "https://github.com/TehShrike/svelte-querystring-router",
	"authors": ["tehshrike"],
	"homepage": "https://github.com/TehShrike/svelte-querystring-router#readme",
	"downloads": 31,
	"updated": "2018-07-03T17:46:38.854Z",
	"tags": ["router"],
	"github_stars": 6,
	"typescript": false,
	"version": "2.0.0",
	"svelte_range": "2.9.1",
	"last_rune_check_version": "2.0.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-querystring-router",
				"version": "2.0.0",
				"size": 99281
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "A client-side router that only serializes a small amount of state to the querystring.\n\n# Use case\n\n[Svelte](https://svelte.technology/) is a new kind of component library, in that its footprint is so small that you can justifiably use it on a standalone HTML page that has a small amount of dynamic content.\n\nNormally you would want to avoid pulling in a component framework to put a component or two on a single page, but since Svelte [doesn't have the overhead of runtime code to ship to the browser](https://svelte.technology/blog/frameworks-without-the-framework), you can toss a few components onto a small page without any guilt.\n\nThese single pages don't need a full router, but you should still serialize any dynamic state to the url.  That's where this library comes in.\n\n*Note:*  don't use this library if you want a client-side router to display different Svelte components as pages based on the route. If you have a true single-page application with multiple pages, you should use [abstract-state-router](https://github.com/TehShrike/abstract-state-router).  Check out [Why your webapp needs a state-based router](http://joshduff.com/#!/post/2015-06-why-you-need-a-state-router.md) for more details.\n\n# What it does\n\n1. Gives you a `<Link>` component your components can use to generate links that update the querystring without reloading the page\n2. Keeps a `querystringParameters` parameter up to date on your top-level components when the querystring changes\n\n# Usage\n\nTo use the Link component in your components:\n\n```html\n<p>\n\tYou can totally click <Link parameters=\"{ { thingy: 'yes' } }\">this</Link>\n</p>\n{#if querystringParameters.thingy === 'yes'}\n<p>\n\tAw, yeah.\n</p>\n{/if}\n\n<script>\nconst { Link } = require('svelte-querystring-router')\n\nexport default {\n\tcomponents: {\n\t\tLink\n\t}\n}\n</script>\n```\n\nTo hook up the query string to your component, so that the `querystringParameters` value is populated, do this wherever you're instantiating your component:\n\n```js\nconst { attachQuerystringData, getCurrentParameters } = require('svelte-querystring-router')\n\nconst component = new YourCoolComponent({\n\ttarget: document.getElementById('whatever'),\n\tdata: {\n\t\tquerystringParameters: getCurrentParameters()\n\t}\n})\n\nattachQuerystringData(component) // This keeps querystringParameters updated\n```\n\n# How it works\n\nClicks on `<Link>` elements are intercepted and turned into [`pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method) calls, so that the page doesn't reload on every click.\n\nWhenever this happens, all the components that you hooked up with `attachQuerystringData()` have their `querystringParameters` data changed - any display values based on that data will change instantly without any page reloading.\n\n# API\n\nWhen you import the module, you get a global instance based on the browser's location/history globals.\n\nIt is possible to create an instance passing in shims for these functions, but I don't know if there's any use for that yet.\n\nAnyway, the instantiated instances come with this API:\n\n## `attachQuerystringData(component)`\n\n## `Link`\n\nThe component to be used in other Svelte components.  Creates an `<a href>` based on the `parameters` you pass in.\n\nTakes these attributes:\n\n- `className`: a string of class names to be applied to the `a` element\n- `style`: a style string to be applied to the `a` element\n- `parameters`: an object of properties to be turned into a querystring link\n\n## `navigate({ parameters, [querystring], [element], [replace] })`\n\nCauses a `pushState`, and fires a navigate event, updating all attached components.\n\nIf `replace` is truthy, then `replaceState` is called instead of `pushState`.\n\n## `currentQuerystring = getCurrentQuerystring()`\n\n## `currentParameters = getCurrentParameters()`\n\n## Events\n\nThere are two event-listening methods:\n\n- `removeListener = on(event, listener)`\n- `removeListener = once(event, listener)`\n\nThese events are fired:\n\n- `before navigate`\n- `navigate` - this is when `pushState` is called\n- `after navigate`\n\nAll events emit a single object as an argument, with three properties: `querystring`, `parameters`, and `element`.\n\n# License\n\n[WTFPL](http://wtfpl2.com)\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 33],
		[3596, 135],
		[3603, 102],
		[3610, 66],
		[3617, 85],
		[3624, 34],
		[3631, 59],
		[3638, 21],
		[3645, 9],
		[3652, 9],
		[3659, 6],
		[3666, 28],
		[3673, 1],
		[3680, 13],
		[3687, 12],
		[3694, 3],
		[3701, 2],
		[3715, 3],
		[3722, 6],
		[3729, 45],
		[3736, 1],
		[3743, 1],
		[3750, 4],
		[3757, 2],
		[3764, 5],
		[3771, 22],
		[3778, 1],
		[3785, 3],
		[3792, 5],
		[3799, 11],
		[3806, 10],
		[3813, 3],
		[3820, 1],
		[3827, 2],
		[3841, 6],
		[3848, 8],
		[3855, 2],
		[3862, 107],
		[3869, 4],
		[3876, 3],
		[3883, 5],
		[3890, 33],
		[3897, 48],
		[3904, 51],
		[3911, 16],
		[3918, 20],
		[3925, 37],
		[3932, 27],
		[3939, 5],
		[3946, 14],
		[3953, 28],
		[3960, 156],
		[3967, 51],
		[3974, 68],
		[3981, 31],
		[3988, 26],
		[3995, 41],
		[4002, 26],
		[4009, 17],
		[4016, 28],
		[4023, 20],
		[4030, 36],
		[4037, 74],
		[4044, 55],
		[4051, 57],
		[4058, 42],
		[4065, 51],
		[4072, 35],
		[4079, 59],
		[4086, 12],
		[4093, 52],
		[4100, 84],
		[4107, 8],
		[4114, 31],
		[4121, 50],
		[4128, 34]
	]
}
