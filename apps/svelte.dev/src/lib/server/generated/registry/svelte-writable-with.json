{
	"name": "svelte-writable-with",
	"description": "Extend Svelte writables with state, history, and local storage.",
	"repo_url": "https://github.com/SaintPepsi/svelte-writable-with",
	"authors": ["sancoca"],
	"homepage": "https://github.com/SaintPepsi/svelte-writable-with#readme",
	"downloads": 9,
	"updated": "2024-10-26T03:35:27.663Z",
	"tags": ["miscellaneous"],
	"github_stars": 0,
	"typescript": true,
	"version": "0.4.2",
	"svelte_range": "5.0.0",
	"last_rune_check_version": "0.4.2",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-writable-with",
				"version": "0.4.2",
				"size": 136786
			},
			{
				"name": "esm-env",
				"version": "1.2.2",
				"size": 3784
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "[![CI](https://github.com/SaintPepsi/svelte-writable-with/actions/workflows/ci.yml/badge.svg)](https://github.com/SaintPepsi/svelte-writable-with/actions/workflows/ci.yml)\n# svelte-writable-with\n\nA Svelte store utility library that allows you to extend the writable.\n\nWorking with Svelte's `get` to retrieve writable values can feel cumbersome, especially with the import clutter from many libraries. `withState`, inspired by [TanStack Store](https://tanstack.com/store/latest), allows you to access values directly via `store.state`. \n\nThis utility library will evolve to include other useful features.\n\n## Why `writableWith`?\n_Old way (verbose):_\n```ts\nconst store = writable('foo');\nconst value = get(store);\nconst desiredValue = someRecord[value];\n```\n\n_New way (cleaner):_\n```ts\nconst store = state(writable('foo'));\nconst desiredValue = someRecord[store.state];\n```\n\n## Installation\n\n```bash\nbun add svelte-writable-with\n```\n\n## Features\n\n### Composition\n\n`writableWith` is flexible. You can pass a direct value, a `writable`, or another `writableWith`. This keeps writables predictable and avoids introducing unwanted side effects.\n\nExample:\n```ts\nimport { state, previous } from 'svelte-writable-with';\n\ntype Modes = \"paint\" | \"pan\" | \"erase\";\n\nconst baseMode = writable('paint')\nconst { set, update, subscribe } = baseMode;\n\nconst modeWithState = state(baseMode);\nconst { set, update, subscribe, state } = baseMode;\n\nconst modeWithPreviousAndState = previous(modeWithState)\nconst { set, update, subscribe, state, previous } = baseMode;\n```\n\nEnsure you provide the primary type in the first **\"withable\"** to avoid type issues. _(Working on improving this ü§ì)_\n\n‚úÖ Correct types: \n```ts\nstate(previous(writable<Record<\"foo\" | \"bar\", boolean>>({})))\n```\n‚ùå Invalid types: `previous` will complain\n```ts\nstate<Record<\"foo\" | \"bar\", boolean>>(previous(writable({})))\n``` \n\n\n## API\n\nEach method can take either a value or a writable.\n\n### `withState`\nusage: `writableWith.state | withState`\n\nAllows access to the store's state directly, without using Svelte's `get`\n\n#### this utility returns:\n\n- **[+]** _property_ `state` - Accesses the store state directly, replacing `get(store)`.\n\n#### Usage:\n\n```ts\nconst {\n    state,      // The current state of the writable.\n    // ... writable return values\n} = withState(writable(1337));\n```\n\n#### Example:\n\nProperty access:\n\n```ts\nconst currentBenefit = withState(writable<\"spinach\" | \"broccoli\">(\"spinach\"));\n\nconst vegetableBenefits = {\n    spinach: \"Iron, vitamins, energy\",\n    broccoli: \"Fiber, heart health\",\n};\n\nfunction getBenefit() {\n    return vegetableBenefits[currentBenefit.state];\n}\n```\n\n### `withPrevious`\nusage: `writableWith.previous | withPrevious`\n\nkeeps track of the last value.\n\n#### this utility returns:\n\n- **[+]** _property_ `previous` - Returns the previous value before the store was updated.\n\n- **[%]** _method_ `subscribe` - previous value as second argument `(value, previousValue)`\n    \n- **[%]** _method_ `set` - sets the previous value before setting store state\n    \n- **[%]** _method_ `update` - sets the previous value before updating store state\n\n#### Usage:\n\n```typescript\nconst {\n    subscribe,      // Modified subscribe with 2 arguments (`value`, `previousValue`)\n    set,            // Modified set updates `previous` value\n    update,         // Modified update updates `previous` value\n    previous,       // The previous value\n} = withPrevious(writable(1337));\n```\n\n#### Example:\n\nsetting the writable back to the last value\n\n```ts\ntype States = \"paint\" | \"pan\" | \"erase\"; \nconst mode = withPrevious(writable<States>(\"paint\"));\n\n// Some condition to change mode\nmode.set(\"pan\");\n\n// Some condition to return\nmode.set(mode.previous);\n```\n\n\n### `withLocalStorage`\n\nusage: `writableWith.localStorage | withLocalStorage`\n\nStores the value in localStorage under a specific key prefixed with `svelte-writable-with:`\n\nIf the `initialValue` is a `writable` or `writableWith`, it initializes the store with the value from `localStorage` (if present).\n\n#### this utility returns:\n\n- **[+]** initialises with the `localStorage` value for that key or the `initialValue`\n    \n- **[%]** _method_ `set` - sets the value in `localStorage` - `JSON.stringify` -> `set`\n    \n- **[%]** _method_ `update` - runs the updater with the value currently in the store and stores the value in `localStorage` - `JSON.stringify` -> `set`\n\n#### Note: `withLocalStorage` is still being refined. Here are a few limitations:\n\n**‚ö†Ô∏è currently keys are not strongly typed and are just strings.**\n\nKeys and values are managed through the `WithLocalStorageKeys` interface\n\nin your `app.d.ts` or `global.d.ts` add the following:\n\n```ts\ndeclare module 'svelte-writable-with' {\n\tinterface WithLocalStorageKeys {\n\t\tSOME_KEY: number;\n\t}\n}\n```\n\n#### Features:\n- Typed Keys and values - extendable `interface` ‚úÖ\n- Automatic `JSON.parse`-ing and `JSON.stringify`-ing ‚úÖ\n- [Storage Events](https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event) ‚ùå\n- Schema Safe Parser ‚ùå (any?, [zod?](https://zod.dev/))\n\n#### Usage:\n\n```typescript\nconst {\n    set,            // Modified set updates `localStorage`\n    update,         // Modified update updates `localStorage`\n    // ... writable return values\n} = withLocalStorage('SOME_KEY', writable(1337));\n```\n\n#### Example:\n\nsetting the writable back to the last value\n\n```ts\ntype States = \"paint\" | \"pan\" | \"erase\"; \nconst mode = withPrevious(writable<States>(\"paint\"));\n\n// Change the mode\nmode.set(\"pan\");\n\n// Revert to the previous mode\nmode.set(mode.previous);\n```\n\n\n\n\n### `withHistory`\nusage: `writableWith.history | withHistory`\n\nkeeps track of an indefinite history of values.\n\n#### this utility returns:\n\n- **[+]** _property_ `history` - Returns the history writable (with state).\n\n- **[+]** _method_ `pop` - removes last value from the history object (if it exists), sets the state with the popped value and then returns the popped value\n\n- **[%]** _method_ `subscribe` - history value as second argument `(value, history)`\n    \n- **[%]** _method_ `set` - pushes the value to history before setting store state\n    \n- **[%]** _method_ `update` - pushes the value to history before updating store state\n\n#### Usage:\n\n```typescript\nconst {\n    subscribe,      // Modified subscribe with 2 arguments (`value`, `history`)\n    set,            // Modified set updates `history` value\n    update,         // Modified update updates `history` value\n    history,\t\t// The history writable\n\tpop, \t\t\t// removes last value from history and returns it (updates main store with returned value)\n} = withHistory(writable(1337));\n```\n\n#### Example:\n\nsetting the writable back to the last value\n\n```ts\ntype States = \"paint\" | \"pan\" | \"erase\"; \nconst mode = withHistory(writable<States>(\"paint\"));\n\n// Some condition to change mode\nmode.set(\"pan\");\n// history = ['paint']\nmode.set(\"paint\");\n// history = ['paint', 'pan']\nmode.set(\"erase\");\n// history = ['paint', 'pan', 'paint']\n\n// Some code...\n\nconst paintValue1 = mode.pop();\n// paintValue1 === 'paint'\n// history === ['paint', 'pan']\nconst panValue = mode.pop();\n// panValue === 'pan'\n// history === ['paint']\nconst paintValue2 = mode.pop();\n// paintValue2 === 'paint'\n// history === []\n\nconst originalMode = get(mode) // \"paint\"\n```\n\n### Common Issues:\n\n- Using any writable where a `$state` rune is expected, i.e. `\"Type 'WithState<string, Writable<boolean>>' is not assignable to type 'boolean | null | undefined'.\"`\n\n    use `fromStore` -> `import { fromStore } from 'svelte/store';` to create a reactive `$state` rune .e.g:\n    ```html\n    <script lang=\"ts\">\n    export let isDebuggerEnabled = withLocalStorage(writable(false), 'DebuggerEnabled');\n\texport let isChecked = fromStore(isDebuggerEnabled);\n    </script>\n    <input type=\"checkbox\" id=\"debugger\" name=\"debugger\" bind:checked={isChecked.current} />\n    <label for=\"debugger\">Debugger</label>\n    ```\n    \n\n### Goal:\n\nThe goal of `svelte-writable-with` is to offer an intuitive API for extending and enhancing `writable` stores based on your specific needs.\n\n\n#### Possible future extensions include\n\n-   `history`\n\n## License\n\nMIT\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3932, 472],
		[3939, 724],
		[3946, 182],
		[3953, 47],
		[3960, 4],
		[3967, 27],
		[3974, 1],
		[3981, 1],
		[3995, 10],
		[4002, 4],
		[4009, 3],
		[4016, 24],
		[4023, 28],
		[4030, 9],
		[4037, 16],
		[4044, 11],
		[4051, 13],
		[4065, 2],
		[4079, 1],
		[4100, 20],
		[4107, 43],
		[4114, 9],
		[4121, 19],
		[4128, 32],
		[4135, 11]
	],
	"esm": true,
	"cjs": true
}
