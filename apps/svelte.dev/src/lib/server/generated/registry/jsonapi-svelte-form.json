{
	"name": "jsonapi-svelte-form",
	"description": "Build forms for JSON:API backends in Svelte.",
	"repo_url": "",
	"authors": ["saibotsivad"],
	"homepage": "https://github.com/saibotsivad/jsonapi-svelte-form",
	"downloads": 25,
	"updated": "2022-05-10T16:18:36.002Z",
	"tags": ["miscellaneous"],
	"typescript": true,
	"version": "0.0.20",
	"svelte_range": "^3.43.0",
	"last_rune_check_version": "0.0.20",
	"github_stars": 0,
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "jsonapi-svelte-form",
				"version": "0.0.20",
				"size": 169065
			},
			{
				"name": "just-debounce-it",
				"version": "1.5.0",
				"size": 4848
			},
			{
				"name": "just-diff",
				"version": "3.1.1",
				"size": 9214
			},
			{
				"name": "klona",
				"version": "2.0.6",
				"size": 23173
			},
			{
				"name": "pointer-props",
				"version": "1.1.4",
				"size": 32665
			},
			{
				"name": "dlv",
				"version": "1.1.3",
				"size": 5802
			},
			{
				"name": "dset",
				"version": "3.1.4",
				"size": 10779
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2],
			[0, 3],
			[0, 4],
			[4, 5],
			[4, 6]
		],
		"circular": []
	},
	"readme": "# JSON:API Svelte Form\n\nTooling for building forms in Svelte for JSON:API backends.\n\nIf you use Svelte to build business webapps, and those webapps interact with [JSON:API](https://jsonapi.org/), than you've probably thought about building some tooling to help make it easier to build good forms, without so much boilerplate.\n\n## How to Use\n\nTo import the Svelte components (documented below):\n\n```js\nimport {\n\tField,\n\tFieldSetter,\n\tForm,\n\tFormCreate,\n\tFormRemove,\n\tMakeDiff,\n\tRelationship\n} from 'jsonapi-svelte-form'\n```\n\nTo import the mapper functions:\n\n```js\nimport { saving, error, saved } from 'jsonapi-svelte-form/mapper'\n```\n\n## The Big Idea\n\nBuild a form with a couple Svelte component wrappers:\n\n```html\n<script>\n\timport { Form, Field } from 'jsonapi-svelte-form'\n\texport let form // a specially formed object\n</script>\n<Form bind:form let:remove let:create>\n\tInside your form, bind a property to an input element:\n\t<Field bind:form let:set let:value id=\"id001\" keypath={[ 'attributes', 'color' ]}>\n\t\t<input type=\"text\" {value} on:input={event => set(event.target.value)} />\n\t</Field>\n</Form>\n```\n\nNow, you can bind values using JSON Pointer paths.\n\nThere's a demo [here](https://saibotsivad.github.io/jsonapi-svelte-form/), or as a [Svelte REPL](https://svelte.dev/repl/ca6db8ec270d4f5c9f8cd679592e8441?version=3.43.0), to see how to use the tooling.\n\n## Data Structure\n\nWhen you get a response from a JSON:API server, you map it to a `JsonApiForm` object, typically using the `load` function:\n\n```js\nimport { load } from 'jsonapi-svelte-form/mapper'\nconst fetchVehicle = () => fetch('/api/v1/vehicles/id001')\n\t.then(response => response.json())\n\t.then(load)\n```\n\nThat structure of that object looks like this:\n\n```js\nconst JsonApiForm = {\n\t// This is the data you'll mutate with your form:\n\tdata: {\n\t\tid001: {\n\t\t\tid: 'id001',\n\t\t\ttype: 'car',\n\t\t\tattributes: { /* ... */ }\n\t\t}\n\t},\n\t// A copy is kept around that isn't allowed to change...\n\toriginal: {\n\t\tid001: {\n\t\t\tid: 'id001',\n\t\t\ttype: 'car',\n\t\t\tattributes: { /* ... */ }\n\t\t}\n\t},\n\t// ...that way the changes between the two can be calculated:\n\tchanges: {\n\t\tid001: [\n\t\t\t{\n\t\t\t\top: 'add',\n\t\t\t\t// (Note: the changes are JSON Patch objects, but\n\t\t\t\t// the path is the array of accessors, instead of\n\t\t\t\t// the escaped string.)\n\t\t\t\tpath: [ 'attributes', 'color' ],\n\t\t\t\tvalue: 'red'\n\t\t\t}\n\t\t]\n\t},\n\t// If there are errors on a response, they can be mapped to this error\n\t// object, which is a map to each resource:\n\terrors: {\n\t\tid001: {\n\t\t\tattributes: {\n\t\t\t\tcolor: [\n\t\t\t\t\t// Each object is a valid JSON:API error object:\n\t\t\t\t\t// https://jsonapi.org/format/#error-objects\n\t\t\t\t\t{\n\t\t\t\t\t\tcode: 'TheServerErrorCode',\n\t\t\t\t\t\ttitle: 'Human-readable summary.',\n\t\t\t\t\t\t// etc.\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## Field Component\n\nWhen the `set` function of the `Field` component is called, e.g.:\n\n```html\n<Field bind:form let:set let:value id=\"id001\" keypath={[ 'attributes', 'color' ]}>\n\t<input type=\"text\" {value} on:input={event => set(event.target.value)} />\n</Field>\n```\n\nthe component updates the appropriate `form.data` property, and then updates the `form.changes` list by doing a diff against the `form.original` property.\n\n> **Note:** your component is responsible for handling the difference between undefined and empty-string.\n\nIn the example above, when the input element is made to be empty, the default `event.target.value` is the empty string, so the `form.data` property would be set to the empty string. This matters when calculating the `changes` list for the `form` object: if the property was originally undefined and a change event is emitted where `value` is the empty string, the `form.changes` list will not be empty.\n\nOne way to handle that difference is simply:\n\n```html\n<input ... on:input={event => set(event.target.value || undefined)} />\n```\n\nThis may be wanted or unwanted behaviour, so it is left up to your implementation to handle the difference.\n\n## Field Component API\n\nRequired properties to set on the `Field` component:\n\n* `form: JsonApiForm` - The form object needs to be bound for the reactivity to work.\n* `id: String` - The resource identifier to bind to.\n* `keypath: String | Array<String|Number>` - Either the JSON Pointer string, e.g. `\"/path/to/thing\"` or\n  the list, e.g. `[ \"path\", \"to\", \"thing\" ]`. (Note: using the string incurs a performance penalty, since\n  it will be converted to a list in the `Field` component.)\n\nOptional properties:\n\n* `debounceMillis: Integer` (default: `15`) - On every change, the diff between original and updated is calculated. This can get very expensive, and since it blocks the UI, it can cause the form to feel very jerky if many changes are made quickly. To counteract this, there is a debounce on the diff calculation, and you can modify the debounce delay with this property.\n\nEmitted events:\n\n**change** - Emitted after an object has been updated and the diff has been calculated. It emits an object with these properties.\n\n* `id: String` - The resource identifier.\n* `keypath: Array<String>` - The JSON Pointer accessor tokens.\n* `value: any` - The set value.\n\nSlot properties:\n\n* `value: any` - The value located at the resources keypath, or undefined.\n* `errors: Array<JsonApiError>` - The list of errors, or an empty list.\n* `set: Function` - Call this with the updated value, when it changes.\n* `disabled: Boolean` - A convenient property which is true if the form is in the `saving` or `loading` state.\n\n## Form Component\n\nThe `Form` component is responsible for handling creating and removing resources, so at the root of your form you'd have something like:\n\n```html\n<Form bind:form let:remove let:create on:create on:remove>\n\t<button on:click={() => create(resource)}Create</button>\n</Form>\n```\n\nNew resources are placed on the `form.data` object, with an id generated using a configurable prefix (by default `GID`) and an incrementing counter, e.g. `GID1` will be the id of the first generated resource.\n\nThe `create` function requires new resources to have their relationship defined, so e.g. on a car form you might make a `wheel` resource, but that relationship would need to be defined.\n\n## Form Component Api\n\nRequired properties to set on the `Form` component:\n\n* `form: JsonApiForm` - The form object needs to be bound for the reactivity to work.\n\nOptional properties:\n\n* `prefix: String` (default: `GID`) - The prefix used on the identifiers of created resources.\n* `suffix: String` (default: blank string) - The suffix used on the identifiers of created resources.\n\nSlot properties:\n\n* `create: Function` - Used to create a new resource with a generated identifier. Call with\n  an object containing these properties:\n  * `relId: String` - The identifier of the resource to add this to, as a relationship.\n  * `relName: String` - The relationship accessor name of the relationship.\n  * `isArray: Boolean` (optional) - Set to true if the relationship is an array style.\n  * `type: String` - The type of the resource to create.\n  * `resource: Object` - The initial state of the created resource, with `id` and `type` set, e.g. `resource = { attributes, meta }`.\n* `remove: Function` - Used to remove a resource. Call with an object containing these properties:\n  * `id: String` - The identifier of the resource to remove.\n  * `type: String` - The type of the resource to remove.\n* `disabled: Boolean` - A convenient property which is true if the form is in the `saving` or `loading` state.\n\n## License\n\nPublished and released under the [Very Open License](http://veryopenlicense.com).\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 57],
		[3596, 110],
		[3603, 20],
		[3610, 54],
		[3617, 38],
		[3624, 41],
		[3631, 66],
		[3638, 23],
		[3645, 71],
		[3652, 26],
		[3659, 45],
		[3666, 71],
		[3673, 89],
		[3680, 42],
		[3687, 64],
		[3694, 51],
		[3701, 64],
		[3708, 78],
		[3715, 46],
		[3722, 57],
		[3729, 30],
		[3736, 37],
		[3743, 22],
		[3750, 49],
		[3757, 53],
		[3764, 70],
		[3771, 47],
		[3778, 45],
		[3785, 54],
		[3792, 32],
		[3799, 62],
		[3806, 21],
		[3813, 30],
		[3820, 48],
		[3827, 25],
		[3834, 58],
		[3841, 32],
		[3848, 45],
		[3855, 106],
		[3862, 43],
		[3869, 50],
		[3876, 65],
		[3883, 13],
		[3890, 83],
		[3897, 92],
		[3904, 55],
		[3911, 54],
		[3918, 37],
		[3925, 38],
		[3932, 21],
		[3939, 31],
		[3946, 37],
		[3953, 21],
		[3960, 81],
		[3967, 96],
		[3974, 48],
		[3981, 73],
		[3988, 65],
		[3995, 56],
		[4002, 51],
		[4009, 17],
		[4016, 46],
		[4023, 63],
		[4030, 70],
		[4037, 72],
		[4044, 49],
		[4051, 57],
		[4058, 57],
		[4065, 43],
		[4072, 31],
		[4079, 91],
		[4086, 69],
		[4093, 60],
		[4100, 54],
		[4107, 19],
		[4114, 25],
		[4121, 40],
		[4128, 30]
	]
}
