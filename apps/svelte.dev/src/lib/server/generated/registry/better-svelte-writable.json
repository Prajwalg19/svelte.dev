{
	"name": "better-svelte-writable",
	"description": "Create type-safe Svelte writable stores with previous value tracking.",
	"repo_url": "",
	"authors": ["tnthung"],
	"homepage": "https://github.com/tnthung/better-svelte-writable",
	"downloads": 16,
	"updated": "2023-12-01T00:51:18.489Z",
	"tags": ["miscellaneous"],
	"typescript": true,
	"version": "0.4.2",
	"svelte_range": "^4.0.0",
	"kit_range": "^1.20.4",
	"last_rune_check_version": "0.4.2",
	"github_stars": 0,
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "better-svelte-writable",
				"version": "0.4.2",
				"size": 26212
			},
			{
				"name": "zod",
				"version": "3.24.3",
				"size": 697771
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"legacy_svelte": false,
	"readme": "# better-svelte-writable\r\n\r\n[![npm version](http://img.shields.io/npm/v/better-svelte-writable.svg)](https://www.npmjs.com/package/better-svelte-writable)\r\n[![npm downloads](https://img.shields.io/npm/dm/better-svelte-writable.svg)](https://www.npmjs.com/package/better-svelte-writable)\r\n![license](https://img.shields.io/npm/l/better-svelte-writable)\r\n\r\nThis package provides a type-safe writable which gives you more control over the container.\\\r\nThe writable is designed for you to painlessly replace with the native writable.\r\n\r\nThere are 3 problems this package is addressing:\r\n\r\n1. You can't get the previous value after the value is changed.\r\n1. Peeking the current value is not intuitive and verbose.\r\n1. Syncing the value between multiple `writable`s is not easy.\r\n\r\n\r\n## Table of Contents\r\n\r\n1. [Installation                ](#installation)\r\n1. [Demo                        ](#demo)\r\n1. [Highlight                   ](#highlight)\r\n    1. [Previous tracking       ](#previous-tracking)\r\n    1. [Value syncing           ](#value-syncing)\r\n    1. [Simple getter           ](#simple-getter)\r\n    1. [Type-safety             ](#type-safety)\r\n1. [Usage                       ](#usage)\r\n    1. [`get`                   ](#get)\r\n    1. [`previous`              ](#previous)\r\n    1. [`toReadable`            ](#toreadable)\r\n    1. [`isPersistent`          ](#ispersistent)\r\n    1. [`subscribe`             ](#subscribe)\r\n1. [Options                     ](#options)\r\n    1. [`trackerCount`          ](#trackercount)\r\n    1. [`key`                   ](#key)\r\n    1. [`isEqual`               ](#isequal)\r\n    1. [`forceEmit`             ](#forceEmit)\r\n    1. [`start`                 ](#start)\r\n    1. [`persist`               ](#persist)\r\n1. [Changelog                   ](#changelog)\r\n\r\n\r\n## Installation\r\n\r\n```bash\r\n$ npm i better-svelte-writable\r\n```\r\n\r\n## Demo\r\n\r\n[Svelte RELP](https://svelte.dev/repl/125afbe969a7409ab940f35a293e1e44?version=4.0.1)\r\n\r\n## Highlight\r\n\r\n### Previous tracking\r\n\r\nThis package letting you to keeps track as much as old values you need.\r\n[[Option: `trackerCount`]](#trackercount)\r\n\r\n### Value syncing\r\n\r\nWe provided native value syncing mechanism and it even works cross tabs.\r\n[[Option: `key`]](#key)\r\n[[Option: `persist`]](#persist)\r\n\r\n### Simple getter\r\n\r\nA light-weight getter is built-in in the `BetterWritable<T, N>` object.\r\n[[Method: `get`]](#get)\r\n\r\n### Type-safety\r\n\r\nThe available previous tracker is strictly sized to `trackerCount`.\r\n\r\n```typescript\r\nimport { writable } from \"better-svelte-writable\";\r\n\r\nconst store = writable(0, { trackerCount: 2 });\r\n\r\n{\r\n  const [\r\n    last,\r\n    penultimate,\r\n  ] = store.trackers;\r\n\r\n  store.subscribe((current, last, penultimate) => {});\r\n} // works\r\n\r\n{\r\n  const [\r\n    last,\r\n    penultimate,\r\n    antepenultimate,\r\n  ] = store.trackers;\r\n\r\n  store.subscribe((current, last, penultimate, antepenultimate) => {});\r\n} // ts(2493): Tuple type '[...]' of length '2' has no element at index '2'.\r\n```\r\n\r\nIf you're using persistent writable, and the Zod schema is provided, the type of the value will be\r\ninferred from the schema.\r\n\r\n```typescript\r\nimport { writable } from \"better-svelte-writable\";\r\n\r\n{\r\n  const store = writable(0, {\r\n    key: \"test1\",\r\n    persist: {\r\n      schema: z.number(),\r\n    }\r\n  });\r\n} // works\r\n\r\n{\r\n  const store = writable(0, {\r\n    key: \"test2\",\r\n    persist: {\r\n      schema: z.string(),\r\n    }\r\n  });\r\n} // ts(2345): Argument of type 'number' is not assignable to parameter of type 'string'.\r\n```\r\n\r\n\r\n## Usage\r\n\r\nThe `writable` from this package is a drop-in replacement for the native writable.\r\nIt provides some additional features which are listed below.\r\nBy simply replace `svelte/store` with `better-svelte-writable` in import statement,\r\nyou can unlock the power of this package.\r\n\r\n```diff\r\n- import { writable } from 'svelte/store';\r\n+ import { writable } from 'better-svelte-writable';\r\n```\r\n\r\n> `writable(value as T)` is preferred over `writable<T>(value)`,\r\n> so types can be inferred automatically from schema.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\nconst store = writable(0);\r\n\r\nconst {\r\n  // Remaining the same as the native writable\r\n  set,\r\n  update,\r\n\r\n  // New members\r\n  get,          // a method for getting the current value without invoking the update\r\n  trackers,     // an tuple which contains tracked previous values that can be used a store\r\n                // only available when `trackerCount` is provided greater than 0\r\n  previous,     // an tuple which contains the previous values\r\n  toReadable,   // a method for converting the writable to a readable\r\n  toComputed,   // a method for converting the writable to a computed\r\n\r\n  key,          // a getter for the key option\r\n  schema,       // a getter for the schema option\r\n  previous,     // an tuple which contains the previous values\r\n  overwrite,    // a getter for the overwrite option\r\n  serializer,   // a getter for the serializer option\r\n  isPersistent, // a boolean value indicates whether the value is persisted in storage\r\n\r\n  // Modified\r\n  subscribe,    // a method for subscribing to the value changes\r\n} = writable(0);\r\n\r\n// The `set`, `update`, `trackers` & `toReadable` are absent in the `BetterReadable<T>` object,\r\n// rest of the members are exactly the same as the native `Readable<T>` object\r\n```\r\n\r\n### `get`\r\n\r\nThe pain with the native `writable` is when you just need to peek the current value, the best you\r\ncan do is through the `update` function and return the old value, or by using the provided `get`\r\nmethod in `svelte/store`. This is not only verbose but also not intuitive.\r\n\r\nThe solution we provide is a native `get` method inside the return `BetterWritable<T>` object which\r\nis much straight forward and performance friendly.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\nconst store = writable(0);\r\nconsole.log(store.get()); // 0\r\n```\r\n\r\n### `trackers`\r\n\r\nThe `trackers` is an tuple which contains the `BetterReadable<T>` objects holding the previous\r\nvalues. Just like `Readable<T>` from `svelte/store`, the `BetterReadable<T>` object also has a\r\n`subscribe` method. By prefixing `$`, you can subscribe to the value changes.\r\n\r\n> The length of the tuple is determined by the `trackerCount` option.\r\n\r\n```svelte\r\n<script lang=\"ts\">\r\n  import { writable } from 'better-svelte-writable';\r\n\r\n\r\n  const store = writable(0, { trackerCount: 1 });\r\n  const prev1 = store.trackers[0];\r\n</script>\r\n\r\n<div>Current : {$store}</div>\r\n<div>Previous: {$prev1}</div>\r\n\r\n<button on:click={() => $store++}>  +  </button>\r\n<button on:click={() => $store=0}>Reset</button>\r\n<button on:click={() => $store--}>  -  </button>\r\n```\r\n\r\n### `previous`\r\n\r\nThe `previous` is an tuple which contains the previous values.\r\n\r\n> The length of the tuple is determined by the `trackerCount` option.\r\n\r\n```svelte\r\n<script lang=\"ts\">\r\n  import { writable } from 'better-svelte-writable';\r\n\r\n  const store = writable(0, { trackerCount: 1 });\r\n  const prev1 = store.trackers[0];\r\n</script>\r\n\r\n<div>Current : {$store}</div>\r\n<div>Previous: { prev1}</div>\r\n\r\n<button on:click={() => $store++}>  +  </button>\r\n<button on:click={() => $store=0}>Reset</button>\r\n<button on:click={() => $store--}>  -  </button>\r\n```\r\n\r\n### `toReadable`\r\n\r\nThe `toReadable` method is used to convert the `BetterWritable<T>` object to a `BetterReadable<T>`\r\nobject. Which is a useful wrapper to discard the mutability and use the returned as a reference.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\nconst store    = writable(0);\r\nconst readable = store.toReadable();\r\n\r\nconsole.log(readable.get())\r\n```\r\n\r\n### `toComputed`\r\n\r\nThe `toComputed` method is used to convert the `BetterWritable<T>` object to a `BetterReadable<T>`\r\nobject. Which, when get or subscribe, will first compute the value from the function passed in.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\nconst store    = writable(0);\r\nconst computed = store.toComputed(n => n * 2);\r\n\r\nconsole.log(computed.get())\r\n```\r\n\r\n### `isPersistent`\r\n\r\nThis is a simple boolean value that indicates whether the writable is persistent in storage.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\n\r\nconst store1 = writable(0, { key: \"test\", persist: true  });\r\nconst store2 = writable(0, { key: \"test\", persist: false });\r\n\r\nconsole.log(store1.isPersistent); // true\r\nconsole.log(store2.isPersistent); // false\r\n```\r\n\r\n### `subscribe`\r\n\r\nThe native `subscribe` method has one major problem, which has no way to found the old value\r\nwhen the callback is invoked. So the `subscribe` method we provide gives you the ability to\r\nsee the old value(s). The first arg is the current value and followed by the previous values.\r\n\r\n> The length of the tuple is determined by the `trackerCount` option.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\n\r\nconst store = writable(0, { trackerCount: 1 });\r\n\r\nstore.subscribe((current, last) => {\r\n  console.log(last);\r\n  console.log(current);\r\n});\r\n```\r\n\r\n\r\n## Options\r\n\r\n`writable<T>` provides an optional second argument which is an object of options.\r\n\r\n### `trackerCount`\r\n\r\n```typescript\r\ntype trackerCountOption = number;\r\n```\r\n\r\n`trackerCount` decides how many previous values will be tracked. If this option is set to `0`, the\r\nprevious values will not be tracked.\r\n\r\nThe default value of `trackerCount` is `0`.\r\n\r\n\r\n```typescript\r\nimport { writable } from \"better-svelte-writable\";\r\n\r\n\r\nconst store = writable(0, { trackerCount: 1 });\r\n\r\nstore.subscribe((n, last, penultimate) =>\r\n  console.log(last, penultimate));\r\n\r\n\r\nconst last        = store.trackers[0];\r\nconst penultimate = store.trackers[1];\r\n\r\nlast       .subscribe(n => console.log(\"last\"       , n));\r\npenultimate.subscribe(n => console.log(\"penultimate\", n));\r\n```\r\n\r\n### `key`\r\n\r\n```typescript\r\ntype keyOption = string | undefined;\r\n```\r\n\r\n`key` can be used to sync the value between multiple `writable`s.\r\nIf the `persist` option is non-falsy, the value will also be synced across tabs.\r\n\r\n> If the `key` already exists, **ALL** the other options will be ignored.\r\n\r\n> The `initialValue` will be the fallback value if the `key` never been used.\r\n\r\n> There's no way stopping you from using 2 `writable` with same `key` but different `type T`.\\\r\n  You need to make sure the type is the same manually.\r\n\r\nThe default value of `key` is `undefined`.\r\n\r\n```svelte\r\n<script lang=\"ts\">\r\n  import { writable } from 'better-svelte-writable';\r\n\r\n\r\n  const count1 = writable(0, { key: \"count\" });\r\n  const count2 = writable(0, { key: \"count\" });\r\n</script>\r\n\r\n<div>Count1: {$count1}</div>\r\n<div>Count2: {$count2}</div> <!-- also update when count1 changes -->\r\n\r\n<button on:click={() => $count1++}>  +  </button>\r\n<button on:click={() => $count1=0}>Reset</button>\r\n<button on:click={() => $count1--}>  -  </button>\r\n```\r\n\r\n### `isEqual`\r\n\r\n```typescript\r\ntype isEqualFunction = (currentValue: T, newValue: T) => boolean;\r\n```\r\n\r\n`isEqual` is the function which been used to compare the previous value with the new value, which\r\ncan be customized to fit your needs.\r\n\r\nThe default value of `isEqual` is `(a, b) => !safe_not_equal(a, b)`.\r\n\r\n### `forceEmit`\r\n\r\n```typescript\r\ntype forceEmitOption = boolean;\r\n```\r\n\r\n`forceEmit` indicates whether the callbacks will be called even if the value is not changed.\r\nIf this option is set to `true`, the equality result of `isEqual` will be ignored.\r\n\r\nThe default value of `forceEmit` is `false`.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\n\r\n{\r\n  const store = writable(0, { forceEmit: true });\r\n\r\n  store.subscribe(() => console.log('fire'));\r\n\r\n  store.set(1); // console: fire\r\n  store.set(1); // console: fire\r\n  store.set(1); // console: fire\r\n}\r\n\r\n{\r\n  const store = writable(0, { forceEmit: false });\r\n\r\n  store.subscribe(() => console.log('fire'));\r\n\r\n  store.set(1); // console: fire\r\n  store.set(1);\r\n  store.set(1);\r\n}\r\n```\r\n\r\n### `start`\r\n\r\n```typescript\r\ntype setter  = (value: T) => void;\r\ntype updater = (fn: (value: T) => T) => T;\r\n\r\ntype startFunction = (set: setter, update: updater) => (void | () => void);\r\n```\r\n\r\n`start` is a function which is will be called when the\r\n**first subscriber is added** *(not necessarily the first time)*.\\\r\nWhich may return a function which will be called when the\r\n**last subscriber is removed** *(not necessarily the last time)*.\r\n\r\nThe default value of `start` is `() => {}`.\r\n\r\n```typescript\r\nimport { writable } from 'better-svelte-writable';\r\n\r\n\r\nconst store = writable(0, {\r\n  start: (set, update) => {\r\n    console.log('start');\r\n    return () => console.log('end');\r\n  },\r\n});\r\n\r\n\r\nlet tmp1 = store.subscribe(() => {}); // console: start\r\nlet tmp2 = store.subscribe(() => {});\r\nlet tmp3 = store.subscribe(() => {});\r\n\r\ntmp2();\r\ntmp3();\r\ntmp1(); // console: end\r\n\r\n\r\nlet tmp4 = store.subscribe(() => {}); // console: start\r\n\r\ntmp4(); // console: end\r\n```\r\n\r\n### `persist`\r\n\r\n```typescript\r\ninterface Serializer<T> {\r\n  parse    : (v: string) => T;\r\n  stringify: (v: T     ) => string;\r\n};\r\n\r\ntype persistOption<T> = boolean | {\r\n  schema    ?: ZodType;\r\n  storage   ?: Storage;\r\n  overwrite ?: boolean;\r\n  serializer?: Serializer<T>;\r\n};\r\n```\r\n\r\n> If `persist` is non-falsy, the `key` option must be set.\r\n\r\n`persist` indicates whether or how will the value be stored in the storage.\r\nIf this option is set to `false`, the value will only be stored in current tab.\r\nOtherwise, the value will be stored in the storage,\r\nwhich will be synced across tabs with the `writable`s with the same `key`.\r\n\r\n2 sub-options are available:\r\n\r\n1. `storage`: The storage to be used.\\\r\n   The default value of `storage` is `localStorage`.\r\n\r\n1. `serializer`: The serializer to be used.\\\r\n   The default value of `serializer` is `JSON`.\r\n\r\n1. `schema`: The validator checking if value is invalid created with Zod.\\\r\n   The default value of `schema` is `undefined`.\r\n\r\n1. `overwrite`: Whether the value in the storage will be overwritten when invalid.\\\r\n   &gt; `\"always\" ` Overwritten whenever storage value is invalid then warn in console\\\r\n   &gt; `\"initial\"` Only overwrite when value is invalid on creation\\\r\n   &gt; `\"never\"  ` Never overwrite and throw error when value is invalid\\\r\n   The default value of `overwrite` is `\"never\"`.\r\n\r\nThe default value of `persist` is `false`.\r\n\r\n```svelte\r\n<!-- /+page.svelte -->\r\n<script lang=\"ts\">\r\n  import { writable } from 'better-svelte-writable';\r\n  const count = writable(0, { key: \"count\", persist: true });\r\n</script>\r\n\r\n<!-- Value been sync across tabs -->\r\n<div>Count: {$count}</div>\r\n\r\n<button on:click={() => $count++}>  +  </button>\r\n<button on:click={() => $count=0}>Reset</button>\r\n<button on:click={() => $count--}>  -  </button>\r\n```\r\n",
	"downloads_history": [
		[3589, 1],
		[3596, 93],
		[3603, 26],
		[3610, 2],
		[3617, 240],
		[3624, 24],
		[3631, 4],
		[3638, 5],
		[3645, 8],
		[3652, 24],
		[3659, 6],
		[3666, 29],
		[3673, 4],
		[3680, 1],
		[3687, 2],
		[3694, 1],
		[3715, 4],
		[3722, 15],
		[3729, 5],
		[3736, 1],
		[3743, 14],
		[3750, 13],
		[3757, 1],
		[3764, 3],
		[3771, 19],
		[3778, 17],
		[3785, 2],
		[3792, 6],
		[3799, 2],
		[3806, 6],
		[3813, 3],
		[3820, 2],
		[3834, 21],
		[3841, 94],
		[3848, 2],
		[3855, 3],
		[3862, 4],
		[3869, 3],
		[3876, 14],
		[3883, 4],
		[3890, 25],
		[3897, 52],
		[3904, 1],
		[3911, 1],
		[3918, 2],
		[3925, 8],
		[3932, 14],
		[3939, 1],
		[3946, 3],
		[3953, 1],
		[3967, 2],
		[3974, 23],
		[3995, 1],
		[4002, 1],
		[4009, 1],
		[4016, 2],
		[4023, 3],
		[4030, 8],
		[4037, 31],
		[4044, 19],
		[4051, 17],
		[4058, 6],
		[4065, 9],
		[4072, 5],
		[4079, 6],
		[4086, 2],
		[4093, 27],
		[4100, 67],
		[4107, 6],
		[4114, 16],
		[4121, 18],
		[4128, 17]
	],
	"esm": true,
	"cjs": false
}
