{
	"name": "immer-loves-svelte",
	"description": "Create immutable Svelte stores with Immer.js.",
	"repo_url": "https://github.com/bradphelan/immer.loves.svelte",
	"authors": ["bradphelan"],
	"homepage": "https://github.com/bradphelan/immer.loves.svelte#readme",
	"downloads": 18,
	"updated": "2022-11-14T09:58:56.200Z",
	"tags": ["miscellaneous"],
	"github_stars": 56,
	"typescript": true,
	"version": "2.2.4",
	"svelte_range": "^3.26.0",
	"last_rune_check_version": "2.2.4",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "immer-loves-svelte",
				"version": "2.2.4",
				"size": 137134
			},
			{
				"name": "immer",
				"version": "9.0.21",
				"size": 871966
			},
			{
				"name": "svelte",
				"version": "3.59.2",
				"size": 10624206
			},
			{
				"name": "underscore",
				"version": "1.13.7",
				"size": 906308
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2],
			[0, 3]
		],
		"circular": []
	},
	"readme": "# immer-loves-svelte ( functional lenses over svelte stores )\n\nA library of svelte store wrappers\n\n- **subStore** Create views on to leaf stores using arrow functions to specify the scope. Uses immer js under the hood.\n- **undoStore** Wrap any store with undo redo features\n- **transactionStore** Wrap any store with validation and transactions\n- **sortStore** provides a sorted array of writable stores given a single store input for root\n- **arrayStore** converts a store of a read-only array to a readable store of sub-stores for each element in the array.\n\n[A live example of subStore and undoStore](https://svelte.dev/repl/4434d8fcd12242d79887343fd95e429c?version=3.29.7)\n[ A live example of sorting](https://svelte.dev/repl/54f428bdfc324fe39a67b1345c7bc742?version=3.29.7)\n\n[HomePage](https://bradphelan.github.io/immer.loves.svelte)\n\n# subStore\n\n```js\nchildStore = subStore(mainStore, root => root.a.b.c[\"foo\"].q.r.really.but.it.still.works)\n```\n\nUnder the hood immer and proxy types are used to do the work.\n\nFor example\n\n```js\n\nimport {subStore} from \"immer-loves-svelte\"\n\ntype Foo = {\n  readonly a: number;\n  readonly b: string;\n};\n\ntype Bar = {\n  readonly foo1: Foo;\n  readonly foo2: Foo;\n  readonly foo3: readonly Foo[];\n};\n\nconst bar: Bar = {\n  foo1: { a: 10, b: 'monkey' },\n  foo2: { a: 20, b: 'cat' },\n  foo3: [\n    { a: 10, b: 'monkey' },\n    { a: 20, b: 'cat' },\n  ],\n};\n\n\ntest('creating a subStore through object path works', (t) => {\n\n  let result: Bar = null;\n\n  // create a normal writable store\n  const barStore = writable(bar);\n\n  // create a store referencing a sub tree or sub value using just a selector\n  const s = subStore(barStore, b => b.foo1.a);\n\n  // collect the results using subscribe\n  barStore.subscribe((v: Bar) => {\n    result = v;\n  });\n\n  // Set the value using the subStore setter\n  s.set(77);\n\n  // Check that the result is correct\n  t.deepEqual(result.foo1.a, 77);\n\n\n});\n\n```\n\nOne of the benefits is being able to use `bind:value` with immutable stores. For example if you have a store with type\n\n```js\ntype Data {\n  readonly a:string\n  readonly b:string\n}\n\nlet store:Writable<Data>\n```\n\nnow you can\n\n```html\n<script>\n  let aStore = subStore(store,s=>s.a)\n  let bStore = subStore(store,s=>s.b)\n</script>\n\n<input type=\"text\" bind:Value={$aStore}/>\n<input type=\"text\" bind:Value={$bStore}/>\n```\n\nthe original store is always updated using **immutable** updates.\n\nIdeally you defined a single main store for your entire app and then\ndistribute subStore views to individual components.\n\n# undoStore\n\nWrap any store to provide undo/redo capabilities. Is able to wrap **subStores**.\n\nThe provided interface is\n\n```js\nexport function undoStore<T>(\n  store: Writable<T>,\n): UndoRedoStore<T>;\n\nexport type UndoRedoStore<T> = Writable<T> & {\n  readonly undo: ()=>void\n  readonly redo: ()=>void\n  readonly clear: ()=>void\n  readonly canUndo: Readable<boolean>\n  readonly canRedo: Readable<boolean>\n};\n```\n\n# transactionStore\n\nWrap any store to provide transaction like capabilities with validation. This could be useful when you want to provide updates in a form or dialog with an **ok button**.\n\n```js\nexport function transactionStore<T>(\n  store: Writable<T>,\n  validator:Validator<T> = alwaysValid\n): TransactionStore<T>;\n\nexport type TransactionStore<T> = Writable<T> & {\n  // Commit the transaction. Will only work if the the store is valid\n  readonly commit: ()=>void\n  // Cancel the transaction and revert all changes\n  readonly cancel: ()=>void\n  readonly hasChanges: Readable<boolean>\n  readonly validationError: Readable<ValidationError>\n};\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 60],
		[3596, 198],
		[3603, 124],
		[3610, 131],
		[3617, 130],
		[3624, 228],
		[3631, 109],
		[3638, 116],
		[3645, 123],
		[3652, 210],
		[3659, 55],
		[3666, 77],
		[3673, 287],
		[3680, 67],
		[3687, 37],
		[3694, 90],
		[3701, 166],
		[3708, 54],
		[3715, 196],
		[3722, 214],
		[3729, 131],
		[3736, 41],
		[3743, 115],
		[3750, 76],
		[3757, 289],
		[3764, 107],
		[3771, 97],
		[3778, 19],
		[3785, 64],
		[3792, 71],
		[3799, 92],
		[3806, 103],
		[3813, 57],
		[3820, 27],
		[3827, 73],
		[3834, 85],
		[3841, 66],
		[3848, 87],
		[3855, 139],
		[3862, 40],
		[3869, 56],
		[3876, 97],
		[3883, 5],
		[3890, 120],
		[3897, 15],
		[3904, 87],
		[3911, 64],
		[3918, 41],
		[3925, 71],
		[3932, 2],
		[3939, 88],
		[3946, 4],
		[3953, 36],
		[3960, 23],
		[3967, 37],
		[3974, 20],
		[3981, 19],
		[3988, 5],
		[3995, 44],
		[4002, 1],
		[4009, 8],
		[4016, 11],
		[4023, 43],
		[4030, 5],
		[4037, 38],
		[4044, 109],
		[4051, 126],
		[4058, 40],
		[4065, 87],
		[4072, 36],
		[4079, 1],
		[4086, 37],
		[4100, 55],
		[4107, 6],
		[4114, 18],
		[4121, 14],
		[4128, 14]
	]
}
