{
	"name": "@sheepdog/svelte",
	"description": "Handle async tasks in Svelte applications.",
	"repo_url": "https://github.com/mainmatter/sheepdog",
	"authors": ["pablopang", "marcoow", "mainmatter", "beerinho", "nickschot"],
	"homepage": "https://github.com/mainmatter/sheepdog#readme",
	"downloads": 267,
	"updated": "2025-03-21T22:28:06.239Z",
	"tags": ["miscellaneous"],
	"github_stars": 86,
	"typescript": true,
	"version": "0.12.5",
	"svelte_range": "^4.0.0 || ^5.0.0 || ^5.0.0-next.1",
	"kit_range": "^2.5.8",
	"last_rune_check_version": "0.12.5",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@sheepdog/svelte",
				"version": "0.12.5",
				"size": 77822
			},
			{
				"name": "@sheepdog/core",
				"version": "0.2.1",
				"size": 34257
			},
			{
				"name": "acorn",
				"version": "8.14.1",
				"size": 547473
			},
			{
				"name": "esm-env",
				"version": "1.2.2",
				"size": 3784
			},
			{
				"name": "esrap",
				"version": "1.4.6",
				"size": 50818
			},
			{
				"name": "@jridgewell/sourcemap-codec",
				"version": "1.5.0",
				"size": 112815
			},
			{
				"name": "zimmerframe",
				"version": "1.1.2",
				"size": 12266
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2],
			[1, 3],
			[1, 4],
			[4, 5],
			[1, 6]
		],
		"circular": []
	},
	"readme": "# @sheepdog/svelte\n\nHandle async tasks in your svelte application with ease thanks to `@sheepdog/svelte`.\n\n## What is it?\n\n`@sheepdog/svelte` supplies a simple way to introduce cancellable concurrency into your app. Not only do they provide the cancellability that is missing from normal Promises, `@sheepdog/svelte` also provides a public API that allows you to observe the running state of your task without having to set a single flag manually.\n\nTasks that live on components are automatically cancelled when their context is destroyed, meaning you don't need to worry about the clean up - we've got you covered.\n\nChoose whether you want to keep the oldest, keep the newest or keep all instances of your task to help boost the performance of your app and reduce unnecessary server load.\n\n## How to use `@sheepdog/svelte`\n\nInstall it using your favorite package manager:\n\n```bash\npnpm install @sheepdog/svelte\n```\n\nThen put it to work immediately wherever you want cancellable promises. (Cancellation is only available when using the generator function or async transform, but more on that later).\n\n## Task structure\n\nAll tasks will return a store with the same structure:\n\n- `isRunning`: Boolean - whether the task is currently running or not\n- `last`: TaskInstance | undefined - the last task instance, regardless of whether it errored, was canceled, or was successful\n- `lastCanceled`: TaskInstance | undefined - the last canceled task instance\n- `lastErrored`: TaskInstance | undefined - the last errored task instance\n- `lastRunning`: TaskInstance | undefined - the last running task instance, as soon as the task stops running, this will be undefined\n- `lastSuccessful`: TaskInstance | undefined - the last successful task instance\n- `performCount`: Number - the number of times the task has been run,\n\n## Task Instance\n\nAll TaskInstances will have the same structure:\n\n- `error`: undefined | unknown - if an error is thrown inside the task instance, it will be found here\n- `isCanceled`: boolean - whether the task instance was canceled\n- `isError`: boolean - whether the task instance throw an error before completing\n- `isRunning`: boolean - whether the task instance is currently running\n- `isSuccessful`: boolean - whether the task instance completed successfully\n- `value`: undefined | TReturn - if the task instance completed successfully, this will be the return value\n\n## Task types\n\nThere are several flavours of tasks to choose from (check out the interactive docs here [insert link to site when ready]).\n\nWith all types of task, it is possible to invoke it directly or add the `kind` parameter to the options object.\n\nIf you don't care about mid-call cancellation, then you can utilize the concurrency with any of the following task types.\n\nIf you do care about mid-call cancellation, be sure to check out the [Task Cancellation](#task-cancellation) section.\n\n### Standard/default task\n\nThis simply gives you a task wrapper around your function. It will not handle any kind of concurrency for you.\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(async (param: number) => {\n\t\tawait timeout(2000);\n\t\treturn param * 2;\n\t});\n</script>\n```\n\nOR\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ kind: 'default' },\n\t);\n</script>\n```\n\n### Restartable task\n\nThis will cancel the oldest instance of the task and start a new instance of it. You can also provide a `max` that will only restart the oldest task instance if the threshold is exceeded.\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task.restart(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ max: 3 },\n\t);\n</script>\n```\n\nOR\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ kind: 'restart', max: 3 },\n\t);\n</script>\n```\n\nBoth of the above will result in 3 simultaneous tasks being allowed to run. Triggering the task a fourth time will cancel the oldest task.\n\n### Droppable task\n\nThis will cancel any new instances of the task. You can also provide a `max` that will only drop the task instances if the threshold is exceeded.\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task.drop(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ max: 3 },\n\t);\n</script>\n```\n\nOR\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ kind: 'drop', max: 3 },\n\t);\n</script>\n```\n\nBoth of the above will result in 3 simultaneous tasks being allowed to run. Triggering the task a fourth time will cause it to be cancelled, leaving the initial 3 task instances untouched.\n\n### Enqueue task\n\nThis will add all task instances to a list and each task will be run in order. You can also provide a `max` that will dictate the number of task instances that will run at the same time.\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task.enqueue(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ max: 3 },\n\t);\n</script>\n```\n\nOR\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ kind: 'enqueue', max: 3 },\n\t);\n</script>\n```\n\nBoth of the above will result in 3 simultaneous tasks being allowed to run. Any additional instances of the task will be added to a list and run when there is space in the queue.\n\n### KeepLatest task\n\nThis will run the initial tasks and then ensure that the very last task instance is also run. You can also provide a `max` that will dictate the number of task instances that will run initially. Note: `keepLatest` will only preserve the final _one_ task instance.\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task.keepLatest(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ max: 3 },\n\t);\n</script>\n```\n\nOR\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(\n\t\tasync (param: number) => {\n\t\t\tawait timeout(2000);\n\t\t\treturn param * 2;\n\t\t},\n\t\t{ kind: 'keepLatest', max: 3 },\n\t);\n</script>\n```\n\nBoth of the above will result in 3 simultaneous tasks being allowed to run initially. Triggering the task again will wait for the oldest to complete and then run the latest task instance, preserving the most recent instance.\n\n### Accessing the task in the template\n\nAs the return value from the task wrapper is a store, you can access it just like you would with any other store (check the [Task Instance](#task-instance) section for more detail about what to expect):\n\n```svelte\n<script>\n\timport { task, timeout } from '@sheepdog/svelte';\n\n\tconst myTask = task(async (param: number) => {\n\t\tawait timeout(2000);\n\t\treturn param * 2;\n\t});\n</script>\n\n{$myTask.isRunning}\n{$myTask.last.value}\n{$myTask.performCount}\n```\n\n## Task Cancellation\n\nWith normal Promises, once you have triggered it to run, the only way to interrupt it is to implement your own series of checks at different intervals. With `@sheepdog/svelte` we offer two ways to attain this ability without having to handle it yourself:\n\n### Generator functions\n\n`@sheepdog/svelte` can utilize generator functions to give us fine-grain control of how far through our task will run when cancelled.\n\n```ts\nlet data;\n\nconst instance = task(async function*() {\n\tconst res = async fetch('...');\n\tyield;\n\tdata = await res.json()\n});\n```\n\nUsing a generator function, we can now stop our function as soon as it is cancelled, that means that if we cancelled the task while the `fetch` request was running, the `data` attribute would not be reassigned.\n\n### Async transform (recommended)\n\n`@sheepdog/svelte` also includes a vite plugin that transforms your async functions into generators.\n\nTo set this up, you simply need to important the vite plugin and add it to your `plugins` array:\n\n```diff\n// vite.config.ts\n\nimport { sveltekit } from '@sveltejs/kit/vite';\nimport { coverageConfigDefaults, defineConfig } from 'vitest/config';\n+ import { asyncTransform } from '@sheepdog/svelte/vite';\n\nexport default defineConfig(({ mode }) => ({\n-\tplugins: [sveltekit()],\n+\tplugins: [sveltekit(), asyncTransform()],\n\t...\n\t})\n)\n```\n\nThen you can use standard `async` functions in your `task` definition and under the hood, it will transform your code from this:\n\n```ts\nconst instance = task(async () => {\n\tconst res = await fetch('...');\n});\n```\n\nto this:\n\n```ts\nconst instance = task(async function* () {\n\tconst res = yield fetch('...');\n});\n```\n\nMeaning you get all of the functionality of generators without having to implement them yourself. And have no fear, this will only apply to async functions that you pass as a parameter to the `task` function from `@sheepdog/svelte`. (You can still use standard async promises as you would normally.)\n\n## Task Utilities\n\nAs well as providing your own parameter as the first argument when creating your task function, you also have optional access to another object containing two useful utilities.\n\n`signal` is the `AbortSignal` from the `AbortController`, this can be used to investigate the state of the signal of the current task instance.\n`link` allows you to link the current task to another task, allowing automatic cancellation if the parent task is aborted, or if the child is cancelled, the parent will also be cancelled.\n\n```ts\nconst parent_task = task(async () => {\n\tconst res = await fetch('...');\n\treturn res;\n});\nconst child_task = task(async ({ my_param1, my_param2 }, { signal, link }) => {\n\tconst res = await link(parent_task).perform();\n\tif (signal.aborted) {\n\t\tconsole.log(\"I've been cancelled 😭\");\n\t}\n});\n```\n\n## Utility functions\n\n### didCancel\n\nWhen a task is canceled, it will throw a `CancelationError` when it aborts the current controller. Though this can be useful, it's not something we ever want to show to the end user.\n\nFor this reason we expose `didCancel` which allows us to distinguish an actual error from one thrown internally by `sheepdog`.\n\n```ts\nimport { didCancel } from '@sheepdog/svelte';\n\nconst parent_task = task(async () => {\n\tconst res = await fetch('...');\n\treturn res;\n});\n\nparent_task.perform().catch((e) => {\n\t// return early if it's sheepdog cancelation error\n\tif (didCancel(e)) return;\n\t// do something with the actual error from our task\n});\n```\n\nIn this example, our `fetch` call might throw an error or our task might be canceled. With `didCancel` we can check the error and ignore any cancelation errors, while doing something meaningful with any real errors that come from our task.\n\n### timeout\n\nThe `timeout` function provides a convenient way to wait for a certain amount of milliseconds. Its implementation comes down to a promisified `setTimeout` call.\n\n```ts\nimport { task, timeout } from '@sheepdog/svelte';\n\nconst myTask = task(async () => {\n\tawait timeout(500);\n\tconst res = await fetch('...');\n\treturn res;\n});\n```\n\n## Contributing\n\n### How to write async transform tests?\n\nIf you want to write a new test for the async transformation you just need to create a `code.js` file in a new folder in `./src/lib/tests/expected-transforms`. Try to give the folder a descriptive name and the run `pnpm generate-expected`. This will create a series of `transform.js` files in the various folder which will later be used to test the transform. If you are modifying the transform make sure to run the tests before running the `generate-expected` script!\n\nP.s. If, after you run the script, you'll see a folder with `code.js` and no `transform.js` this means that in that case the transform will not apply.\n\n## License\n\n`@sheepdog/svelte` is developed by and &copy;\n[Mainmatter GmbH](http://mainmatter.com) and contributors. It is\nreleased under the [MIT License](LICENSE).\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3813, 17],
		[3820, 242],
		[3827, 137],
		[3834, 106],
		[3841, 126],
		[3848, 262],
		[3855, 134],
		[3862, 78],
		[3869, 283],
		[3876, 192],
		[3883, 176],
		[3890, 294],
		[3897, 16],
		[3904, 56],
		[3911, 14],
		[3918, 124],
		[3925, 147],
		[3932, 338],
		[3939, 252],
		[3946, 6],
		[3953, 37],
		[3960, 105],
		[3967, 49],
		[3974, 33],
		[3981, 120],
		[3988, 149],
		[3995, 171],
		[4002, 27],
		[4009, 51],
		[4016, 36],
		[4023, 66],
		[4030, 87],
		[4037, 115],
		[4044, 249],
		[4051, 323],
		[4058, 258],
		[4065, 308],
		[4072, 292],
		[4079, 130],
		[4086, 109],
		[4093, 381],
		[4100, 269],
		[4107, 55],
		[4114, 267],
		[4121, 56],
		[4128, 119]
	],
	"esm": true,
	"cjs": false
}
