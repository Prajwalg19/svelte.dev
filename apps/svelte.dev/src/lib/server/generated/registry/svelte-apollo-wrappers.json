{
	"name": "svelte-apollo-wrappers",
	"description": "Wrap ApolloClient methods for Svelte applications.",
	"repo_url": "",
	"authors": ["mashiachy"],
	"homepage": "https://github.com/mashiachy/svelte-apollo-wrappers",
	"downloads": 4,
	"updated": "2022-12-05T21:34:20.894Z",
	"tags": ["integration"],
	"typescript": true,
	"version": "1.0.1",
	"svelte_range": "^3.53.1",
	"last_rune_check_version": "1.0.1",
	"github_stars": 0,
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-apollo-wrappers",
				"version": "1.0.1",
				"size": 49866
			},
			{
				"name": "graphql-combine-query",
				"version": "1.2.4",
				"size": 31764
			},
			{
				"name": "lodash-es",
				"version": "4.17.21",
				"size": 636080
			},
			{
				"name": "zen-observable-ts",
				"version": "1.1.0",
				"size": 20890
			},
			{
				"name": "@types/zen-observable",
				"version": "0.8.3",
				"size": 10121
			},
			{
				"name": "zen-observable",
				"version": "0.8.15",
				"size": 72504
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2],
			[0, 3],
			[3, 4],
			[3, 5]
		],
		"circular": []
	},
	"readme": "# svelte-apollo-wrappers\n\nDocumentation based on <a href=\"https://github.com/timhall/svelte-apollo\">svelte-apollo</a> library.\nSvelte integration for Apollo GraphQL without Svelte context usage. Support multiple GraphQL docuemnts as arguments.\n\n## Example\n\nThe following simple example shows how to run a simple query with svelte-apollo.\n\n```typescript\n/* main.ts */\nimport { ApolloClient } from \"@apollo/client/core\";\nimport { setClient } from \"svelte-apollo-wrappers\";\n\n// 1. Create an Apollo client and pass it to all child components\n//    (uses svelte's built-in context)\nconst client = new ApolloClient({\n  /* ... */\n});\nsetClient(client);\n```\n\n```svelte\n<!-- Books.svelte -->\n<script>\n  import { query } from \"svelte-apollo-wrappers\";\n  import GET_BOOKS from \"./GET_BOOKS.graphql\";\n\n  // 2. Execute the GET_BOOKS GraphQL query using the Apollo client\n  //    -> Returns a svelte store of promises that resolve as values come in\n  const books = query(GET_BOOKS);\n  \n  // 3. Refetch query each 15 seconds\n  //    books.query is original result from apolloClient.watchQuery call\n  setInterval(() => books.query.refetch(), 15000);\n</script>\n\n<!-- 3. Use $books (note the \"$\"), to subscribe to query values -->\n{#if $books.loading}\n  Loading...\n{:else if $books.error}\n  Error: {$books.error.message}\n{:else}\n  {#each $books.data.books as book}\n    {book.title} by {book.author.name}\n  {/each}\n{/if}\n```\n\n## API\n\n<a href=\"#query\" name=\"query\">#</a> <b>query</b>(<i>document</i>[, <i>options</i>])\n\nQuery an Apollo client, returning a readable store of result values.\nUses Apollo's [`watchQuery`](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.watchQuery),\nfor fetching from the network and watching the local cache for changes.\n\n```svelte\n<script>\n  import { query } from \"svelte-apollo-wrappers\";\n  import GET_BOOKS from \"./GET_BOOKS.graphql\";\n\n  const books = query(GET_BOOKS, {\n    // variables, fetchPolicy, errorPolicy, and others\n  });\n\n  function reload() {\n    books.query.refetch();\n  }\n</script>\n\n<ul>\n  {#if $books.loading}\n    <li>Loading...</li>\n  {:else if $books.error}\n    <li>ERROR: {$books.error.message}</li>\n  {:else}\n    {#each $books.data.books as book (book.id)}\n      <li>{book.title} by {book.author.name}</li>\n    {/each}\n  {/if}\n</ul>\n\n<button on:click=\"{reload}\">Reload</button>\n```\n\nReactive variables are supported with `refetch`:\n\n```svelte\n<script>\n  import { query } from \"svelte-apollo-wrappers\";\n  import { SEARCH_BY_AUTHOR } from \"./queries\";\n\n  export let author;\n  let search = \"\";\n\n  const books = query(SEARCH_BY_AUTHOR, {\n    variables: { author, search },\n  });\n\n  // `books` is refetched when author or search change\n  $: books.query.refetch({ author, search });\n</script>\n\nAuthor: {author}\n<label>Search <input type=\"text\" bind:value=\"{search}\" /></label>\n\n<ul>\n  {#if $books.loading}\n    <li>Loading...</li>\n  {:else if $books.error}\n    <li>ERROR: {$books.error.message}</li>\n  {:else if $books.data}\n    {#each $books.data.books as book (book.id)}\n      <li>{book.title}</li>\n    {/each}\n  {:else}\n    <li>No books found</li>\n  {/if}\n</ul>\n```\n\n<a href=\"#mutation\" name=\"mutation\">#</a> <b>mutation</b>(<i>document</i>[, <i>options</i>])\n\nPrepare a GraphQL mutation with the Apollo client, using Apollo's [`mutate`](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.mutate).\n`mutation()` call returns async function to execute mutation; Returned function has subscribe method, so you can use it as svelte store ({ data, loading, error }).\nYou can set mutation options as second argument of `mutation()` call, them will use as default in all executions of resulted mutation function. You can specify them for every call as first argument.\n\n\n```svelte\n<script>\n  import { mutation } from \"svelte-apollo-wrappers\";\n  import ADD_BOOK from \"./ADD_BOOK.graphql\";\n\n  const addBook = mutation(ADD_BOOK);\n  let title = \"\";\n  let author = \"\";\n\n  $: ({ data, error, loading } = $addBook);\n\n  async function handleSubmit() {\n    try {\n      await addBook({ variables: { title, author } });\n    } catch (error) {\n      // TODO\n    }\n  }\n</script>\n\n<form on:submit|preventDefault=\"{handleSubmit}\">\n  <label for=\"book-author\">Author</label>\n  <input type=\"text\" id=\"book-author\" bind:value=\"{author}\" />\n\n  <label for=\"book-title\">Title</label>\n  <input type=\"text\" id=\"book-title\" bind:value=\"{title}\" />\n\n  <button type=\"submit\" loading=\"{loading}\">Add Book</button>\n</form>\n{#if data}\nDone!\n{:else if error}\nError!\n{/if}\n```\n\n<a href=\"#lazyQuery\" name=\"lazyQuery\">#</a> <b>lazyQuery</b>(<i>document</i>[, <i>options</i>])\n\nPrepare a GraphQL lazyQuery with the Apollo client, using Apollo's [`query`](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.query).\n`lazyQuery()` call returns async function to execute query; Returned function has subscribe method, so you can use it as svelte store ({ data, loading, error }).\nYou can set query options as second argument of `lazyQuery()` call, them will use as default in all executions of resulted query function. You can specify them for every call as first argument.\n\n\n```svelte\n<script>\n  import { lazyQuery } from \"svelte-apollo-wrappers\";\n  import GET_BOOK from \"./GET_BOOK.graphql\";\n\n  const getBook = lazyQuery(GET_BOOK);\n  let title = \"\";\n  let author = \"\";\n\n  $: ({ data, error, loading } = $getBook);\n</script>\n\n<button on:click=\"{getBook}\">Fetch book</button>\n{#if data}\n  Fetched: {data}\n{:else if error}\n  Error: {error}\n{:else if loading}\n  Loading\n{/if}\n```\n\n<a href=\"#subscribe\" name=\"subscribe\">#</a> <b>subscribe</b>(<i>document</i>[, <i>options</i>])\n\nSubscribe using an Apollo client, returning a store that is compatible with `{#await $...}`. Uses Apollo's [`subscribe`](https://www.apollographql.com/docs/react/api/apollo-client#ApolloClient.subscribe).\n\n```svelte\n<script>\n  import { subscribe } from \"svelte-apollo-wrappers\";\n  import NEW_BOOKS from \"./NEW_BOOKS.graphql\";\n\n  const newBooks = subscribe(NEW_BOOKS);\n</script>\n\n{#if $newBooks.loading}\n  Waiting for new books...\n{:else if $newBooks.data}\n  New Book: {$newBooks.data.book}\n{/if}\n```\n\n<a href=\"#setClient\" name=\"setClient\">#</a> <b>setClient</b>(<i>client</i>)\n\nSet an Apollo client for all wrappers.\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import { setClient } from \"svelte-apollo-wrappers\";\n  import client from \"./client\";\n\n  setClient(client);\n</script>\n```\n\n<a href=\"#getClient\" name=\"getClient\">#</a> <b>getClient</b>()\n\nGet an Apollo client.\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  import { getClient } from \"svelte-apollo-wrappers\";\n\n  const client = getClient();\n</script>\n```\n\n## FEATURES\n\n<a href=\"#arrayedDocuments\" name=\"arrayedDocuments\">#</a> <b>arrayed documents</b>\n\nYou can use array of graphql documents as document argument for every wrappers. List of docuemnts will be merged in one document. Make sure that you dont have operations with the same name in different docuemnts. All wrappers options includes possible option `operationName` which will be usaed as a name for resulted document.\n\n```typescript\nimport QUERY_ONE from \"./QUERY_ONE.graphql\";\nimport QUERY_TWO from \"./QUERY_TWO.graphql\";\nimport { query } from \"svelte-apollo-wrappers\";\n\nconst queryStore = query([QUERY_ONE, QUERY_TWO]);\n```\n\n<a href=\"#typescript\" name=\"typescript\">#</a> <b>Typescript</b>\n\nAll wrappers are \"typescripted\". Usage the same as in `ApolloClient.[\"watchQuery\" / \"query\" / ...]`.\nSupporting of TypedDocuemnts. If you are using graphql-codegen for generate types for GraphQL files the library will use this types.\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3596, 6],
		[3603, 5],
		[3610, 4],
		[3617, 1],
		[3631, 1],
		[3652, 1],
		[3659, 1],
		[3666, 3],
		[3673, 1],
		[3680, 1],
		[3708, 2],
		[3722, 1],
		[3729, 3],
		[3750, 1],
		[3757, 3],
		[3771, 2],
		[3778, 1],
		[3785, 1],
		[3792, 1],
		[3799, 2],
		[3806, 5],
		[3820, 1],
		[3827, 1],
		[3834, 2],
		[3841, 12],
		[3848, 2],
		[3855, 2],
		[3862, 1],
		[3869, 2],
		[3876, 1],
		[3883, 2],
		[3890, 4],
		[3897, 1],
		[3904, 3],
		[3911, 3],
		[3932, 1],
		[3946, 1],
		[3960, 1],
		[3967, 3],
		[3981, 1],
		[3988, 1],
		[3995, 1],
		[4023, 3],
		[4030, 1],
		[4037, 6],
		[4044, 9],
		[4051, 2],
		[4058, 1],
		[4065, 2],
		[4072, 1],
		[4079, 3],
		[4086, 1],
		[4093, 1],
		[4100, 9],
		[4107, 3],
		[4114, 4],
		[4121, 9],
		[4128, 2]
	],
	"esm": true,
	"cjs": true
}
