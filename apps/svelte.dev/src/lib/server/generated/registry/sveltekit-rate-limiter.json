{
	"name": "sveltekit-rate-limiter",
	"description": "Modular rate limiter for SvelteKit, use in password resets.",
	"repo_url": "https://github.com/ciscoheat/sveltekit-rate-limiter",
	"authors": ["ciscoheat"],
	"homepage": "https://github.com/ciscoheat/sveltekit-rate-limiter#readme",
	"downloads": 2973,
	"updated": "2024-09-19T14:55:23.003Z",
	"tags": ["server"],
	"github_stars": 256,
	"typescript": true,
	"version": "0.6.1",
	"svelte_range": "^4.2.12",
	"kit_range": "1.x || 2.x",
	"last_rune_check_version": "0.6.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "sveltekit-rate-limiter",
				"version": "0.6.1",
				"size": 32335
			},
			{
				"name": "@isaacs/ttlcache",
				"version": "1.4.1",
				"size": 25201
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "# sveltekit-rate-limiter\n\nA modular rate limiter for password resets, account registration, API call limiting, etc. Use in your `+page.server.ts`, `+server.ts` or `src/hooks.server.ts`.\n\nUses an in-memory cache ([@isaacs/ttlcache](https://www.npmjs.com/package/@isaacs/ttlcache)), but can be swapped for something else. Same for limiters, which are plugins. The [source file](https://github.com/ciscoheat/sveltekit-rate-limiter/blob/main/src/lib/server/index.ts#L24-L32) lists both interfaces.\n\n## Installation\n\n```\nnpm i -D sveltekit-rate-limiter\n```\n\n```\npnpm i -D sveltekit-rate-limiter\n```\n\n## How to use\n\n```ts\nimport { error } from '@sveltejs/kit';\nimport { RateLimiter } from 'sveltekit-rate-limiter/server';\n\nconst limiter = new RateLimiter({\n  // A rate is defined as [number, unit]\n  IP: [10, 'h'], // IP address limiter\n  IPUA: [5, 'm'], // IP + User Agent limiter\n  cookie: {\n    // Cookie limiter\n    name: 'limiterid', // Unique cookie name for this limiter\n    secret: 'SECRETKEY-SERVER-ONLY', // Use $env/static/private\n    rate: [2, 'm'],\n    preflight: true // Require preflight call (see load function)\n  }\n});\n\nexport const load = async (event) => {\n  /**\n   * Preflight prevents direct posting. If preflight option for the\n   * cookie limiter is true and this function isn't called before posting,\n   * request will be limited.\n   *\n   * Remember to await, so the cookie will be set before returning!\n   */\n  await limiter.cookieLimiter?.preflight(event);\n};\n\nexport const actions = {\n  default: async (event) => {\n    // Every call to isLimited counts as a hit towards the rate limit for the event.\n    if (await limiter.isLimited(event)) throw error(429);\n  }\n};\n```\n\n## Call order for limiters\n\nThe limiters will be called in smallest unit and rate order, so in the example above:\n\n```\ncookie(2/min) → IPUA(5/min) → IP(10/hour)\n```\n\nFor four consecutive requests from the same source within one minute, the following will happen:\n\n| Request | Cookie    | IPUA  | IP    |\n| ------- | --------- | ----- | ----- |\n| 1       | Hit 1     | Hit 1 | Hit 1 |\n| 2       | Hit 2     | Hit 2 | Hit 2 |\n| 3       | **Limit** | -     | -     |\n| 4       | **Limit** | -     | -     |\n\nIf the cookie is deleted but the User-Agent stays the same, the counter keeps going for the other limiters:\n\n| Request | Cookie    | IPUA  | IP    |\n| ------- | --------- | ----- | ----- |\n| 5       | Hit 1     | Hit 3 | Hit 3 |\n| 6       | Hit 2     | Hit 4 | Hit 4 |\n| 7       | **Limit** | -     | -     |\n\nIf deleted one more time, the User-Agent limiter will reach its limit:\n\n| Request | Cookie    | IPUA      | IP    |\n| ------- | --------- | --------- | ----- |\n| 8       | Hit 1     | Hit 5     | Hit 5 |\n| 9       | Hit 2     | **Limit** | -     |\n| 10      | **Limit** | -         | -     |\n\n## Valid units\n\nValid units are, from smallest to largest:\n\n```\n'100ms' | '250ms' | '500ms'\n's' | '2s' | '5s' | '10s' | '15s' | '30s' | '45s'\n'm' | '2m' | '5m  | '10m' | '15m' | '30m' | '45m'\n'h' | '2h' | '6h' | '12h'\n'd'\n```\n\n## Multiple limits\n\nYou can specify the rates as an array, to handle multiple rates per limiter, like \"Max 1 per second and 100 per hour\": `[[1, 's'], [100, 'h']]`.\n\n## Retry-After limiter\n\nThere is a version of the rate limiter that will return [Retry-After](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) information, the number of seconds before the request should be attempted again. This has been implemented in the `src/hooks.server.ts` file and instead of throwing an error code like other pages, we have to create a new response so that we can add the header.\n\n```ts\nimport type { Handle } from '@sveltejs/kit';\nimport { RetryAfterRateLimiter } from 'sveltekit-rate-limiter/server';\n\nconst limiter = new RetryAfterRateLimiter({\n  IP: [10, 'h'],\n  IPUA: [5, 'm']\n});\n\nexport const handle: Handle = async ({ event, resolve }) => {\n  const status = await limiter.check(event);\n  if (status.limited) {\n    let response = new Response(\n      `You are being rate limited. Please try after ${status.retryAfter} seconds.`,\n      {\n        status: 429,\n        headers: { 'Retry-After': status.retryAfter.toString() }\n      }\n    );\n    return response;\n  }\n  const response = await resolve(event);\n  return response;\n};\n```\n\nA custom store for the `RetryAfterRateLimiter` can also be used, in which the second argument to the constructor should be a [RateLimiterStore](https://github.com/ciscoheat/sveltekit-rate-limiter/blob/main/src/lib/server/index.ts#L24) that returns a unix timestamp describing when the request should be reattempted, based on the unit sent to it.\n\n## Clearing the limits\n\nClearing all rate limits can be done by calling the `clear` method of the rate limiter object.\n\n## Custom hash function\n\nThe default hash function is using `crypto.subtle` to generate a SHA-256 digest, but if isn't available in your environment, you can supply your own with the `hashFunction` option. Here's an example with the NodeJS `crypto` package:\n\n```ts\nimport crypto from 'crypto';\n\n// (input: string) => MaybePromise<string>\nconst hashFunction = (input: string) =>\n  crypto.createHash('sha256').update(input).digest('hex');\n```\n\n## Creating a custom limiter\n\nImplement the `RateLimiterPlugin` interface:\n\n```ts\ninterface RateLimiterPlugin {\n  hash: (event: RequestEvent) => MaybePromise<string | boolean | null>;\n  get rate(): Rate | Rate[];\n}\n```\n\nIn `hash`, return one of the following:\n\n- A `string` based on a [RequestEvent](https://kit.svelte.dev/docs/types#public-types-requestevent), which will be counted and checked against the rate.\n- A `boolean`, to short-circuit the plugin chain and make the request fail (`false`) or succeed (`true`) no matter the current rate.\n- Or `null`, to signify an indeterminate result and move to the next plugin in the chain, or fail the request if it's the last and no previous limiter have passed.\n\n### String hash rules\n\n- **The string will be hashed later**, so you don't need to use a hash function.\n- **The string cannot be empty**, in which case an exception will be thrown.\n\n### Example\n\nHere's the source for the IP + User Agent limiter:\n\n```ts\nimport type { RequestEvent } from '@sveltejs/kit';\nimport type { Rate, RateLimiterPlugin } from 'sveltekit-rate-limiter/server';\n\nclass IPUserAgentRateLimiter implements RateLimiterPlugin {\n  readonly rate: Rate | Rate[];\n\n  constructor(rate: Rate | Rate[]) {\n    this.rate = rate;\n  }\n\n  async hash(event: RequestEvent) {\n    const ua = event.request.headers.get('user-agent');\n    if (!ua) return false;\n    return event.getClientAddress() + ua;\n  }\n}\n```\n\nAdd your limiter to the `plugins` option to use it.\n\n```ts\nimport { RateLimiter } from 'sveltekit-rate-limiter/server';\n\nconst limiter = new RateLimiter({\n  plugins: [new CustomLimiter([5, 'm'])]\n  // The built-in limiters can be added as well.\n});\n```\n\n## Custom data for the limiter\n\nYou can specify a type parameter to `RateLimiter` that expands the `isLimited` method with an extra parameter. There you can add extra data that will be supplied to the custom limiters:\n\n```ts\nclass AllowDomain implements RateLimiterPlugin {\n  // Shortest rate, so it will be executed first\n  readonly rate: Rate = [0, '100ms'];\n  readonly allowedDomain: string;\n\n  constructor(allowedDomain: string) {\n    this.allowedDomain = allowedDomain;\n  }\n\n  async hash(_: RequestEvent, extraData: { email: string }) {\n    // Return true to bypass the rest of the plugin chain\n    return extraData.email.endsWith(this.allowedDomain) ? true : null;\n  }\n}\n```\n\n```ts\nconst limiter = new RateLimiter<{ email: string }>({\n  plugins: [new AllowDomain('company-domain.com')],\n  IP: [10, 'm']\n});\n\nexport const actions = {\n  default: async (event) => {\n    if (await limiter.isLimited(event, { email: event.locals.user.email })) {\n      throw error(429);\n    }\n  }\n};\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3596, 193],
		[3603, 201],
		[3610, 206],
		[3617, 87],
		[3624, 167],
		[3631, 287],
		[3638, 370],
		[3645, 199],
		[3652, 329],
		[3659, 400],
		[3666, 765],
		[3673, 553],
		[3680, 619],
		[3687, 662],
		[3694, 1086],
		[3701, 794],
		[3708, 1147],
		[3715, 1406],
		[3722, 1308],
		[3729, 1302],
		[3736, 1153],
		[3743, 1307],
		[3750, 994],
		[3757, 1070],
		[3764, 1186],
		[3771, 796],
		[3778, 1132],
		[3785, 1471],
		[3792, 1160],
		[3799, 1184],
		[3806, 1591],
		[3813, 1959],
		[3820, 1619],
		[3827, 1429],
		[3834, 1957],
		[3841, 1923],
		[3848, 1605],
		[3855, 1349],
		[3862, 1238],
		[3869, 1601],
		[3876, 1729],
		[3883, 1792],
		[3890, 2028],
		[3897, 2054],
		[3904, 2420],
		[3911, 2234],
		[3918, 2351],
		[3925, 2753],
		[3932, 1911],
		[3939, 2320],
		[3946, 2078],
		[3953, 1573],
		[3960, 1776],
		[3967, 2132],
		[3974, 2793],
		[3981, 2569],
		[3988, 2832],
		[3995, 1965],
		[4002, 3070],
		[4009, 1805],
		[4016, 1333],
		[4023, 2189],
		[4030, 2514],
		[4037, 2811],
		[4044, 2407],
		[4051, 2490],
		[4058, 1956],
		[4065, 2527],
		[4072, 3908],
		[4079, 2531],
		[4086, 2971],
		[4093, 2860],
		[4100, 3324],
		[4107, 2136],
		[4114, 2973],
		[4121, 3400],
		[4128, 2423],
		[4135, 1810]
	]
}
