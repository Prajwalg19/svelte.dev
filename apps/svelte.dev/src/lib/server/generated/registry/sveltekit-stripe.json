{
	"name": "sveltekit-stripe",
	"description": "Integrate Stripe Elements into SvelteKit applications.",
	"repo_url": "https://github.com/pevey/sveltekit-stripe",
	"authors": ["pevey"],
	"homepage": "https://pevey.com/sveltekit-stripe",
	"downloads": 216,
	"updated": "2024-03-30T13:22:57.386Z",
	"tags": ["integration"],
	"github_stars": 12,
	"typescript": true,
	"version": "3.1.3",
	"svelte_range": "^4.0.0",
	"kit_range": "^2.5.2",
	"last_rune_check_version": "3.1.3",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "sveltekit-stripe",
				"version": "3.1.3",
				"size": 24197
			},
			{
				"name": "@stripe/stripe-js",
				"version": "3.5.0",
				"size": 885729
			},
			{
				"name": "@sveltejs/vite-plugin-svelte",
				"version": "3.1.2",
				"size": 126232
			},
			{
				"name": "debug",
				"version": "4.4.0",
				"size": 42798
			},
			{
				"name": "ms",
				"version": "2.1.3",
				"size": 6721
			},
			{
				"name": "kleur",
				"version": "4.1.5",
				"size": 20250
			},
			{
				"name": "vitefu",
				"version": "0.2.5",
				"size": 19174
			},
			{
				"name": "deepmerge",
				"version": "4.3.1",
				"size": 31157
			},
			{
				"name": "svelte-hmr",
				"version": "0.16.0",
				"size": 75417
			},
			{
				"name": "magic-string",
				"version": "0.30.17",
				"size": 467464
			},
			{
				"name": "@jridgewell/sourcemap-codec",
				"version": "1.5.0",
				"size": 112815
			},
			{
				"name": "@sveltejs/vite-plugin-svelte-inspector",
				"version": "2.1.0",
				"size": 25824
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2],
			[2, 3],
			[3, 4],
			[2, 5],
			[2, 6],
			[2, 7],
			[2, 8],
			[2, 9],
			[9, 10],
			[2, 11],
			[11, 3]
		],
		"circular": []
	},
	"readme": "# sveltekit-stripe\n\nThis package is a barebones SvelteKit implementation for concisely rendering Stripe Elements. It gets the job done in most cases with as little complexity as possible.\n\n[Documentation](https://pevey.com/sveltekit-stripe)\n\n## Features\n\n- [Payment Element](https://stripe.com/docs/payments/payment-element)\n- [Address Element](https://stripe.com/docs/elements/address-element)\n\n## Setup\n\nCreate a SvelteKit project and install the package:\n\n```bash\nnpm create svelte@latest my-app\ncd my-app\nnpm install -D sveltekit-stripe\n```\n\nAdd your Stripe public key to your environment variables:\n\n`.env`\n\n```bash\nPUBLIC_STRIPE_KEY=pk_test_1234567890...\n```\n\n## Usage\n\nAfter integrating Stripe with SvelteKit for the umpteenth time, I created this to significantly reduce the boilerplate I was writing over and over again.\n\nA functioning Stripe integration can be achieved with very little code.\n\nThe options objects for the Svelte components are properly typed using the underlying Stripe library types to provide type hints for syntax.  If you define your options outside of the component, you can import the Stripe types from this library instead of the underlying Stripe package.\n\n### Example: Self-Hosted Checkout Using `use:enhance`\n\nIn the example below, we assume we've already obtained a clientSecret.  In many cases, your existing ecommerce backend (such as [Vendure](https://vendure.io)) or [Medusa](https://medusajs.com)) will handle generating payment intents and/or setup intents.  Client secrets come from these intents.  See a section further down for more information about generating client secrets if you need to generate them yourself.\n\nNOTE: For payment setup rather than checkout, replace the line\n\n`const stripeResponse = await $stripeClient.confirmPayment({ elements: $stripeElements, redirect: 'if_required' })`\n\nwith\n\n`const stripeResponse = await $stripeClient.confirmSetup({ elements: $stripeElements, redirect: 'if_required' })`\n\nThe address element and payment element are Stripe-hosted forms, so any content entered will not be submitted to our server with the form.  The payment and address element allow you to embed the forms on your own page, but all the processing still happens on Stripe servers.  We can use SvelteKit's built-in `enhance` action on the form to have control what happens when a user submits the form.  See the SvelteKit documentation on Form Actions for more detailed explanation of Form Actions and `use:enhance`.\n\nThe return_url below will be called after Stripe has processed the payment.  The call to the return_url will include a payload from Stripe about the status of the payment.\n\n`+page.svelte`\n\n```svelte\n<script>\n\timport { Elements, PaymentElement, type StripePaymentElementOptions } from 'sveltekit-stripe'\n\timport { PUBLIC_STRIPE_KEY } from '$env/static/public'\n\timport { enhance } from '$app/forms'\n\tlet clientSecret = 'pi_1234567890...' // from your server, see README\n\tlet success = false\n\n\tconst elementsOptions: StripePaymentElementOptions = {\n\t\tappearance: { \n\t\t\ttheme: 'stripe',\n\t\t},\n\t\tmode: 'payment',\n\t\tcurrency: 'usd',\n\t\tamount: 1000\n\t}\n</script>\n\n<Elements publicKey={PUBLIC_STRIPE_KEY} let:stripe let:elements {elementsOptions}>\n\t<form method=\"POST\" use:enhance={ async ({ cancel }) => {\n\t\tlet stripeResponse = await elements?.submit()\n\t\t// console.log(stripeResponse)\n\t\tif (stripeResponse && !stripeResponse.error) {\n\t\t\tlet stripeResponse = await stripe.confirmPayment({ \n\t\t\t\telements,\n\t\t\t\tclientSecret,\n\t\t\t\tconfirmParams: { return_url: `https://example.com/order/success/${exampleOrderCode}` }\n\t\t\t})\n\t\t\t// console.log(stripeResponse)\n\t\t\tif (stripeResponse.error) { \n\t\t\t\tconsole.log(stripeResponse.error)\n\t\t\t\tcancel()\n\t\t\t} \n\t\t}\n\t\treturn async ({ result }) => {\n\t\t\t// If we get here instead of being redirected to the url set above,\n\t\t\t// we know that something went wrong.\n\t\t\terrorMessage = stripeResponse?.error?.message\n\t\t\tprocessing = false\n\t\t}\n\t}}>\n\t\t<PaymentElement />\n\t\t<button type=\"submit\">Place Your Order</button>\n\t</form>\n</Elements>\n```\n\n### Example: Self-Hosted Checkout Using the Address Element\n\nOne way to use the Address component is to bind the container.  Once we have a binding, we can use the Stripe-provided function getValue():\n\n`+page.svelte`\n```svelte\n<script>\n\timport { Elements, PaymentElement, AddressElement } from 'sveltekit-stripe'\n\timport { PUBLIC_STRIPE_KEY } from '$env/static/public'\n\timport { enhance } from '$app/forms'\n\tlet clientSecret = 'pi_1234567890...' // from your server, see README\n\tlet addressContainer\n</script>\n\n<Elements publicKey={PUBLIC_STRIPE_KEY} let:stripe let:elements {elementsOptions}>\n\t<form method=\"POST\" use:enhance={ async ({ cancel }) => {\n\t\tconst {complete, value} = await addressContainer.getValue()\n\t\tif (complete) {\n\t\t\t// save the address somewhere\n\t\t\tconsole.log(value)\n\t\t} //else {\n\t\t\t// You can choose to handle the error yourself (e.g., show an error message)\n\t\t\t// Or you can just continue the submission and Stripe will handle the error\n\t\t//}\n\t\t\n\t\t// ...submit to Stripe as in example above\n\t}}>\n\t\t<AddressElement {addressElementOptions} bind:addressContainer />\n\t\t<PaymentElement />\n\t\t<button type=\"submit\">Place Your Order</button>\n\t</form>\n</Elements>\n```\n\n### Example: Using the Custom on:complete Event with the Address Element\n\nOne downside of the above is that it only gets the value when the entire form is submitted.  This may not be suitable for some checkout flows.  The Stripe-provided on:change event can be used to dispatch an event upon any change in the input, but this is not usually what we want.  You still have to check each time to see if the form element is complete.  For convenience, this package provides a custom event named \"complete\" that will trigger with any change that consitutes a full, valid address.\n\n```svelte\n<Address on:complete={async (e) => {\n\t\tconsole.log(e.detail)\n\t\t// we have an address we can do something with\n\t\t// for instance, get shipping/payment options\n\t}}\n/>\n```\n\n## Obtaining a Client Secret\n\nEach time a user begins checkout, a payment intent needs to be generated. The payment intent contains a client secret that must be passed to the client.  A valid client secret must be passed to the Address and Payment components, or they will not render.\n\nIn many use cases, another system, such as an ecommerce backend, already has a method of generating and providing client secrets for checkout.  Please see the relevant documentation for your backend.\n\n### Passing from Server to Client in a Load Function \n\nOne way to pass a client secret to the client in SvelteKit is via the load function.  The client secret can be passed to the client as a prop, which is then passed to the Address and Payment components.\n\n`+page.server.js`\n\n```js\nexport const load = async () => {\n\tconst clientSecret = await generateClientSecret() // example function \n\treturn {\n\t\tclientSecret\n\t}\n}\n```\n\nPlease note that `generateClientSecret()` is not a real function.  It is a placeholder for however you generate a client secret using your ecommerce backend.\n\n`+page.svelte`\n\n```svelte\n<script>\n\t...\n\texport let data\n\tlet clientSecret = data?.clientSecret\n\t...\n</script>\n```\n\n### Passing from Server to Client in an Endpoint\n\nAnother way to obtain a client secret is to use an endpoint.  A simplified example:\n\n`+server.js`\n\n```js\nimport { json } from '@sveltejs/kit'\n\nexport async function POST({ request }) {\n\tconst data = await request.json()\n\t// some sort of validation on data\n\tconst clientSecret = await generateClientSecret() // example function \n\treturn json({clientSecret})\n}\n```\n\nNOTE: In practice, you would want to use recaptcha or turnstile on this endpoint.  See example in a section below.\n\nYou can load the clientSecret from the server endpoint when the page loads like this:\n\n`+page.svelte`\n```js\n{#if !clientSecret}\n\tlet clientSecret = await fetch('/api/stripe', { \n\t\tmethod: 'POST',\n\t\theaders: {'Content-Type': 'application/json'},\n\t\tbody: JSON.stringify({some:data}) \n\t}).then(res => res.json())\n{:else}\n// rest of page\n```\n\nOr, you can take advantage of the relatively new ability in Stripe to produce Payment element without yet having a clientSecret, and then generate the client secret when the payment is submitted.  This approach of creating the intent/clientSecret at the last moment is useful if the final price might change due to shipping ot other charges, and avoids the need to use the stripe client to manually update the payment intent after it was initially created.\n\n`+page.svelte`\n```svelte\n<script>\n\timport { Elements, PaymentElement, AddressElement } from 'sveltekit-stripe'\n\timport { PUBLIC_STRIPE_KEY } from '$env/static/public'\n\timport { enhance } from '$app/forms'\n\tlet clientSecret = 'pi_1234567890...' // from your server, see README\n\tlet addressContainer\n</script>\n\n<Elements publicKey={PUBLIC_STRIPE_KEY} let:stripe let:elements {elementsOptions}>\n\t<form method=\"POST\" use:enhance={ async ({ cancel }) => {\n\t\tlet stripeResponse = await elements?.submit()\n\t\t// get the client secret here before final submission of payment\n\t\tconst { clientSecret } = await fetch('/checkout/turnstile', { \n\t\t\tmethod: 'POST', \n\t\t\tbody: JSON.stringify({ token })\n\t\t}).then(res => res.json()).catch(e => console.log(e))\n\n\t\tif (stripeResponse && !stripeResponse.error) {\n\t\t\tlet stripeResponse = await stripe.confirmPayment({ \n\t\t\t\telements,\n\t\t\t\tclientSecret,\n\t\t\t\tconfirmParams: { return_url: `https://example.com/order/success/${exampleOrderCode}` }\n\t\t\t})\n\t\t\tif (stripeResponse.error) { \n\t\t\t\tconsole.log(stripeResponse.error)\n\t\t\t\tcancel()\n\t\t\t} \n\t\t}\n\t\treturn async ({ result }) => {\n\t\t\t// If we get here instead of being redirected to the url set above,\n\t\t\t// we know that something went wrong.\n\t\t\terrorMessage = stripeResponse?.error?.message\n\t\t\tprocessing = false\n\t\t}\n\t}}>\n\t\t<AddressElement on:complete={ async (e) => {\n\t\t\tconsole.log(e.detail.firstName, e.detail.lastName, e.detail.address)\n\t\t}}/>\n\t\t<PaymentElement />\n\t\t<button type=\"submit\">Place Your Order</button>\n\t</form>\n</Elements>\n```\n\n### A Note About Security\n\nClient secrets include payment intents.  Exposing a way that a bot could generate payment intents very rapidly will expose you to carding attacks.  There are number of ways to mitigate the risk of automated carding attacks.  One way is client-side tools like Turnstile or reCAPTCHA.  A full discussion is outside the scope of this readme, but it's important to mention.  Consider using Turnstile or reCAPTCHA and other tools to rate limit the generation of payment intents.\n\nIf passing the client secret via a load function, consider adding a form action to the checkout page and make your checkout button post the token from Turnstile.  The checkout page form action will run before the checkout page load function.\n\nIf obtaining the client secret via an endpoint, you can obtain a client-side token before calling the endpoint and validate the token before returning a payment intent. A Turnstile Example:\n\n`+server.js`\n\n```js\nimport { validateToken } from 'sveltekit-turnstile'\nimport { SECRET_TURNSTILE_KEY } from '$env/static/private'\nimport { error, json } from '@sveltejs/kit'\n\nexport async function POST({ request }) {\n\tconst data = await request.json()\n\tif (!await validateToken(data.token, SECRET_TURNSTILE_KEY)) throw error(400, { message: 'Bot risk' })\n\t// some sort of validation on data\n\tconst clientSecret = await generateClientSecret() // example function \n\treturn json(clientSecret)\n}\n```\n\n`+page.svelte`\n\n```svelte\n<script>\n\t...\n\timport { PUBLIC_TURNSTILE_SITE_KEY } from '$env/static/public'\n\timport { Turnstile } from 'sveltekit-turnstile'\n\n\tlet token: string\n\t...\n</script>\n...\n{#if !token}\n\t<Turnstile siteKey={PUBLIC_TURNSTILE_SITE_KEY} on:turnstile-callback={ async (e) => { \n\t\ttoken = e.detail.token\n\t}} />\n{:else}\n...\n```\n\n## Generating a Client Secret\n\nIf you need to generate a client secret yourself, you will first need to add your secret Stripe key to your .env file:\n\n`.env`\n\n```bash\nSECRET_STRIPE_KEY=\"sk_1234567890...\"\n```\n\nYou must also add the Stripe SDK to your project:\n\n```bash\nnpm install -D stripe\n```\n\nThen, you can generate a payment intent in your load function and export the client secret:\n\n`+page.server.js`\n\n```js\nimport { Stripe } from 'stripe'\nimport { SECRET_STRIPE_KEY } from '$env/static/private'\n\nexport const load = async () => {\n\tconst stripe = new Stripe(SECRET_STRIPE_KEY)\n\n\tconst options = {\n\t\tprice: 1000, // price in smallest units (eg pennies), REQUIRED\n\t\tcurrency: 'USD', // currency code, REQUIRED\n\t\t//customer: locals.user.stripeCustomerId, required for setup intent\n\t\t//setup_future_usage: 'on_session', \n\t\t//automatic_payment_methods: { enabled: true }\n\t}\n\n\tconst paymentIntent = await stripe.paymentIntents.create(options)\n\n\treturn { \n\t\tclientSecret: paymentIntent.client_secret\n\t}\n}\n```\n\nWhile the above example works fine, you will probably notice that instantiating a new Stripe object on every load is not ideal.  We could instead create a singleton Stripe object in your app and export it.\n\n`lib/server/stripe.js`\n\n```js\nimport { Stripe } from 'stripe'\nimport { SECRET_STRIPE_KEY } from '$env/static/private'\nexport default new Stripe(SECRET_STRIPE_KEY)\n```\n\n`+page.server.js`\n\n```js\nimport stripe from '$lib/server/stripe'\n\nexport const load = async () => {\n\tconst options = {\n\t\tprice: 1000, \n\t\tcurrency: 'USD'\n\t}\n\n\tconst paymentIntent = await stripe.paymentIntents.create(options)\n\n\treturn { \n\t\tclientSecret: paymentIntent.client_secret\n\t}\n}\n```\n\n## Passing Options\n\nThe Payment and Address components support all options available in the Stripe SDK.\n\nFor details about options available, see the Stripe Documentation:\n\n- Payment Element [(docs)](https://stripe.com/docs/js/element/payment_element)\n- Address Element [(docs)](https://stripe.com/docs/js/element/address_element)\n\n### Example: Passing Options\n\n`+page.svelte`\n\n```svelte\n<script>\n\t...\n\tlet addressElementOptions = {\n\t\tautocomplete: 'automatic',\n\t\tallowedCountries: ['US', 'CA'],\n\t\tblockPoBox: false,\n\t\tdisplay: { name: 'split' }\n\t\tcontacts: [{\n\t\t\tname: 'Jenny Rosen',\n\t\t\taddress: {\n\t\t\t\tline1: '185 Berry St.',\n\t\t\t\tcity: 'San Francisco',\n\t\t\t\tstate: 'CA',\n\t\t\t\tpostal_code: '94941',\n\t\t\t\tcountry: 'US',\n\t\t\t}\n\t\t}]\n\t}\n\t...\n</script>\n\n...\n<Address {addressElementOptions} />\n...\n```\n\n### Example: Passing Options from a Separate File\n\nIf preferred, your options can be set in a separate file and imported.\n\n`addressElementOptions.ts`\n\n```ts\nimport type { StripeAddressElementOptions } from 'sveltekit-stripe'\nexport default addressElementOptions: StripeAddressElementOptions = {\n\t// options\n}\n```\n\n`+page.svelte`\n\n```svelte\nimport addressElementOptions from './addressElementOptions'\n...\n```\n\n## Customizing the Elements\n\nThe Payment and Address components support the [Appearance API](https://stripe.com/docs/elements/appearance-api).\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 18],
		[3603, 31],
		[3610, 25],
		[3617, 142],
		[3624, 34],
		[3631, 14],
		[3638, 17],
		[3645, 42],
		[3652, 66],
		[3659, 16],
		[3666, 51],
		[3673, 23],
		[3680, 69],
		[3687, 33],
		[3694, 67],
		[3701, 61],
		[3708, 68],
		[3715, 148],
		[3722, 126],
		[3729, 73],
		[3736, 113],
		[3743, 62],
		[3750, 56],
		[3757, 27],
		[3764, 30],
		[3771, 42],
		[3778, 85],
		[3785, 48],
		[3792, 26],
		[3799, 38],
		[3806, 101],
		[3813, 150],
		[3820, 47],
		[3827, 60],
		[3834, 52],
		[3841, 72],
		[3848, 41],
		[3855, 23],
		[3862, 18],
		[3869, 20],
		[3876, 15],
		[3883, 43],
		[3890, 72],
		[3897, 108],
		[3904, 45],
		[3911, 84],
		[3918, 42],
		[3925, 51],
		[3932, 54],
		[3939, 38],
		[3946, 18],
		[3953, 92],
		[3960, 31],
		[3967, 18],
		[3974, 29],
		[3981, 29],
		[3988, 10],
		[3995, 35],
		[4002, 54],
		[4009, 33],
		[4016, 43],
		[4023, 28],
		[4030, 20],
		[4037, 27],
		[4044, 20],
		[4051, 13],
		[4058, 30],
		[4065, 53],
		[4072, 89],
		[4079, 99],
		[4086, 24],
		[4093, 13],
		[4100, 41],
		[4107, 65],
		[4114, 216],
		[4121, 130],
		[4128, 96],
		[4135, 57]
	],
	"esm": true,
	"cjs": false
}
