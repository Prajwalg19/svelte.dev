{
	"name": "svelte-spa-router",
	"description": "Create single-page applications with Svelte using hash-based routing.",
	"repo_url": "https://github.com/ItalyPaleAle/svelte-spa-router",
	"authors": ["italypaleale"],
	"homepage": "https://github.com/ItalyPaleAle/svelte-spa-router#readme",
	"downloads": 15735,
	"updated": "2024-01-09T01:09:06.033Z",
	"tags": ["router"],
	"github_stars": 1566,
	"typescript": true,
	"version": "4.0.1",
	"svelte_range": "^4.2.8",
	"last_rune_check_version": "4.0.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-spa-router",
				"version": "4.0.1",
				"size": 60820
			},
			{
				"name": "regexparam",
				"version": "2.0.2",
				"size": 13840
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "<table>\n  <tr>\n    <td>\n      <a href=\"https://www.amazon.com/dp/B08D6T6BKS/\"><img src=\"https://static.packt-cdn.com/products/9781839213625/cover/smaller\" width=\"120\" /></a>\n    </td>\n    <td>\n      <h3>Svelte 3 Up and Running</h3>\n      <p>Want to learn Svelte 3 and how to build a Single-Page App (SPA) with it (and with this router)? Check out my book <a href=\"https://www.amazon.com/dp/B08D6T6BKS/\">Svelte 3 Up and Running</a> on Amazon.</p>\n    </td>\n</table>\n\n# svelte-spa-router\n\n[![Build Status](https://github.com/ItalyPaleAle/svelte-spa-router/workflows/Continuous%20Integration%20tests/badge.svg)](https://github.com/ItalyPaleAle/svelte-spa-router/actions) \n[![npm](https://img.shields.io/npm/v/svelte-spa-router.svg)](https://www.npmjs.com/package/svelte-spa-router)\n[![GitHub](https://img.shields.io/github/license/ItalyPaleAle/svelte-spa-router.svg)](https://github.com/ItalyPaleAle/svelte-spa-router/blob/master/LICENSE.md)\n\nThis module is a router for [Svelte 3 and 4](https://github.com/sveltejs/svelte) applications, specifically optimized for Single Page Applications (SPA).\n\nMain features:\n\n- Leverages **hash-based routing**, which is optimal for SPAs and doesn't require any server-side processing\n- Insanely simple to use, and has a minimal footprint\n- Uses the tiny [regexparam](https://github.com/lukeed/regexparam) for parsing routes, with support for parameters (e.g. `/book/:id?`) and more\n\nThis module is released under MIT license.\n\n## Video\n\n[\"So you want to pick a router?\"]((https://www.youtube.com/watch?v=EL1qM0cv0eA)) talk by @ItalyPaleAle at Svelte Summit 2020. Includes an explanation of the two kinds of routers and a demo of svelte-spa-router.  \n_(Click on the cover image to play the video on YouTube)_\n\n[![Click to play video: 'So you want to pick a router?'](https://img.youtube.com/vi/EL1qM0cv0eA/0.jpg)](https://www.youtube.com/watch?v=EL1qM0cv0eA)\n\n## Hash-based routing\n\nWith hash-based routing, navigation is possible thanks to storing the current view in the part of the URL after `#`, called \"hash\" or \"fragment\".\n\nFor example, if your SPA is in a static file called `index.html`, your URLs for navigating within the app look something like `index.html#/profile`, `index.html#/book/42`, etc. (The `index.html` part can usually be omitted for the index file, so you can just create URLs that look like `http://example.com/#/profile`).\n\nWhen I created this component, other routers for Svelte 3+ implemented navigation using the HTML5 history API. While those URLs look nicer (e.g. you can actually navigate to `http://example.com/profile`), they are not ideal for static Single Page Applications. In order for users to be able to share links or even just refresh the page, you are required to have a server on the backend processing the request, and building fully-static apps is much harder as a consequence.\n\nHash-based routing is simpler, works well even without a server, and it's generally better suited for static SPAs, especially when SEO isn't a concern, as is the case when the app requires authentication. Many popular apps use hash-based routing, including GMail!\n\n## Sample code\n\nCheck out the code in the [examples](/examples) folder for some usage examples.\n\nTo run the samples, clone the repository, install the dependencies, then build each sample using Rollup:\n\n````sh\ngit clone https://github.com/ItalyPaleAle/svelte-spa-router\ncd svelte-spa-router\nnpm install\n\n# Navigate to a sample\ncd examples/â€¦\n# For example\ncd examples/basic-routing\n\n# Build and run (in the folder of a sample)\nnpx rollup -c\nnpx serve -n -l 5050 dist\n````\n\nThe sample will be running at http://localhost:5050\n\n## Starter template\n\nYou can find a starter template with Svelte 4 and svelte-spa-router at [italypaleale/svelte-spa-router-template](https://github.com/italypaleale/svelte-spa-router-template).\n\nTo use the template:\n\n```sh\nnpx degit italypaleale/svelte-spa-router-template svelte-app\ncd svelte-app\n```\n\nMore information can be found on the [template's repo](https://github.com/italypaleale/svelte-spa-router-template).\n\n## Using svelte-spa-router\n\nYou can include the router in any project using Svelte 3 or 4.\n\n### Install from NPM\n\nTo add svelte-spa-router to your project:\n\n````sh\nnpm install svelte-spa-router\n````\n\n### Supported browsers\n\nsvelte-spa-router aims to support modern browsers, including recent versions of:\n\n- Chrome\n- Edge (\"traditional\" and Chromium-based)\n- Firefox\n- Safari\n\nSupport for Internet Explorer is not a goal for this project. Some users have reportedly been able to use svelte-spa-router with IE11 after transpilation (e.g. with Babel), but this is not guaranteed.\n\n### Define your routes\n\nEach route is a normal Svelte component, with the markup, scripts, bindings, etc. Any Svelte component can be a route.\n\nThe route definition is just a JavaScript dictionary (object) where the key is a string with the path (including parameters, etc), and the value is the route object.\n\nFor example:\n\n````js\nimport Home from './routes/Home.svelte'\nimport Author from './routes/Author.svelte'\nimport Book from './routes/Book.svelte'\nimport NotFound from './routes/NotFound.svelte'\n\nconst routes = {\n    // Exact path\n    '/': Home,\n\n    // Using named parameters, with last being optional\n    '/author/:first/:last?': Author,\n\n    // Wildcard parameter\n    '/book/*': Book,\n\n    // Catch-all\n    // This is optional, but if present it must be the last\n    '*': NotFound,\n}\n````\n\nRoutes must begin with `/` (or `*` for the catch-all route).\n\nAlternatively, you can also define your routes using custom regular expressions, as explained below.\n\nNote that the order matters! When your users navigate inside the app, the first matching path will determine which route to load. It's important that you leave any \"catch-all\" route (e.g. a \"Page not found\" one) at the end.\n\n### Include the router view\n\nTo display the router, in a Svelte component (usually `App.svelte`), first import the router component:\n\n````js\nimport Router from 'svelte-spa-router'\n````\n\nThen, display the router anywhere you'd like by placing the component in the markup. For example:\n\n````svelte\n<body>\n    <Router {routes}/>\n</body>\n````\n\nThe `routes` prop is the dictionary defined above.\n\nThat's it! You already have all that you need for a fully-functional routing experience.\n\n### Dynamically-imported components and code-splitting\n\nStarting with version 3.0, svelte-spa-router supports dynamically-imported components (via the `import()` construct). The advantage of using dynamic imports is that, if your bundler supports that, you can enable code-splitting and reduce the size of the bundle you send to your users. This has been tested with bundlers including Rollup and Webpack.\n\nTo use dynamically-imported components, you need to leverage the `wrap` method (which can be used for a variety of actions, as per the docs on [route wrapping](/Advanced%20Usage.md#route-wrapping)). First, import the `wrap` method:\n\n```js\nimport {wrap} from 'svelte-spa-router/wrap'\n```\n\nThen, in your route definition, wrap your routes using the `wrap` method, passing a function that returns the dynamically-imported component to the `asyncComponent` property:\n\n```js\nwrap({\n    asyncComponent: () => import('./Foo.svelte')\n})\n```\n\n> Note: the value of `asyncComponent` must be the **definition of a function** returning a dynamically-imported component, such as `asyncComponent: () => import('./Foo.svelte')`.  \n> Do **not** use `asyncComponent: import('./Foo.svelte')`, which is a function invocation instead.\n\nFor example, to make the Author and Book routes from the first example dynamically-imported, we'd update the code to:\n\n````js\n// Import the wrap method\nimport {wrap} from 'svelte-spa-router/wrap'\n\n// Note that Author and Book are not imported here anymore, so they can be imported at runtime\nimport Home from './routes/Home.svelte'\nimport NotFound from './routes/NotFound.svelte'\n\nconst routes = {\n    '/': Home,\n\n    // Wrapping the Author component\n    '/author/:first/:last?': wrap({\n        asyncComponent: () => import('./routes/Author.svelte')\n    }),\n\n    // Wrapping the Book component\n    '/book/*': wrap({\n        asyncComponent: () => import('./routes/Book.svelte')\n    }),\n\n    // Catch-all route last\n    '*': NotFound,\n}\n````\n\nThe `wrap` method accepts an object with multiple properties and enables other features, including: setting a \"loading\" component that is shown while a dynamically-imported component is being requested, adding pre-conditions (route guards), passing static props, and adding custom user data.\n\nYou can learn more about all the features of `wrap` in the documentation for [route wrapping](/Advanced%20Usage.md#route-wrapping).\n\n### Navigating between pages\n\nYou can navigate between pages with normal anchor (`<a>`) tags. For example:\n\n````svelte\n<a href=\"#/book/123\">Thus Spoke Zarathustra</a>\n````\n\n#### The `use:link` action\n\nRather than having to type `#` before each link, you can also use the `use:link` action:\n\n````svelte\n<script>\nimport {link} from 'svelte-spa-router'\n</script>\n<a href=\"/book/321\" use:link>The Little Prince</a>\n````\n\nThe `use:link` action accepts an optional parameter `opts`, which can be one of:\n\n- A dictionary `{href: '/foo', disabled: false}` where both keys are optional:\n  - If you set a value for `href`, your link will be updated to point to that address, reactively (this will always take precedence over `href` attributes, if present)\n  - Setting `disabled: true` disables the link, so clicking on that would have no effect\n- A string with a destination (e.g. `/foo`), which is a shorthand to setting `{href: '/foo'}`.\n\nFor example:\n\n````svelte\n<script>\nimport {link} from 'svelte-spa-router'\nlet myLink = \"/book/456\"\n</script>\n<!-- Note the {{...}} notation because we're passing an object as parameter for a Svelte action -->\n<a use:link={{href: myLink, disabled: false}}>The Biggest Princess</a>\n````\n\nThe above is equivalent to:\n\n````svelte\n<script>\nimport {link} from 'svelte-spa-router'\nlet myLink = \"/book/456\"\n</script>\n<a use:link={myLink}>The Biggest Princess</a>\n````\n\nChanging the value of `myLink` will reactively update the link's `href` attribute.\n\n#### Navigating programmatically\n\nYou can navigate between pages programmatically too:\n\n````js\nimport {push, pop, replace} from 'svelte-spa-router'\n\n// The push(url) method navigates to another page, just like clicking on a link\npush('/book/42')\n\n// The pop() method is equivalent to hitting the back button in the browser\npop()\n\n// The replace(url) method navigates to a new page, but without adding a new entry in the browser's history stack\n// So, clicking on the back button in the browser would not lead to the page users were visiting before the call to replace()\nreplace('/book/3')\n````\n\nThese methods can be used inside Svelte markup too, for example:\n\n````svelte\n<button on:click={() => push('/page')}>Go somewhere</button>\n````\n\nThe `push`, `pop` and `replace` methods perform navigation actions only in the next iteration (\"tick\") of the JavaScript event loop. This makes it safe to use them also inside `onMount` callbacks within Svelte components.\n\nThese functions return a Promise that resolves with no value once the navigation has been triggered (in the next tick of the event loop); however, please note that this will likely be before the new page has rendered.\n\n### Parameters from routes\n\nsvelte-spa-router uses [regexparam](https://github.com/lukeed/regexparam) to parse routes, so you can add optional parameters to the route. Basic syntax is:\n\n- `/path` matches `/path` exactly (and only that)\n- `/path/:id` matches `/path/` followed by any string, which is a named argument `id`\n- `/path/:id/:version?` allows for an optional second named argument `version`\n- `/path/*` matches `/path/` followed by anything, using a non-named argument\n\n_Please refer to the documentation of regexparam for more details._\n\nIf your route contains any parameter, they will be made available to your component inside the `params` dictionary.\n\nFor example, for a route `/name/:first/:last?`, you can create this Svelte component:\n\n````svelte\n<p>Your name is: <b>{params.first}</b> <b>{#if params.last}{params.last}{/if}</b></p>\n<script>\n// You need to define the component prop \"params\"\nexport let params = {}\n</script>\n````\n\nNon-named arguments are returned as `params.wild`.\n\n### Getting the current page\n\nYou can get the current page from the `$location` readable store. This is a Svelte store, so it can be used reactively too.\n\n````svelte\n<script>\nimport {location} from 'svelte-spa-router'\n</script>\n<p>The current page is: {$location}</p>\n````\n\n### Querystring parameters\n\nYou can also extract \"querystring\" parameters from the hash of the page. This isn't the _real_ querystring, as it's located after the `#` character in the URL, but it can be used in a similar way. For example: `#/books?show=authors,titles&order=1`.\n\nWhen svelte-spa-router finds a \"querystring\" in the hash, it separates that from the location and returns it as a string in the Svelte store `$querystring`. For example:\n\n````svelte\n<script>\nimport {location, querystring} from 'svelte-spa-router'\n</script>\n<p>The current page is: {$location}</p>\n<p>The querystring is: {$querystring}</p>\n````\n\nWith the example above, this would print:\n\n````text\nThe current page is: /books\nThe querystring is: show=authors,titles&order=1\n````\n\nIt's important to note that, to keep this component lightweight, svelte-spa-router **does not parse** the \"querystring\". If you want to parse the value of `$querystring`, you can use [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) available in all modern browsers, or third-party modules such as [qs](https://www.npmjs.com/package/qs).\n\n### Highlight active links\n\nsvelte-spa-router has built-in support for automatically marking links as \"active\", with the `use:active` action.\n\nFor example, you can use the code below to add the CSS class `active` to links that are active:\n\n````svelte\n<script>\nimport {link} from 'svelte-spa-router'\nimport active from 'svelte-spa-router/active'\n</script>\n\n<style>\n/* Style for \"active\" links; need to mark this :global because the router adds the class directly */\n:global(a.active) {\n    color: red;\n}\n</style>\n\n<a href=\"/hello/user\" use:link use:active={{path: '/hello/*', className: 'active', inactiveClassName: 'inactive'}}>Say hi!</a>\n<a href=\"/hello/user\" use:link use:active={'/hello/*'}>Say hi with a default className!</a>\n<a href=\"/hello/user\" use:link use:active>Say hi with all default options!</a>\n````\n\nThe `active` action accepts a dictionary `options` as argument:\n\n- `options.path`: the path that, when matched, makes the link active. In the first example above, we want the link to be active when the route is `/hello/*` (the asterisk matches anything after that). As you can see, this doesn't have to be the same as the path the link points to. When `options.path` is omitted or false-y, it defaults to the path specified in the link's `href` attribute. This parameter can also be a regular expression that will mark the link as active when it matches: for example, setting to the regular expression `/^\\/*\\/hi$/` will make the link active when it starts with `/` and ends with `/hi`, regardless of what's in between.\n- `options.className`: the name of the CSS class to add. This is optional, and it defaults to `active` if not present.\n- `options.inactiveClassName`: the name of the CSS class to add when the link is _not_ active. This is optional, and it defaults to nothing if not present.\n\nAs a shorthand, instead of passing a dictionary as `options`, you can pass a single string or regular expression that will be interpreted as `options.path`.\n\n### Define routes with custom regular expressions\n\nSince version 1.2 of svelte-spa-router, it's possible to define routes using custom regular expressions too, allowing for greater flexibility. However, this requires defining routes using a JavaScript Map rather than an object:\n\n````js\nimport Home from './routes/Home.svelte'\nimport Name from './routes/Name.svelte'\nimport NotFound from './routes/NotFound.svelte'\n\nconst routes = new Map()\n\n// You can still use strings to define routes\nroutes.set('/', Home)\nroutes.set('/hello/:first/:last?', Name)\n\n// The keys for the next routes are regular expressions\n// You will very likely always want to start the regular expression with ^\nroutes.set(/^\\/hola\\/(.*)/i, Name)\nroutes.set(/^\\/buongiorno(\\/([a-z]+))/i, Name)\n\n// Catch-all, must be last\nroutes.set('*', NotFound)\n````\n\nWhen you define routes as regular expressions, the `params` prop is populated with an array with the result of the matches from the regular expression.\n\nFor example, with this `Name.svelte` route:\n\n````svelte\n<p>Params is: <code>{JSON.stringify(params)}</code></p>\n<script>\n// You need to define the component prop \"params\"\nexport let params = {}\n</script>\n````\n\nWhen visiting `#/hola/amigos`, the params prop will be `[\"/hola/amigos\",\"amigos\"]`.\n\nThis is consistent with the results of [`RegExp.prototype.exec()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec).\n\n> When defining a route using a regular expression, you can optionally use [named capturing groups](https://2ality.com/2017/05/regexp-named-capture-groups.html). When using those, in addition to finding your matches in the `params` prop, you can find the matches for named capturing groups in `params.group`.  \n> For example, consider the route:\n>\n> ```js\n> routes.set(/^\\/book\\/(?<title>[a-z]+)$/, Book)\n> ```\n> \n> When visiting `/#/book/mytitle`, the `params` prop will be an array with `[\"/book/mytitle\", \"mytitle\"]`, and `params.groups` will be a dictionary with `{\"title\": \"mytitle\"}`.\n\n## Advanced usage\n\nCheck out the [Advanced Usage](/Advanced%20Usage.md) documentation for using:\n\n- [Route wrapping](/Advanced%20Usage.md#route-wrapping), including:\n  - [Dynamically-imported routes and placeholders](/Advanced%20Usage.md#async-routes-and-loading-placeholders)\n  - [Route pre-conditions](/Advanced%20Usage.md#route-pre-conditions) (\"route guards\")\n  - [Adding user data to routes](/Advanced%20Usage.md#user-data)\n  - [Static props](/Advanced%20Usage.md#static-props)\n- [`routeEvent` event](/Advanced%20Usage.md#routeevent-event)\n- [`routeLoading` and `routeLoaded` events](/Advanced%20Usage.md#routeloading-and-routeloaded-events)\n- [Querystring parsing](/Advanced%20Usage.md#querystring-parsing)\n- [Static props](/Advanced%20Usage.md#static-props)\n- [Route transitions](/Advanced%20Usage.md#route-transitions)\n- [Nested routers](/Advanced%20Usage.md#nested-routers)\n- [Route groups](/Advanced%20Usage.md#route-groups)\n- [Restore scroll position](/Advanced%20Usage.md#restore-scroll-position)\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3596, 20952],
		[3603, 20291],
		[3610, 20529],
		[3617, 21211],
		[3624, 20426],
		[3631, 18496],
		[3638, 16750],
		[3645, 6871],
		[3652, 11846],
		[3659, 20454],
		[3666, 22677],
		[3673, 20532],
		[3680, 19916],
		[3687, 20461],
		[3694, 15694],
		[3701, 21160],
		[3708, 17415],
		[3715, 17166],
		[3722, 15211],
		[3729, 15444],
		[3736, 14592],
		[3743, 15331],
		[3750, 16664],
		[3757, 15891],
		[3764, 15466],
		[3771, 10814],
		[3778, 12344],
		[3785, 13960],
		[3792, 12153],
		[3799, 14707],
		[3806, 13436],
		[3813, 14099],
		[3820, 13465],
		[3827, 14561],
		[3834, 13664],
		[3841, 13705],
		[3848, 12933],
		[3855, 14845],
		[3862, 12773],
		[3869, 14016],
		[3876, 11956],
		[3883, 13786],
		[3890, 12972],
		[3897, 13379],
		[3904, 19552],
		[3911, 20327],
		[3918, 16212],
		[3925, 19650],
		[3932, 19869],
		[3939, 21251],
		[3946, 19567],
		[3953, 16103],
		[3960, 15666],
		[3967, 11380],
		[3974, 12329],
		[3981, 14437],
		[3988, 12514],
		[3995, 12234],
		[4002, 11837],
		[4009, 5845],
		[4016, 7864],
		[4023, 15834],
		[4030, 12969],
		[4037, 13064],
		[4044, 12649],
		[4051, 17385],
		[4058, 19386],
		[4065, 16871],
		[4072, 15782],
		[4079, 18609],
		[4086, 15931],
		[4093, 17635],
		[4100, 16965],
		[4107, 17023],
		[4114, 15735],
		[4121, 13469],
		[4128, 14406],
		[4135, 13023]
	]
}
