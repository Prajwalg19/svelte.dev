{
	"name": "svelte-form-helper",
	"description": "Provides lightweight helper for Svelte form validation.",
	"repo_url": "https://github.com/captaincodeman/svelte-form-helper",
	"authors": ["captaincodeman"],
	"homepage": "https://captaincodeman.github.io/svelte-form-helper/",
	"downloads": 30,
	"updated": "2024-04-27T18:51:26.876Z",
	"tags": ["miscellaneous"],
	"github_stars": 56,
	"typescript": true,
	"version": "0.4.1",
	"svelte_range": "^3.54.0 || ^4.0.0 || ^5.0.0",
	"kit_range": "^2.5.7",
	"last_rune_check_version": "0.4.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-form-helper",
				"version": "0.4.1",
				"size": 17959
			},
			{
				"name": "highlight.js",
				"version": "11.11.1",
				"size": 5433042
			}
		],
		"dependencies": [[0, 1]],
		"circular": []
	},
	"readme": "# Svelte Form Helper\n\nLightweight helper for form validation with Svelte\n\n1.79 KB minified, 919 bytes gzipped (compression level 6)\n\n## Features\n\n- ✅ Tiny size (it could have been called `itsy-bitsy-teenie-weenie-svelte-form-validate-machiney`)\n- ✅ Progressive enhancement of standard form validation\n- ✅ Supports SSR only forms (with JS disabled, or if JS fails to load)\n- ✅ Easy acces to validation state and control over messaging & styling when JS is enabled\n- ✅ Support dynamic addition / removal of form fields\n- ✅ Aggregate individual field into form-level state\n- ✅ Add appropriate WIA-ARIA accessibility attributes for screen readers\n- ✅ Works great with [SvelteKit Form actions](https://kit.svelte.dev/docs/form-actions)\n- ✅ Supports all [HTMLElements that implement The Constraint Validation API](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#the_constraint_validation_api)\n\n## Example\n\nOnline example coming soon, in the meantime checkout the [Basic Example](https://github.com/CaptainCodeman/svelte-form-helper/blob/master/src/routes/Example.svelte) or the [Component Example](https://github.com/CaptainCodeman/svelte-form-helper/blob/master/src/routes/ExampleHelpers.svelte)\n\n## Usage\n\nThe important thing to remember is that we're not trying to _replace_ or _re-implement_ the browser native form validation, so you won't find JS versions of `required` or `minlength` - we build on top of what the browser already provides, to enhance it. So it's worth being familiar with the [validation attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation) available.\n\nWe also use the native browser [`ValidityState` model](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState) to determine if and why validation failed and use those flags to determine what validation messages to show.\n\n### Install from NPM\n\nInstall using your package manager of choice, e.g.:\n\n    npm install svelte-form-helper\n    pnpm i svelte-form-helper\n    yarn add svelte-form-helper\n\n### Create Form Instance\n\nFirst import the `createForm` factory function in your component `<script>` block and create a form validator instance from it:\n\n```ts\nimport { createForm } from 'svelte-form-helper'\n\nconst form = createForm()\n```\n\n### Create Field Instance(s)\n\nFields are created using the form instance `.field()` method. An options object can be passed to set:\n\n- `onDirty` - a boolean flag of whether to show validation errors on `input` (default `false`)\n- `onTouched` - a boolean flag of whether to show validation errors on `blur` (default `true`)\n- `validator` - a custom validator function\n\n```ts\nconst name = form.field({ validator: isNameAvailable, onDirty: true })\nconst email = form.field({ onDirty: true })\nconst title = form.field()\n```\n\nNOTE: The field is _always_ validated on `input` and `blur` (i.e. when dirty or touched) so the form validation state is always known and uptodate. This creates a better user experience as the form submit button will be enabled as soon as the form is valid, rather than requiring the user to tab out of the field first.\n\n### Custom Validation Function\n\nThe custom validation function will be called if the field is otherwise valid (i.e. it won't be called if the input is set to `required` but is empty or hasn't yet met a required input length). It should accept a string value parameter and return a message if validation fails or else `null` if the value was valid. The validation function can be async to call a remote endpoint - if the input changes before the previous validation completed, the last one called will always win.\n\n```ts\nasync function isNameAvailable(value: string) {\n  const resp = await fetch('/checkname?name=' + value)\n  return resp.status === 200 ? null : `Name not available`\n}\n```\n\nNOTE: It will be ignored if used with a `HTMLFieldSetElement` (which represents a `<fieldset>` element) as this lacks a `value` property.\n\n### Apply to HTMLFormElement\n\nThe `form` instance is a Svelte `use:action` directive so adding it to the `<form>` tag in the Svelte template associates it with the actual `HTMLFormElement` that is created in the browser:\n\n```svelte\n<form use:form on:submit={onSubmit}>\n```\n\nOn the client the form action will set the `noValidate` property of the form to disable the native browser validation messages and provide us full control to provide and style our own. If JS is not available for any reason, the native browser validation will still be enabled.\n\n### Access Form State\n\nThe `form` instance is _also_ a Svelte Readable Store and provides flags to indicate if the form is:\n\n- `dirty` (_any_ field has been input)\n- `touched` (the user has clicked on or tabbed to _any_ field)\n- `valid` (_all_ of the fields attached to the form are valid)\n\nThe typical use for the state is to enable or disable the form submit button (which can also be reflected in its style to provide feedback to the user). Remember to use the `$` prefix to access the store value itself:\n\n```svelte\n<button type=\"submit\" disabled={!$form.valid}>Submit</button>\n```\n\nThis flag can also be used to prevent form submission in any `on:submit` event handler.\n\n### Apply to HTMLInputElement(s)\n\nThe individual field instances are also Svelte `use:action` directives and should be added to the corresponding `<input>` tags in the template to associate them with the actual `HTMLInputElement`s in the browser:\n\n```svelte\n<input use:name type=\"text\" placeholder=\"unique name\" required minlength=\"5\" maxlength=\"50\"/>\n\n<input use:email type=\"email\" placeholder=\"email address\" required />\n```\n\n### CSS `:valid` & `:invalid` Input Styling\n\nThe current field state is reflected to the HTML Element with `data-show`, `data-dirty` and `data-touched` attributes which can be used to style the input itself. You could apply a green or red border to indicate its valid or invalid state only when touched for instance. Note the reason for not using the `:valid` and `:invalid` CSS pseudo classes alone is that the styles would otherwise be applied to inputs on page load which is not a great user experience.\n\n#### Svelte Style\n\nA Svelte style based on the `data-touched` attribute needs to be made global to prevent it being removed:\n\n<style global>\n  input[data-touched]:valid {\n    color: green;\n    border-color: green;\n  }\n\n  input[data-touched]:invalid {\n    color: red;\n    border-color: red;\n  }\n</style>\n\n#### TailwindCSS\n\nIf using TailwindCSS the styles can be added directly to the input element. e.g. to make the text and border red or green based on the state:\n\n```html\n<input\n  use:email\n  type=\"email\"\n  placeholder=\"email address\"\n  required\n  class=\"\n    data-[touched]:valid:text-green-700\n    data-[touched]:valid:border-green-700\n    data-[touched]:invalid:text-red-700\n    data-[touched]:invalid:border-red-700\n  \"\n/>\n```\n\nThis can be made tidier by adding a custom variant using a TailwindCSS plugin defined in `tailwind.config.cjs`:\n\n```ts\nconst plugin = require('tailwindcss/plugin')\n\n// rest of config\n\nplugins: [\n  plugin(({ addVariant }) => {\n    addVariant('touched', '&[data-touched]')\n  }),\n],\n```\n\nThe previous classes applied to the input element can then be simplified to:\n\n```html\n<input\n  use:email\n  type=\"email\"\n  placeholder=\"email address\"\n  required\n  class=\"\n    touched:valid:text-green-700\n    touched:valid:border-green-700\n    touched:invalid:text-red-700\n    touched:invalid:border-red-700\n  \"\n/>\n```\n\n### Access Field State\n\nEnough about styling the input elements themselves, what about adding additonal validation messages and hints?\n\nThe individual field instances are _also_ Svelte Readable Stores and provide easy access to the validation state of their associated `HTMLInputElement`. This can be used to decide what validation messages or hints to output. Whether the message should be shown is determined by the `show` flag.\n\nThis snippet will output the default validation message that the browser generates but allows control over where it is shown and how it is styled. Note the `id` being set on the message element - this allows the message to be linked to the `HTMLInputElement` by setting the appropriate `aria-invalid` and `aria-describedby` attributes on it (this happens automatically):\n\n```svelte\n{#if $name.show}\n  <div id={$name.id} class=\"text-red-700\">{$name.message}</div>\n{/if}\n```\n\nBut we also have access to the [`ValidityState` flags](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState) so we're not limited to the message that the browser generates - we can decide exactly what custom message we want to show for each reason:\n\n```svelte\n{#if $name.show}\n  <div id={$name.id} class=\"text-red-700\">\n    {#if $name.valueMissing}Name is required{/if}\n    {#if $name.tooShort}Name must be at least 5 characters{/if}\n    {#if $name.tooLong}Name can't be longer than 50 characters{/if}\n    {#if $name.customError}Name not available{/if}\n  </div>\n{/if}\n```\n\nNOTE: instead of using the `{#if}` block another approach is to set the `hidden` attribute based on the `show` flag to control whether the validation message is shown:\n\n```svelte\n<div id={$name.id} class=\"text-red-700\" hidden={!$name.show}>\n  {#if $name.valueMissing}Name is required{/if}\n  {#if $name.tooShort}Name must be at least 5 characters{/if}\n  {#if $name.tooLong}Name can't be longer than 50 characters{/if}\n  {#if $name.customError}Name not available{/if}\n</div>\n```\n\n### Validation Component Wrappers\n\nThe use of `{#if}` blocks or `hidden` attributes helps keep the package size down and should be more efficient, but it's also possible to define some Svelte Components to make the outputting easier if preferred:\n\n```svelte\n<input use:email type=\"email\" placeholder=\"email address\" required />\n\n<Validation for={email} class=\"text-red-700\">\n  <Hint valueMissing>Email address is required</Hint>\n  <Hint typeMismatch>Not a valid email address</Hint>\n</Validation>\n```\n\n#### Validation.svelte\n\nThe simplest message display just needs to reference the field:\n\n```svelte\n<Validation for={email} class=\"text-red-700\" />\n```\n\n```svelte\n<script lang=\"ts\" context=\"module\">\n  import type { FieldState } from 'svelte-form-helper/field'\n\n  export const key = {}\n  export type Context = {\n    state: Readable<FieldState>\n    clazz: string\n  }\n</script>\n\n<script lang=\"ts\">\n  import type { Readable } from 'svelte/store'\n\n  import { setContext } from 'svelte'\n  export { state as for }\n\n  let state: Readable<FieldState>\n  let clazz = $$props.class\n\n  setContext<Context>(key, { state, clazz })\n</script>\n\n{#if $state.show}\n  <slot><div id={$state.id} class={clazz}>{$state.message}</div></slot>\n{/if}\n```\n\n#### Hint.svelte\n\nFor separate validation messages per reason, nest one or more `<Hint>` components within a `<Validation>` component:\n\n```svelte\n<input use:email type=\"email\" placeholder=\"email address\" required />\n\n<Validation for={email} class=\"m-1 text-xs text-red-700\">\n  <Hint valueMissing>Email address is required</Hint>\n  <Hint typeMismatch>Not a valid email address</Hint>\n</Validation>\n```\n\n```svelte\n<script lang=\"ts\">\n  import { key } from './Validation.svelte'\n  import type { Context } from './Validation.svelte'\n  import { getContext } from 'svelte'\n\n  export let badInput = false\n  export let customError = false\n  export let patternMismatch = false\n  export let rangeOverflow = false\n  export let rangeUnderflow = false\n  export let stepMismatch = false\n  export let tooLong = false\n  export let tooShort = false\n  export let typeMismatch = false\n  export let valid = false\n  export let valueMissing = false\n\n  const { state, clazz } = getContext<Context>(key)\n\n  // prettier-ignore\n  $: show = ($state.badInput && badInput) ||\n            ($state.customError && customError) ||\n            ($state.patternMismatch && patternMismatch) ||\n            ($state.rangeOverflow && rangeOverflow) ||\n            ($state.rangeUnderflow && rangeUnderflow) ||\n            ($state.stepMismatch && stepMismatch) ||\n            ($state.tooLong && tooLong) ||\n            ($state.tooShort && tooShort) ||\n            ($state.typeMismatch && typeMismatch) ||\n            ($state.valid && valid) ||\n            ($state.valueMissing && valueMissing)\n</script>\n\n{#if show}\n  <div id={$state.id} class={clazz}><slot message={$state.message} /></div>\n{/if}\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 3],
		[3596, 2],
		[3603, 18],
		[3610, 19],
		[3617, 4],
		[3624, 13],
		[3631, 20],
		[3638, 8],
		[3645, 19],
		[3652, 7],
		[3659, 5],
		[3666, 18],
		[3673, 17],
		[3680, 5],
		[3687, 2],
		[3694, 5],
		[3701, 1],
		[3708, 1],
		[3715, 9],
		[3722, 4],
		[3729, 5],
		[3736, 3],
		[3743, 3],
		[3757, 8],
		[3764, 84],
		[3771, 29],
		[3778, 34],
		[3785, 3],
		[3792, 9],
		[3799, 25],
		[3806, 4],
		[3813, 7],
		[3820, 37],
		[3827, 8],
		[3834, 7],
		[3841, 92],
		[3848, 6],
		[3855, 1],
		[3862, 10],
		[3869, 9],
		[3876, 7],
		[3883, 28],
		[3890, 50],
		[3897, 34],
		[3904, 47],
		[3911, 23],
		[3918, 9],
		[3925, 27],
		[3932, 39],
		[3939, 31],
		[3946, 69],
		[3953, 36],
		[3960, 12],
		[3967, 27],
		[3974, 25],
		[3981, 35],
		[3988, 27],
		[3995, 26],
		[4002, 29],
		[4009, 37],
		[4016, 43],
		[4023, 12],
		[4030, 32],
		[4037, 22],
		[4044, 56],
		[4051, 14],
		[4058, 31],
		[4065, 15],
		[4072, 11],
		[4079, 9],
		[4086, 12],
		[4093, 12],
		[4100, 28],
		[4107, 89],
		[4114, 30],
		[4121, 43],
		[4128, 44]
	]
}
