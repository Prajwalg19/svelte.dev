{
	"name": "svader",
	"description": "Create GPU-rendered Svelte components with WebGL/WebGPU.",
	"repo_url": "https://github.com/sockmaster27/svader",
	"authors": ["gomfer"],
	"homepage": "https://github.com/sockmaster27/svader#readme",
	"downloads": 29,
	"updated": "2025-03-04T12:21:18.764Z",
	"tags": ["ui"],
	"github_stars": 408,
	"typescript": true,
	"version": "0.5.4",
	"svelte_range": "^5.0.0||^4.0.0",
	"last_rune_check_version": "0.5.4",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svader",
				"version": "0.5.4",
				"size": 72554
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "<p align=\"center\">\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://raw.githubusercontent.com/sockmaster27/svader/master/resources/logoDark.png\">\n    <img width=\"150\" alt=\"Svader Logo\" src=\"https://raw.githubusercontent.com/sockmaster27/svader/master/resources/logoLight.png\">\n  </picture>\n  <br>\n  <a href=\"https://github.com/sockmaster27/svader/blob/master/LICENSE.md\"><img alt=\"MIT License\" src=\"https://img.shields.io/badge/license-MIT-blue\"></a>\n  <a href=\"https://github.com/sockmaster27/svader/actions/workflows/ci.yml\"><img alt=\"CI Status\" src=\"https://github.com/sockmaster27/svader/actions/workflows/ci.yml/badge.svg\"></a>\n  <br>\n  <a href=\"https://www.npmjs.com/package/svader\"><img alt=\"NPM Version\" src=\"https://img.shields.io/npm/v/svader\"></a>\n</p>\n\n# Svader\n\nCreate GPU-rendered Svelte components with WebGL and WebGPU fragment shaders.\n\nSupports Svelte 4 and Svelte 5.\n\n## What is a fragment shader?\n\nIn short, a _fragment shader_ can be written as a program that takes the coordinates of a pixel on the screen and returns the color that this pixel should have.\nThis program can be executed on the GPU, ensuring massive parallelism and speed.\n\nTo learn more about how to write fragment shaders, check out [The Book of Shaders](https://thebookofshaders.com/).\n\nThe following is a collection of examples all made using Svader. The live version of all of these can be previewed on [svader.vercel.app](https://svader.vercel.app/),\nand the source code can be found in the [`src/routes/`](https://github.com/sockmaster27/svader/tree/master/packages/tests-svelte5/src/routes) directory.\n\n![Shader example collage](https://raw.githubusercontent.com/sockmaster27/svader/master/resources/collage.png)\n\n## Installation\n\n```bash\n# npm\nnpm i -D svader\n\n# pnpm\npnpm i -D svader\n\n# Bun\nbun i -D svader\n\n# Yarn\nyarn add -D svader\n```\n\n## Usage\n\nTo use a fragment shader component, you first need to decide whether to use WebGL or WebGPU.\nIf you're unsure about what to use, see the [WebGL vs. WebGPU](#webgl-vs-webgpu) section.\n\n### Sections\n\n- [WebGL](#webgl)\n    - [WebGL parameters](#webgl-parameters)\n        - [WebGL built-in values](#webgl-built-in-values)\n- [WebGPU](#webgpu)\n    - [WebGPU parameters](#webgpu-parameters)\n        - [WebGPU built-in values](#webgpu-built-in-values)\n\n### WebGL\n\nThe following is a minimal example of a WebGL fragment shader component.\n\n[**View in playground**](https://svelte.dev/playground/3e4a38bca5ca49fa94e1106a841063d5?version=5.16.2)\n\n```svelte\n<script>\n    import { WebGlShader } from \"svader\";\n\n    const shaderCode = `#version 300 es\n\n        precision highp float;\n\n        out vec4 fragColor;\n\n        uniform vec2 u_resolution;\n        uniform vec2 u_offset;\n\n        void main() {\n            vec2 pos = gl_FragCoord.xy + u_offset;\n            vec2 st = pos / u_resolution;\n            fragColor = vec4(st, 0.0, 1.0);\n        }\n    `;\n</script>\n\n<WebGlShader\n    width=\"500px\"\n    height=\"500px\"\n    code={shaderCode}\n    parameters={[\n        { name: \"u_resolution\", value: \"resolution\" },\n        { name: \"u_offset\", value: \"offset\" },\n    ]}\n>\n    <div class=\"fallback\">WebGL not supported in this environment.</div>\n</WebGlShader>\n```\n\nThis produces the following output:\n\n![Output of the WebGL shader](https://raw.githubusercontent.com/sockmaster27/svader/master/resources/debugShaderWebGl.png)\n\nHere, the `shaderCode` variable is a string containing the [GLES](https://en.wikipedia.org/wiki/OpenGL_ES) shader code.\nFor simplicity, this is stored as a string, but it would typically be stored in a separate `myShader.frag` file.\nWhen loading the shader from a file, it might be useful to know that the `code` property accepts both a `string` and a `Promise<string>`.\n\nWhat this code does is:\n\n1. Add the given `u_offset` uniform to the 2D coordinates of the pixel given by `gl_FragCoord.xy`.\n2. Divide the resulting coordinates entrywise by the `u_resolution` uniform to normalize the coordinates between 0 and 1.\n3. Return the normalized coordinates as the color of the pixel, such that the `x` coordinate becomes the red channel and the `y` coordinate becomes the green channel. The blue channel is always set to 0, and the alpha (opacity) channel is always set to 1 (fully opaque).\n\nIn GLES, _uniforms_ are inputs to the shader program, that are the same for every pixel on the screen.\nThese need to be passed in via the `parameters` property of the `<WebGlShader>` component.\nIn this case, we need to pass in two uniforms: `u_resolution` and `u_offset`.\nSince these specific parameters are very commonly used, they are specially implemented in Svader\nsuch that the `value` property of each parameter can simply be set to `\"resolution\"` and `\"offset\"` respectively.\n\nLastly, the `<WebGlShader>` component accepts a fallback slot, which is rendered when the browser cannot render the shader.\n\n#### WebGL parameters\n\nThe `parameters` property is an array of objects with the following properties:\n\n- **`name`**: The name of the uniform parameter, e.g. `\"my_uniform\"`.\n  This must match the name of the parameter in the shader code.\n\n- **`type`**: The type of the uniform parameter as it is written in the shader code, e.g. `\"float\"`.\n  If the `value` property is a [built-in value](#webgl-built-in-values), such as `\"resolution\"`,\n  the `type` will be determined automatically and should not be set.\n\n- **`value`**: The value of the uniform parameter, or a string specifying a [built-in value](#webgl-built-in-values).\n  If not a built-in value, the type of this property must correspond to the `type` property, such that:\n    - **`float`, `int`, `uint`** is a `number`,\n    - **`vecN`, `ivecN`, `uvecN`** is a `number[]` with a length of `N`, e.g. `vec2` -> `[1.2, 3.4]`.\n    - **`matN`** is a `number[]` with a length of `N * N`, e.g. `mat2` -> `[1, 2, 3, 4]`.\n\n##### WebGL built-in values\n\nSome types of uniforms are used very often. These are implemented in Svader itself, and referred to as _built-in values_.\nTo use these, the `value` property of the parameter object must be set to a string matching one of the following:\n\n- **`\"resolution\"`**: A `vec2` of the canvas width and height in physical device pixels.\n\n- **`\"scale\"`**: A `float` of the ratio between CSS pixels and physical device pixels, i.e. zoom level.\n  For example, if the browser has been zoomed to 150%, the `scale` parameter will be `1.5`.\n\n- **`\"time\"`**: A `float` of the current time in seconds.\n  NOTE: Passing this parameter to the shader will cause it to rerender every frame.\n\n- **`\"offset\"`**: A `vec2` to be added to the `gl_FragCoord.xy` of the fragment shader.\n  Sometimes the size of the canvas is limited by hardware.\n  To compensate for this, Svader creates a virtual canvas with a smaller cutout shifting around to cover the screen.\n  The `\"resolution\"` parameter is automatically adjusted to match the size of this virtual canvas, but for technical reasons,\n  the `gl_FragCoord.xy` cannot be adjusted from the outside.\n  Therefore, the `\"offset\"` parameter is provided to be manually added to these coordinates.\n\n### WebGPU\n\nThe following is a minimal example of a WebGPU fragment shader component.\n\n[**View in playground**](https://svelte.dev/playground/498446d091964bb199e6a88bce90feae?version=5.16.3)\n\n```svelte\n<script>\n    import { WebGpuShader } from \"svader\";\n\n    const shaderCode = `\n        @group(0) @binding(0) var<uniform> resolution: vec2f;\n        @group(0) @binding(1) var<uniform> offset: vec2f;\n\n        @fragment\n        fn main(@builtin(position) raw_pos: vec4f) -> @location(0) vec4f {\n            let pos = raw_pos.xy + offset;\n            let st = pos / resolution;\n            return vec4f(st, 0.0, 1.0);\n        }\n    `;\n</script>\n\n<WebGpuShader\n    width=\"500px\"\n    height=\"500px\"\n    code={shaderCode}\n    parameters={[\n        { label: \"Resolution\", binding: 0, value: \"resolution\" },\n        { label: \"Offset\", binding: 1, value: \"offset\" },\n    ]}\n>\n    <div class=\"fallback\">WebGPU not supported in this environment.</div>\n</WebGpuShader>\n```\n\nThis produces the following output:\n\n![Output of the WebGPU shader](https://raw.githubusercontent.com/sockmaster27/svader/master/resources/debugShaderWebGpu.png)\n\nHere, the `shaderCode` variable is a string containing the [WGSL](https://google.github.io/tour-of-wgsl/) shader code.\nFor simplicity, this is stored as a string, but it would typically be stored in a separate `myShader.wgsl` file.\nWhen loading the shader from a file, it might be useful to know that the `code` property accepts both a `string` and a `Promise<string>`.\n\nWhat this code does is:\n\n1. Add the given `offset` uniform variable to the 2D coordinates of the pixel given by `raw_pos.xy`.\n2. Divide the resulting coordinates entrywise by the `resolution` uniform to normalize the coordinates between 0 and 1.\n3. Return the normalized coordinates as the color of the pixel, such that the `x` coordinate becomes the red channel and the `y` coordinate becomes the green channel. The blue channel is always set to 0, and the alpha (opacity) channel is always set to 1 (fully opaque).\n\nIn WGSL, these `var<uniform>`s are the primary way to pass in parameters to the shader.\nThese need to be passed in via the `parameters` property of the `<WebGpuShader>` component.\nIn this case, we need to pass in two uniforms: `resolution` and `offset`.\nSince these specific parameters are very commonly used, they are specially implemented in Svader\nsuch that the `value` property of each parameter can simply be set to `\"resolution\"` and `\"offset\"` respectively.\n\nLastly, the `<WebGpuShader>` component accepts a fallback slot, which is rendered when the browser cannot render the shader.\n\n#### WebGPU parameters\n\nThe `parameters` property is an array of objects with the following properties:\n\n- **`label`**: The name of the parameter to be used for debugging.\n  This does not have to correspond to the name of the parameter in the shader code.\n\n- **`binding`**: An integer used to match the parameter to the variable in the shader code.\n  This has to match the `binding` property of the parameter in the shader code, e.g. for the variable declaration\n\n    ```WGSL\n    @group(0) @binding(42) var<uniform> my_variable: f32;\n    ```\n\n    the `binding` property should be `42`.\n\n- **`value`**: The value of the parameter, or a string specifying a [built-in value](#webgpu-built-in-values).\n  If not a built-in value, this parameter should be an `ArrayBuffer`/`ArrayBufferView`.\n  For example, to pass in a number to an `f32` parameter, it can be constructed like `new Float32Array([myNumberValue])`.\n\n- **`storage`**: [Optional - defaults to `false`] Whether the parameter is a storage variable rather than a uniform variable.\n  This has to match the declaration in the shader code, e.g. for the variable declaration\n\n    ```WGSL\n    @group(0) @binding(0) var<uniform> my_variable: f32;\n    ```\n\n    the `storage` property should be `false` or omitted, and for\n\n    ```WGSL\n    @group(0) @binding(0) var<storage, read> my_variable: f32;\n    ```\n\n    it should be `true`.\n    Note that Svader currently only supports `var<storage, read>` and not `var<storage, read_write>`.\n\n##### WebGPU built-in values\n\nSome types of inputs are used very often. These are implemented in Svader itself, and referred to as _built-in values_.\nTo use these, the `value` property of the parameter object must be set to a string matching one of the following:\n\n- **`\"resolution\"`**: A `vec2f` of the canvas width and height in physical device pixels.\n\n- **`\"scale\"`**: An `f32` of the ratio between CSS pixels and physical device pixels, i.e. zoom level.\n  For example, if the browser has been zoomed to 150%, the `scale` parameter will be `1.5`.\n\n- **`\"time\"`**: An `f32` of the current time in seconds.\n  NOTE: Passing this parameter to the shader will cause it to rerender every frame.\n\n- **`\"offset\"`**: A `vec2f` to be added to the `@builtin(position)` of the fragment shader.\n  Sometimes the size of the canvas is limited by hardware.\n  To compensate for this, Svader creates a virtual canvas with a smaller cutout shifting around to cover the screen.\n  The `\"resolution\"` parameter is automatically adjusted to match the size of this virtual canvas, but for technical reasons,\n  the `@builtin(position)` cannot be adjusted from the outside.\n  Therefore, the `\"offset\"` parameter is provided to be manually added to these coordinates.\n\n## WebGL vs. WebGPU\n\n**For practical applications, default to using WebGL.**\n\nWebGL and WebGPU are both rendering APIs that allow web applications to render GPU-accelerated graphics.\n\nWebGL is the older of the two and is supported by [all modern browsers](https://caniuse.com/webgl).\n\nWebGPU is still in the experimental stage and is only supported in a [few browsers](https://caniuse.com/webgpu).\nHowever, it supports certain features that WebGL does not. For example, as of writing, WebGL in Google Chrome only supports having 8 canvases active in the document at once, while WebGPU supports a practically unlimited number.\n\n## License\n\nSvader is licensed under the [MIT License](https://github.com/sockmaster27/svader/blob/master/LICENSE.md).\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3883, 95],
		[3890, 74],
		[3897, 10],
		[3904, 139],
		[3911, 17],
		[3918, 141],
		[3925, 93],
		[3932, 12],
		[3939, 75],
		[3946, 25],
		[3953, 31],
		[3960, 115],
		[3967, 28],
		[3974, 5],
		[3981, 16],
		[3988, 3],
		[3995, 607],
		[4002, 169],
		[4009, 13],
		[4016, 103],
		[4023, 260],
		[4030, 315],
		[4037, 179],
		[4044, 149],
		[4051, 81],
		[4058, 208],
		[4065, 97],
		[4072, 152],
		[4079, 151],
		[4086, 84],
		[4093, 27],
		[4100, 34],
		[4107, 20],
		[4114, 29],
		[4121, 50],
		[4128, 33]
	],
	"esm": true,
	"cjs": false
}
