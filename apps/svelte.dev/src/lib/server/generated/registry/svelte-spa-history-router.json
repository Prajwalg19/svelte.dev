{
	"name": "svelte-spa-history-router",
	"description": "Implement history-based routing for Svelte single-page applications.",
	"repo_url": "https://github.com/ykrods/svelte-spa-history-router",
	"authors": ["ykrods"],
	"homepage": "https://github.com/ykrods/svelte-spa-history-router",
	"downloads": 58,
	"updated": "2025-05-01T08:33:17.109Z",
	"tags": ["router"],
	"github_stars": 9,
	"typescript": true,
	"version": "3.0.1",
	"svelte_range": ">5.0.0",
	"last_rune_check_version": "3.0.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-spa-history-router",
				"version": "3.0.1",
				"size": 17465
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# svelte-spa-history-router\n\nA history-based router for [Svelte](https://svelte.dev/) Single Page Applications (SPAs).\n\n> [!TIP]\n> Svelte's official routing library is [SvelteKit](https://svelte.dev/docs/kit/introduction). This library is designed for small or simple projects.\n\n## Features\n\n- History-Based Routing\n- Path matching and Variable Capture using regular expressions\n- Resolver for dynamic routing, code splitting, data preloading, etc.\n\n## Features *not* supported\n\n- Hash-based Routing\n- Nested router\n- Server-Side Rendering (SSR)\n\n## Install\n\n```sh\n$ npm install --save-dev svelte-spa-history-router\n$ # or\n$ yarn add svelte-spa-history-router\n```\n\n## Usage\n\nImport `Router` and include it in your main component (typically App.svelte).\n\nFor example:\n\n```html\n# App.svelte\n\n<script>\n  import { Router } from 'svelte-spa-history-router';\n\n  import Home from './Home.svelte';\n  import Article from './Article.svelte';\n  import NotFound from './NotFound.svelte';\n\n  const routes = [\n    { path: '/', component: Home},\n    { path: '/posts/(?<postId>.*)', component: Article},\n    { path: '.*', component: NotFound},\n  ];\n</script>\n<Router {routes}/>\n```\n\n* `Router` requires the `routes` parameter.\n* `routes` is a list of route objects. Each route object must have a `path` property, and either a `component` or `resolver` property.\n\n  * `path` can be a regular expression. `^` and `$` are automatically added when matching.\n  * `component` is a Svelte component. There are no specific requirements for the component.\n  * `resolver` is a function to return a dynamic component and return props of the type expected by the component.\n\n* Matching is simply performed in the order defined by `routes`.\n\n### Path variable\n\nFor routes that do not use a resolver, matched parameters are passed to the component via the `params` prop.\n\nFor example:\n\n```html\n# App.svelte\n<script>\n  import { Router } from \"svelte-spa-history-router\";\n  import ItemPage from \"./ItemPage.svelte\";\n\n  const routes = [\n    { path: \"/items/(?<itemId>\\\\d+)\", component: ItemPage },\n  ];\n</script>\n<Router {routes}/>\n```\n\n```html\n# ItemPage.svelte\n\n<script lang=\"ts\">\n  let { params }: { params: { itemId: string } } = $props();\n\n  const itemId = $derived(parseInt(params.itemId));\n</script>\n<div>\n  { itemId }\n</div>\n```\n\n### Navigation methods\n\nTo navigate to another page, `link` and `push` are available.\n\n* `link` turns an `<a>` tag into a spa navigation link. For example:\n\n```html\n<script>\n  import { link } from 'svelte-spa-history-router';\n</script>\n\n<a use:link href=\"/\">Home</a>\n```\n\n* `push` navigates to the given path programatically.\n\n```html\n<script>\n  import { push } from 'svelte-spa-history-router';\n<script>\n\n<button onclick={ () => push('/') }>Go to Home</button>\n```\n\n### resolver\n\nA resolver is a mechanism for dynamically determining which component to render. It can be used for various purposes, such as:\n\nExample: code splitting (dynamic import)\n\n```html\n<script>\n  import { Router } from 'svelte-spa-history-router';\n\n  const routes = [\n    { path: '/', resolver: () => import(\"Home.svelte\") },\n  ];\n</script>\n<Router {routes}/>\n```\n\nExample: dynamic routing and pass value to component props.\n\n```html\n<script lang=\"ts\">\n  import { Router } from 'svelte-spa-history-router';\n\n  import Article from \"./Article.svelte\";\n  import NotFound from \"./NotFound.svelte\";\n\n  async function prefetchArticle(params: Record<string, string>) {\n    const article = await getArticle(params.postId);\n    if (article) {\n      return { component: Article, props: { article } };\n    } else {\n      return NotFound;\n    }\n  }\n\n  const routes = [\n    { path: '/posts/(?<postId>.*)', resolver: prefetchArticle },\n  ];\n</script>\n<Router {routes}/>\n```\n\n> [!TIP]\n> This routing mechanism allows preloading data before rendering the component, minimizing layout flicker and improving perceived performance. While skeleton screens are a common modern pattern, this approach can simplify state handling in simple apps.\n\nExample: guard\n\n```html\n<script lang=\"ts\">\n  import { Router, redirect } from 'svelte-spa-history-router';\n\n  import Admin from \"./Admin.svelte\";\n\n\n  let user: User = $state()\n\n  function adminGuard() {\n    if (!isAdmin(user)) {\n      return redirect(\"/\");\n    }\n    return Admin;\n  }\n\n  const routes = [\n    { path: '/', component: Home },\n    { path: '/admin', resolver: adminGuard },\n  ];\n</script>\n<Router {routes}/>\n```\n\nA resolver must return one of the following types:\n\n```typescript\n| Component\n| { component: Component, props: ComponentProps }\n| Redirection // return value of `redirect()`\n| Promise<\n   | Component\n   | { component: Component, props: ComponentProps }\n   | Redirection\n   | { default: Component } // return value of `import()`\n  >\n```\n\n(Added in v2.0.0)\n\n(Changed resolver interface in v3.0.0-next.1)\n\n### currentURL()\n\nstate to detect URL changes (including query string or hash)\n\n```html\n<script>\n  import { currentURL } from \"svelte-spa-history-router\";\n\n  let name = $derived(currentURL().searchParams.get(\"name\") ?? \"unknown\");\n</script>\n<div>{ name }</div>\n```\n\n(Added in v2.1.0)\n\n(Replaced with Svelte5's `$state()` in v3.0.0-next.1)\n\n### Typing\n\nsvelte-spa-history-router provides `Route` type to check combination of component and props.\n\n```typescript\n<script lang=\"ts\">\n  import type { Route } from \"svelte-spa-history-router\"\n\n  // BlogPost requires article property\n  import type BlogPost from \"./pages/BlogPost.svelte\"\n\n  import Top from \"./pages/Top.svelte\"\n\n  const routes: [\n    Route<typeof Top>,\n    Route<typeof BlogPost | typeof NotFound>,\n  ] = [\n    { path: \"/\", component: Top },\n    {\n      path: \"/blog/posts/(?<slug>.*)\",\n      resolver: async (params: Record<\"slug\", string>) => {\n        const article = await getArticle(params.slug);\n        if (article) {\n          const component = (await import(\"./pages/BlogPost.svelte\")).default;\n          return { component, props: { article } }\n        } else {\n          return NotFound;\n        }\n      },\n    },\n  ];\n</script>\n```\n\n(Added in v3.0.0-next.1)\n\n### Full example:\n\n[example](https://github.com/ykrods/svelte-spa-history-router/tree/main/src)\n\n## ChangeLog\n\n[ChangeLog](https://github.com/ykrods/svelte-spa-history-router/tree/main/ChangeLog.md)\n\n## License\n\nMIT License.\n\n## Appendix\n\nA history-based router generally requires server-side routing to support direct links or page reloads.\n\nFor example, the following nginx configuration allows proper routing:\n\n```\nlocation / {\n    try_files $uri /index.html =404;\n}\n```\n\nIf you are considering using firebase hosting for your application, [rewrite](https://firebase.google.com/docs/hosting/full-config#rewrites) may be useful.\n\n## Inspired\n\nsvelte-spa-history-router is inspired by [svelte-spa-router](https://github.com/ItalyPaleAle/svelte-spa-router) and [Svelte Router SPA](https://github.com/jorgegorka/svelte-router).\n\nIf you don't need support for both history-based routing and regular expressions, I recommend these powerful routers.\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3596, 18],
		[3603, 59],
		[3610, 56],
		[3617, 37],
		[3624, 53],
		[3631, 32],
		[3638, 58],
		[3645, 32],
		[3652, 27],
		[3659, 23],
		[3666, 119],
		[3673, 20],
		[3680, 25],
		[3687, 21],
		[3694, 9],
		[3701, 19],
		[3708, 6],
		[3715, 74],
		[3722, 48],
		[3729, 67],
		[3736, 63],
		[3743, 66],
		[3750, 54],
		[3757, 77],
		[3764, 126],
		[3771, 122],
		[3778, 57],
		[3785, 20],
		[3792, 92],
		[3799, 191],
		[3806, 124],
		[3813, 76],
		[3820, 69],
		[3827, 85],
		[3834, 88],
		[3841, 91],
		[3848, 118],
		[3855, 91],
		[3862, 176],
		[3869, 114],
		[3876, 84],
		[3883, 91],
		[3890, 140],
		[3897, 136],
		[3904, 152],
		[3911, 107],
		[3918, 58],
		[3925, 67],
		[3932, 87],
		[3939, 84],
		[3946, 45],
		[3953, 25],
		[3960, 84],
		[3967, 45],
		[3974, 126],
		[3981, 55],
		[3988, 32],
		[3995, 60],
		[4002, 54],
		[4009, 3],
		[4016, 9],
		[4023, 193],
		[4030, 53],
		[4037, 54],
		[4044, 99],
		[4051, 81],
		[4058, 198],
		[4065, 72],
		[4072, 23],
		[4079, 25],
		[4086, 35],
		[4093, 74],
		[4100, 73],
		[4107, 61],
		[4114, 58],
		[4121, 47],
		[4128, 52],
		[4135, 121]
	],
	"esm": true,
	"cjs": false
}
