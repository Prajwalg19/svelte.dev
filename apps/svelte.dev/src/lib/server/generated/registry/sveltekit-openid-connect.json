{
	"name": "sveltekit-openid-connect",
	"description": "Protects SvelteKit applications using OpenID Connect.",
	"repo_url": "https://github.com/starbasehq/sveltekit-openid-connect",
	"authors": ["chrisogden"],
	"homepage": "https://github.com/starbasehq/sveltekit-openid-connect#readme",
	"downloads": 18,
	"updated": "2024-04-10T20:25:43.055Z",
	"tags": ["auth"],
	"github_stars": 16,
	"typescript": false,
	"version": "2.0.1",
	"kit_range": ">=1.0.0",
	"last_rune_check_version": "2.0.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "sveltekit-openid-connect",
				"version": "2.0.1",
				"size": 316419
			},
			{
				"name": "base64url",
				"version": "3.0.1",
				"size": 7548
			},
			{
				"name": "clone",
				"version": "2.1.2",
				"size": 15879
			},
			{
				"name": "cookie",
				"version": "0.6.0",
				"size": 23736
			},
			{
				"name": "futoin-hkdf",
				"version": "1.5.3",
				"size": 33079
			},
			{
				"name": "http-errors",
				"version": "1.8.1",
				"size": 18316
			},
			{
				"name": "depd",
				"version": "1.1.2"
			},
			{
				"name": "inherits",
				"version": "2.0.4",
				"size": 3958
			},
			{
				"name": "setprototypeof",
				"version": "1.2.0",
				"size": 4025
			},
			{
				"name": "statuses",
				"version": "1.5.0",
				"size": 11034
			},
			{
				"name": "toidentifier",
				"version": "1.0.1",
				"size": 4685
			},
			{
				"name": "joi",
				"version": "17.13.3",
				"size": 531117
			},
			{
				"name": "@hapi/hoek",
				"version": "9.3.0",
				"size": 51451
			},
			{
				"name": "@hapi/topo",
				"version": "5.1.0",
				"size": 10720
			},
			{
				"name": "@sideway/address",
				"version": "4.1.5",
				"size": 55851
			},
			{
				"name": "@sideway/formula",
				"version": "3.0.1",
				"size": 16939
			},
			{
				"name": "@sideway/pinpoint",
				"version": "2.0.0",
				"size": 3643
			},
			{
				"name": "jose",
				"version": "2.0.7",
				"size": 213385
			},
			{
				"name": "@panva/asn1.js",
				"version": "1.0.0",
				"size": 46838
			},
			{
				"name": "lodash",
				"version": "4.17.21",
				"size": 1412415
			},
			{
				"name": "on-headers",
				"version": "1.0.2",
				"size": 7538
			},
			{
				"name": "openid-client",
				"version": "4.9.1",
				"size": 134485
			},
			{
				"name": "got",
				"version": "11.8.6",
				"size": 269023
			},
			{
				"name": "p-cancelable",
				"version": "2.1.1",
				"size": 13542
			},
			{
				"name": "responselike",
				"version": "2.0.1",
				"size": 4685
			},
			{
				"name": "lowercase-keys",
				"version": "2.0.0",
				"size": 2781
			},
			{
				"name": "http2-wrapper",
				"version": "1.0.3",
				"size": 53109
			},
			{
				"name": "quick-lru",
				"version": "5.1.1",
				"size": 8645
			},
			{
				"name": "resolve-alpn",
				"version": "1.2.1",
				"size": 4645
			},
			{
				"name": "@sindresorhus/is",
				"version": "4.6.0",
				"size": 57457
			},
			{
				"name": "cacheable-lookup",
				"version": "5.0.4",
				"size": 23919
			},
			{
				"name": "cacheable-request",
				"version": "7.0.4",
				"size": 16750
			},
			{
				"name": "keyv",
				"version": "4.5.4",
				"size": 27751
			},
			{
				"name": "json-buffer",
				"version": "3.0.1",
				"size": 5404
			},
			{
				"name": "get-stream",
				"version": "5.2.0",
				"size": 12397
			},
			{
				"name": "pump",
				"version": "3.0.2",
				"size": 8762
			},
			{
				"name": "once",
				"version": "1.4.0"
			},
			{
				"name": "wrappy",
				"version": "1.0.2"
			},
			{
				"name": "end-of-stream",
				"version": "1.4.4",
				"size": 6234
			},
			{
				"name": "normalize-url",
				"version": "6.1.0",
				"size": 21244
			},
			{
				"name": "clone-response",
				"version": "1.0.3",
				"size": 4526
			},
			{
				"name": "mimic-response",
				"version": "1.0.1",
				"size": 3584
			},
			{
				"name": "http-cache-semantics",
				"version": "4.1.1",
				"size": 35938
			},
			{
				"name": "@types/responselike",
				"version": "1.0.3",
				"size": 4604
			},
			{
				"name": "@types/node",
				"version": "22.15.3",
				"size": 2350386
			},
			{
				"name": "undici-types",
				"version": "6.21.0",
				"size": 83680
			},
			{
				"name": "decompress-response",
				"version": "6.0.0",
				"size": 5472
			},
			{
				"name": "mimic-response",
				"version": "3.1.0",
				"size": 6003
			},
			{
				"name": "@szmarczak/http-timer",
				"version": "4.0.6",
				"size": 10824
			},
			{
				"name": "defer-to-connect",
				"version": "2.0.1",
				"size": 5444
			},
			{
				"name": "@types/cacheable-request",
				"version": "6.0.3",
				"size": 9281
			},
			{
				"name": "@types/keyv",
				"version": "3.1.4",
				"size": 6123
			},
			{
				"name": "@types/http-cache-semantics",
				"version": "4.0.4",
				"size": 9278
			},
			{
				"name": "lru-cache",
				"version": "6.0.0",
				"size": 15643
			},
			{
				"name": "yallist",
				"version": "4.0.0",
				"size": 14752
			},
			{
				"name": "make-error",
				"version": "1.3.6",
				"size": 12434
			},
			{
				"name": "object-hash",
				"version": "2.2.0",
				"size": 59029
			},
			{
				"name": "aggregate-error",
				"version": "3.1.0",
				"size": 6690
			},
			{
				"name": "clean-stack",
				"version": "2.2.0",
				"size": 5508
			},
			{
				"name": "indent-string",
				"version": "4.0.0",
				"size": 4398
			},
			{
				"name": "oidc-token-hash",
				"version": "5.1.0",
				"size": 9322
			},
			{
				"name": "url-join",
				"version": "4.0.1",
				"size": 18310
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2],
			[0, 3],
			[0, 4],
			[0, 5],
			[5, 6],
			[5, 7],
			[5, 8],
			[5, 9],
			[5, 10],
			[0, 11],
			[11, 12],
			[11, 13],
			[13, 12],
			[11, 14],
			[14, 12],
			[11, 15],
			[11, 16],
			[0, 17],
			[17, 18],
			[0, 19],
			[0, 20],
			[0, 21],
			[21, 22],
			[22, 23],
			[22, 24],
			[24, 25],
			[22, 26],
			[26, 27],
			[26, 28],
			[22, 25],
			[22, 29],
			[22, 30],
			[22, 31],
			[31, 32],
			[32, 33],
			[31, 34],
			[34, 35],
			[35, 36],
			[36, 37],
			[35, 38],
			[38, 36],
			[31, 24],
			[31, 39],
			[31, 40],
			[40, 41],
			[31, 25],
			[31, 42],
			[22, 43],
			[43, 44],
			[44, 45],
			[22, 46],
			[46, 47],
			[22, 48],
			[48, 49],
			[22, 50],
			[50, 51],
			[51, 44],
			[50, 44],
			[50, 43],
			[50, 52],
			[21, 17],
			[21, 53],
			[53, 54],
			[21, 55],
			[21, 56],
			[21, 57],
			[57, 58],
			[57, 59],
			[21, 60],
			[0, 61]
		],
		"circular": []
	},
	"readme": "# SvelteKit OpenID Connect\n\nThis is an attempt to port [express-openid-connect](https://github.com/auth0/express-openid-connect) for use with SvelteKit\n\n[![NPM version](https://img.shields.io/npm/v/sveltekit-openid-connect.svg?style=flat-square)](https://npmjs.org/package/sveltekit-openid-connect)\n\n### Open issues for questions or concerns\n\n## Table of Contents\n\n- [Documentation](#documentation)\n- [Install](#install)\n- [Getting Started](#getting-started)\n- [Contributing](#contributing)\n- [Support + Feedback](#support--feedback)\n- [Vulnerability Reporting](#vulnerability-reporting)\n- [What is Auth0](#what-is-auth0)\n- [License](#license)\n\n## Install (Pending)\n\nNode.js version **>=16.0.0** is recommended\n\n```bash\nnpm install sveltekit-openid-connect\n```\n\n## Getting Started\n\n### Initializing\n\n> svelte.config.js\n```js\nconst config = {\n\tkit: {\n\t\tcsrf: { // This is required due to a breaking change in sveltekit see https://github.com/starbasehq/sveltekit-openid-connect/issues/11\n\t\t\tcheckOrigin: false\n\t\t}\n\t}\n}\n```\n\n> src/hooks.server.js\n\n```js\nimport * as cookie from 'cookie'\nimport { TokenUtils } from 'sveltekit-openid-connect'\nimport { SessionService } from '$lib/services' // This is a service that provides session storage, not a part of this package\nimport fetch from 'node-fetch'\n\nconst {\n    AUTH0_DOMAIN,\n    AUTH0_BASE_URL,\n    AUTH0_CLIENT_ID,\n    AUTH0_CLIENT_SECRET,\n    COOKIE_SECRET,\n    AUTH0_AUDIENCE,\n\tCSRF_ALLOWED\n} = process.env\n\nconst csrfAllowed = [`https://${AUTH0_DOMAIN}`, ...(CSRF_ALLOWED || '').split(',').filter(Boolean)]\n\nconst sessionName = 'sessionName'\nconst auth0config = {\n    attemptSilentLogin: true,\n    authRequired: false,\n    auth0Logout: true, // Boolean value to enable Auth0's logout feature.\n    baseURL: AUTH0_BASE_URL,\n    clientID: AUTH0_CLIENT_ID,\n    issuerBaseURL: `https://${AUTH0_DOMAIN}`,\n    secret: COOKIE_SECRET,\n    clientSecret: AUTH0_CLIENT_SECRET,\n    authorizationParams: {\n        scope: 'openid profile offline_access email',\n        response_type: 'code id_token',\n        audience: AUTH0_AUDIENCE\n    },\n    session: {\n        name: 'sessionName', // Replace with custom session name\n        cookie: {\n            path: '/'\n        },\n        absoluteDuration: 86400,\n        rolling: false,\n        rollingDuration: false\n    }\n}\n\n// This was added to support decrypting the encrypted session cookies we utilized\nconst tokenUtils = new TokenUtils(auth0config)\n\nexport async function handle ({ event, resolve }) {\n\tconst { forbidden: forbidCSRF, response: responseCSRF } = checkCSRF(event.request)\n\tif (forbidCSRF) return responseCSRF\n    try {\n        const request = event.request\n        event.locals.isAuthenticated = false\n        const cookies = cookie.parse(request.headers.get('cookie') || '')\n        const { url, body, params } = request\n        const path = url.pathname\n        const query = url.searchParams\n        let sessionCookie\n\n\t\tlet sessionValid = false\n\t\tlet session = {}\n\t\tif (cookies.session_id) event.locals.sessionId = cookies.session_id\n        try {\n\t\t\tif (event.cookies.get('session_id') && event.cookies.get(sessionName)) {\n\t\t\t\tconst cookieToken = event.cookies.get(sessionName)\n\t\t\t\tsession = await sessionService.get(cookies.session_id, cookieToken)\n\t\t\t\ttry {\n\t\t\t\t\tif (tokenUtils.isExpired(cookieToken)) {\n\t\t\t\t\t\tconsole.warn('Token is expired, try to renew')\n\t\t\t\t\t\t// TODO: Needs Testing\n\t\t\t\t\t\t// TODO: Support refresh tokens?\n\t\t\t\t\t\treturn Response.redirect(`/auth/login?returnTo=${event.url.pathname}`, 401)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst idToken = tokenUtils.getIdToken({ token: cookieToken })\n\t\t\t\t\t\tconst sToken = session.data\n\t\t\t\t\t\tif (sToken.exp < idToken.exp) {\n\t\t\t\t\t\t\tconsole.debug('Cookie is Newer, update session')\n\t\t\t\t\t\t\t// Update session from your session service\n\t\t\t\t\t\t\tawait session.save()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sToken.sub === idToken.sub && sToken.iss === idToken.iss) {\n\t\t\t\t\t\t\tconsole.info('Cookie and Session match')\n\t\t\t\t\t\t\tsessionValid = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('Cookie and Session failed to match, do something')\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.info('Token is valid, not expired')\n\t\t\t\t\t}\n\t\t\t\t} catch (tErr) {\n\t\t\t\t\tconsole.trace(tErr)\n\t\t\t\t}\n\n\t\t\t\tevent.locals.sessionId = cookies.session_id\n\n\t\t\t\tif (session) {\n                    // assign session information to event.locals here\n                    /*\n                        event.locals.user = session.data.user\n                    */\n                }\n            } else {\n                console.warn('No session found, better send to auth')\n\t\t\t\t// perform sveltekit redirect\n            }\n        } catch (err) {\n            console.error('problem getting app session', err.message)\n            // perform sveltekit redirect\n        }\n\n        const response = await resolve(request) // This is required by sveltekit\n\n        // Optional: add the session cookie\n        if (sessionCookie) {\n            const existingCookies = (response.headers && response.headers.get('set-cookie')) ? response.headers.get('set-cookie') : []\n            response.headers.set('set-cookie', [...existingCookies, sessionCookie])\n        }\n\n        return response\n    } catch (err) {\n        console.error('Problem running handle', err.message)\n    }\n}\n\nexport async function getSession (event) {\n    // This has been deprecated in sveltekit, it is safe to delete, it is moved to +layout.server.js\n}\n\n// This is required due to sveltekit changes see https://github.com/starbasehq/sveltekit-openid-connect/issues/11\nfunction checkCSRF (request) {\n\tconst url = new URL(request.url)\n\tconst type = request.headers.get('content-type')?.split(';')[0]\n\tconst forbidden =\n\t\trequest.method === 'POST' &&\n\t\t!_.includes([url.origin, ...csrfAllowed], request.headers.get('origin')) &&\n\t\t(type === 'application/x-www-form-urlencoded' || type === 'multipart/form-data')\n\n\tif (forbidden) {\n\t\tconsole.warn('Prevent CSRF')\n\t\tconst response = new Response(`Cross-site ${request.method} form submissions are forbidden`, {\n\t\t\tstatus: 403\n\t\t})\n\t\treturn { forbidden, response }\n\t} else {\n\t\treturn { forbidden, response: null }\n\t}\n}\n```\n\n> src/routes/+layout.server.js\n\n```js\nexport async function load ({ locals }) {\n\treturn {\n\t\tsession: {\n\t\t\tisAuthenticated: locals.isAuthenticated,\n\t\t\tsessionId: locals.sessionId,\n\t\t\tuser: locals.user\n\t\t}\n\t}\n}\n```\n\n### Logging in\n\nThe endpoint route can be different but must be changed in the config block for routes\n> src/routes/auth/login/+server.js\n\n```js\nimport { Auth } from 'sveltekit-openid-connect'\n\nconst {\n    AUTH0_DOMAIN,\n    AUTH0_BASE_URL,\n    AUTH0_CLIENT_ID,\n    AUTH0_CLIENT_SECRET,\n    COOKIE_SECRET,\n    AUTH0_AUDIENCE\n} = process.env\n\nconst auth0config = {\n    attemptSilentLogin: true,\n    authRequired: false,\n    auth0Logout: true, // Boolean value to enable Auth0's logout feature.\n    baseURL: AUTH0_BASE_URL,\n    clientID: AUTH0_CLIENT_ID,\n    issuerBaseURL: `https://${AUTH0_DOMAIN}`,\n    secret: COOKIE_SECRET,\n    clientSecret: AUTH0_CLIENT_SECRET,\n    authorizationParams: {\n        scope: 'openid profile offline_access email groups permissions roles',\n        response_type: 'code id_token',\n        audience: AUTH0_AUDIENCE\n    },\n    routes: {\n        login: '/auth/login',\n        logout: '/auth/logout',\n        callback: '/auth/callback'\n    }\n}\n\nconst auth0 = new Auth(auth0config)\n\nexport async function get ({ request }, ...otherProps) {\n    const loginResponse = await auth0.handleLogin()\n\n\treturn new Response(JSON.stringify({}), {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tlocation: loginResponse.authorizationUrl,\n\t\t\t'Set-Cookie': loginResponse.cookies\n\t\t}\n\t})\n}\n```\n\n### Handling the callback\n\nThe endpoint route can be different but must be changed in the config block for routes\n> src/routes/auth/callback/+server.js\n\n```js\nimport _ from 'lodash'\nimport * as cookie from 'cookie'\nimport { Auth, appSession } from 'sveltekit-openid-connect'\nimport mock from 'mock-http'\nimport { SessionService } from '$lib/services'\n\nconst sessionService = new SessionService()\n\nconst {\n    AUTH0_DOMAIN,\n    AUTH0_BASE_URL,\n    AUTH0_CLIENT_ID,\n    AUTH0_CLIENT_SECRET,\n    COOKIE_SECRET,\n    AUTH0_AUDIENCE\n} = process.env\n\nconst auth0config = {\n    attemptSilentLogin: true,\n    authRequired: false,\n    auth0Logout: true, // Boolean value to enable Auth0's logout feature.\n    baseURL: AUTH0_BASE_URL,\n    clientID: AUTH0_CLIENT_ID,\n    issuerBaseURL: `https://${AUTH0_DOMAIN}`,\n    secret: COOKIE_SECRET,\n    clientSecret: AUTH0_CLIENT_SECRET,\n    authorizationParams: {\n        scope: 'openid profile offline_access email',\n        response_type: 'code id_token',\n        audience: AUTH0_AUDIENCE\n    },\n    session: {\n        name: 'sessionName',\n        cookie: {\n            path: '/'\n        },\n        absoluteDuration: 86400,\n        rolling: false,\n        rollingDuration: false\n    }\n}\n\nconst auth0 = new Auth(auth0config)\n\nexport async function post ({ request }) {\n    const { headers } = request\n    const body = await request.formData()\n    const cookies = cookie.parse(headers.get('cookie') || '')\n    if (_.isObject(cookies)) {\n        const req = new mock.Request({\n            url: request.url,\n            method: 'POST',\n            headers,\n            buffer: Buffer.from(JSON.stringify({\n                code: body.get('code'),\n                state: body.get('state'),\n                id_token: body.get('id_token')\n            }))\n        })\n        req.cookies = cookies\n        req.body = {\n            code: body.get('code'),\n            state: body.get('state'),\n            id_token: body.get('id_token')\n        }\n\n        const res = new mock.Response()\n\n        const authResponse = await auth0.handleCallback(req, res, cookies)\n        const session = await appSession(auth0config)(req, res, authResponse.session)\n\n\t\t// Optional to allow restoring an existing session\n\t\tconst rReturn = new URL(authResponse.redirect.returnTo)\n\t\tlet sessionId = cookies['session_id'] || rReturn.searchParams.get('sid')\n\t\tlet sessionRestored = false\n\t\tlet sessionCookie\n\n\t\tif (sessionId) {\n\t\t\tconst restoredSession = await sessionService.restoreSession(sessionId, authResponse.session)\n\t\t\tif (restoredSession.ok) {\n\t\t\t\tsessionRestored = true\n\t\t\t}\n\t\t}\n\n\t\tif (!sessionRestored) {\n\t\t\tconst newSession = await sessionService.createSession(authResponse.session)\n\t\t\tsessionId = newSession.sessionId\n\t\t\tsessionCookie = cookie.serialize('session_id', sessionId, {\n\t\t\t\thttpOnly: true,\n\t\t\t\tmaxAge: 60 * 60 * 24 * 30,\n\t\t\t\tsameSite: 'lax',\n\t\t\t\tpath: '/'\n\t\t\t})\n\t\t}\n\n        return new Response(JSON.stringify({\n\t\t\terror: false\n\t\t}), {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tlocation: '/',\n\t\t\t\t'set-cookie': _.concat(authResponse.cookies, session.cookies, sessionCookie).filter(Boolean)\n\t\t\t}\n\t\t})\n    } else {\n\t\treturn new Response(JSON.stringify({\n\t\t\terror: true\n\t\t}))\n\t}\n}\n\n```\n\n### Destroying the Session\n\n> src/routes/auth/logout/+server.js\n\n```js\nimport * as cookie from 'cookie'\nimport { Auth } from 'sveltekit-openid-connect'\nimport mock from 'mock-http'\n\nconst {\n    AUTH0_DOMAIN,\n    AUTH0_BASE_URL,\n    AUTH0_CLIENT_ID,\n    AUTH0_CLIENT_SECRET,\n    COOKIE_SECRET,\n    AUTH0_AUDIENCE\n} = process.env\n\nconst auth0config = {\n    attemptSilentLogin: true,\n    authRequired: false, // Require authentication for all routes.\n    auth0Logout: true, // Boolean value to enable Auth0's logout feature.\n    baseURL: AUTH0_BASE_URL,\n    clientID: AUTH0_CLIENT_ID,\n    issuerBaseURL: `https://${AUTH0_DOMAIN}`,\n    secret: COOKIE_SECRET,\n    clientSecret: AUTH0_CLIENT_SECRET,\n    authorizationParams: {\n        scope: 'openid profile offline_access email groups permissions roles',\n        response_type: 'code id_token',\n        audience: AUTH0_AUDIENCE\n    },\n    session: {\n        name: 'sessionName',\n        cookie: {\n            path: '/'\n        },\n        absoluteDuration: 86400,\n        rolling: false,\n        rollingDuration: false\n    },\n    routes: {\n        login: '/auth/login',\n        logout: '/auth/logout',\n        callback: '/auth/callback'\n    }\n}\n\nconst auth0 = new Auth(auth0config)\n\nexport async function get ({ locals, request }) {\n    const { headers } = request\n    const cookies = cookie.parse(headers.get('cookie') || '')\n\n    const res = new mock.Response()\n    const logoutResponse = await auth0.handleLogout(request, res, cookies, Object.assign(locals))\n\n\t// Optional, remove this if you want to support restoring previous session\n    const sessionCookie = cookie.serialize('session_id', 'deleted', {\n        httpOnly: true,\n        expires: new Date(),\n        sameSite: 'lax',\n        path: '/'\n    })\n\n    return new Response(JSON.stringify({}), {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tlocation: logoutResponse.returnURL,\n\t\t\t'Set-Cookie': [...logoutResponse.cookies]\n\t\t}\n\t})\n}\n```\n\n### Sample Session Service\n\n> src/lib/services/session.js\n\n```js\nimport { jwtDecode } from 'jwt-decode'\nimport { v4 as uuidv4 } from 'uuid'\nimport DB from './db' // Custom database service using sequelize\nimport UserService from './user'\n\nconst db = new DB()\nconst userService = new UserService()\n\nclass SessionService {\n    async createSession (authSession) {\n        const sqldb = await db.getDatabase()\n        const sessionId = uuidv4()\n        const session = await jwtDecode(authSession.id_token)\n        console.log('Create Session', session)\n\n        // enrich with raw oidc session data\n        session.oidc = authSession\n\n        const { email, sub } = session\n        const [identitySource, userIdentifier] = sub.split('|')\n        const userData = {\n            identitySource,\n            userIdentifier,\n            email,\n            user_id: sub\n        }\n\n        const userProfile = await userService.get(userData)\n\n        const { UserId, ...other } = userProfile\n\n        session.UserId = UserId\n        session.user = {}\n        session.user.other = other\n\n        const [sessionStore, created] = await sqldb.SessionStore.findOrCreate({\n            where: {\n                sessionId\n            },\n            defaults: {\n                data: session,\n                sessionId,\n                UserId\n            }\n        })\n\n        if (created) {\n            console.log('Created SessionStore', sessionStore._id)\n        }\n\n        return { sessionId, session: sessionStore }\n    }\n\n    async get (sessionId) {\n        const session = await getSession(sessionId)\n\n        return session\n    }\n\n    async decodeJwt (jwt) {\n        return jwtDecode(jwt)\n    }\n\n\tasync restoreSession (sessionId, authSession) {\n\t\tconst rSession = await getSession(sessionId)\n\n\t\tif (!rSession) return { ok: false }\n\n\t\tconst session = await jwtDecode(authSession.id_token)\n\n\t\t// enrich with raw oidc session data\n\t\tsession.oidc = authSession\n\n\t\tconst { email, sub } = session\n\t\tconst [identitySource, userIdentifier] = sub.split('|')\n\t\tconst userData = {\n\t\t\tidentitySource,\n\t\t\tuserIdentifier,\n\t\t\temail,\n\t\t\tuser_id: sub\n\t\t}\n\n\t\tif (session.sub !== rSession.data.sub) {\n\t\t\tconsole.info(`Session is not for authed User ${session.sub} vs ${rSession.data.sub}`)\n\t\t\treturn { ok: false }\n\t\t}\n\n\t\tconst userProfile = await userService.get(userData)\n\n\t\tconst { orgs, projects } = userProfile\n\t\tsession.user = {}\n\t\tsession.user.orgs = orgs || []\n\t\tsession.user.projects = projects || []\n\n\t\ttry {\n\t\t\trSession.data = Object.assign(rSession.data, session)\n\t\t\trSession.changed('data', true)\n\n\t\t\tawait rSession.save()\n\t\t\treturn { ok: true }\n\t\t} catch (e) {\n\t\t\tconsole.error(e.message)\n\t\t\treturn { ok: false }\n\t\t}\n\t}\n}\n\nasync function getSession (sessionId) {\n    const sqldb = await db.getDatabase()\n    const session = await sqldb.SessionStore.findOne({\n        where: {\n            sessionId\n        }\n    })\n\n    return session\n}\n\nexport default SessionService\n```\n\n> src/lib/services/db.js\n\n```js\nimport _ from 'lodash'\nimport orm from '<<sequelize orm project>>'\n\nconst config = {\n    sequelize: {\n        // eslint-disable-next-line dot-notation\n        sync: process.env['DB_SYNC'],\n        // eslint-disable-next-line dot-notation\n        syncForce: process.env['DB_SYNC_FORCE'],\n        // eslint-disable-next-line dot-notation\n        database: process.env['DB_DATABASE'] ,\n        // eslint-disable-next-line dot-notation\n        host: process.env['DB_HOST'] || '127.0.0.1',\n        // eslint-disable-next-line dot-notation\n        port: process.env['DB_PORT'],\n        // eslint-disable-next-line dot-notation\n        username: process.env['DB_USERNAME'],\n        // eslint-disable-next-line dot-notation\n        password: process.env['DB_PASSWORD'],\n        // eslint-disable-next-line dot-notation\n        dbDefault: process.env['DB_DEFAULT'] || 'postgres',\n        dialectOptions: {\n            // eslint-disable-next-line dot-notation\n            ssl: process.env['DB_SSL'] === 'true'\n        }\n    }\n}\n\nconst sqldb = orm(config)\nclass DatabaseService {\n    async getDatabase () {\n        return sqldb\n    }\n}\nexport default DatabaseService\n```\n\n> src/lib/services/user.js\n\n```js\nimport _ from 'lodash'\nimport DB from './db'\n\nconst db = new DB()\n\nclass UserService {\n    async get (userData) {\n        const sqldb = await db.getDatabase()\n\n        const [user, created] = await sqldb.User.findOrCreate({\n            where: {\n                email: userData.email\n            },\n            defaults: userData\n        })\n\n        if (!created) {\n            if (!user.userIdentifier) {\n                await updateUserAttributes(user, userData)\n            }\n            console.debug('Existing User')\n            return {\n                UserId: user._id\n            }\n        } else {\n            console.debug('created new user', JSON.stringify(user, null, 2))\n            return {\n                UserId: user._id\n            }\n        }\n    }\n}\n\nasync function updateUserAttributes (user, aUser) {\n    const identitySource = (aUser.identitySource) ? aUser.identitySource : aUser.identities[0].provider // TODO: should we always assume 0?\n    const userIdentifier = (aUser.userIdentifier) ? aUser.userIdentifier : aUser.identities[0].user_id // TODO: should we always assume 0?\n\n    user.identitySource = identitySource\n    user.userIdentifier = userIdentifier\n    user.user_id = aUser.user_id\n    await user.save()\n}\n\nexport default UserService\n```\n\n\n## Contributing\n\nWe appreciate feedback and contribution to this repo! Before you get started, please see the following:\n\nContributions can be made to this library through PRs to fix issues, improve documentation or add features. Please fork this repo, create a well-named branch, and submit a PR with a complete template filled out.\n\nCode changes in PRs should be accompanied by tests covering the changed or added functionality. Tests can be run for this library with:\n\n```bash\nnpm install\nnpm test\n```\n\nWhen you're ready to push your changes, please run the lint command first:\n\n```bash\nnpm run lint\n```\n\n## Support + Feedback\n\nPlease use the [Issues queue](https://github.com/starbasehq/sveltekit-openid-connect/issues) in this repo for questions and feedback.\n\n## What is Auth0?\n\nAuth0 helps you to easily:\n\n- implement authentication with multiple identity providers, including social (e.g., Google, Facebook, Microsoft, LinkedIn, GitHub, Twitter, etc), or enterprise (e.g., Windows Azure AD, Google Apps, Active Directory, ADFS, SAML, etc.)\n- log in users with username/password databases, passwordless, or multi-factor authentication\n- link multiple user accounts together\n- generate signed JSON Web Tokens to authorize your API calls and flow the user identity securely\n- access demographics and analytics detailing how, when, and where users are logging in\n- enrich user profiles from other data sources using customizable JavaScript rules\n\n[Why Auth0?](https://auth0.com/why-auth0)\n\n## License\n\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3596, 22],
		[3603, 23],
		[3610, 35],
		[3617, 9],
		[3624, 6],
		[3631, 7],
		[3638, 6],
		[3645, 10],
		[3652, 4],
		[3659, 11],
		[3666, 27],
		[3673, 8],
		[3680, 5],
		[3687, 19],
		[3694, 32],
		[3701, 14],
		[3708, 5],
		[3715, 28],
		[3722, 11],
		[3729, 30],
		[3736, 6],
		[3743, 71],
		[3750, 126],
		[3757, 45],
		[3764, 22],
		[3771, 39],
		[3778, 14],
		[3785, 23],
		[3792, 10],
		[3799, 7],
		[3806, 11],
		[3813, 6],
		[3820, 7],
		[3827, 6],
		[3834, 17],
		[3841, 39],
		[3848, 18],
		[3855, 57],
		[3862, 13],
		[3869, 7],
		[3876, 7],
		[3883, 4],
		[3890, 37],
		[3897, 3],
		[3904, 2],
		[3911, 4],
		[3918, 14],
		[3925, 9],
		[3932, 11],
		[3939, 10],
		[3946, 5],
		[3953, 8],
		[3960, 5],
		[3967, 9],
		[3974, 24],
		[3981, 10],
		[3988, 1],
		[3995, 20],
		[4002, 3],
		[4009, 1],
		[4016, 44],
		[4023, 16],
		[4030, 4],
		[4037, 11],
		[4044, 17],
		[4051, 7],
		[4065, 3],
		[4072, 16],
		[4079, 14],
		[4086, 3],
		[4100, 61],
		[4107, 4],
		[4114, 18],
		[4121, 21],
		[4128, 16],
		[4135, 14]
	]
}
