{
	"name": "svelte-htable",
	"description": "Generate hierarchical tables from hierarchical data in Svelte.",
	"repo_url": "https://github.com/webJose/svelte-htable",
	"authors": ["webjose"],
	"homepage": "https://github.com/webJose/svelte-htable#readme",
	"downloads": 8,
	"updated": "2023-04-12T19:29:33.643Z",
	"tags": ["ui"],
	"github_stars": 0,
	"typescript": true,
	"version": "0.1.0",
	"svelte_range": "^3.54.0",
	"kit_range": "1.6.0",
	"last_rune_check_version": "0.1.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-htable",
				"version": "0.1.0",
				"size": 42873
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# svelte-htable\n\nThis is a hierarchical table component for Svelte.  This means that it is a table that may be provided with items that \ncontain items, and said contained items need to be displayed as a sub-table.  The process can be repeated, producing \nan arbitrary amount of nested tables.  An image is worth a thousand words:\n\n![svelte-htable example](example.png)\n\nThe styling shown in the example is not provided in the component itself.  It must be provided by assigning a CSS \nclass to the table or by styling the `<table>` element and its sub-elements (`<th>`, `<td>`, etc).  Inner tables \ninherit any CSS classes that are applied to the parent, but further styling can be applied down the sub tables.  See \nthe [Styling the Table](#styling-the-table) section of this ReadMe for details on the matter.\n\n## Features\n\n1. It is a recursive component.\n2. Sub-tables can show a path and a level on top of it (this uses the table's `<caption>` element).\n3. Sub-tables can be targetted for further styling.\n4. It can group items so all items with sub-items are grouped together either before or after the items with no \nsub-items.\n5. The summary of the elements with sub-items can be specified freely using either the value of a property, \nusing completely arbitrary logic via a function, or creating HTML markup using the `summary` slot.\n6. The path in sub-tables can be generated by the value of a property or by using a function.\n7. Column data can be rendered using the `datacell` slot to allow for complex HTML content.\n8. If needed, the entire row can be freely designed using the `datarow` slot.\n8. Column definitions allow the definition of a `renderValue()` function to easily control data formatting or support \ncomputed columns.\n\n## Quickstart\n\nInstall the package:\n\n```bash\nnpm i svelte-htable\n```\n\nNow use it as `<Htable />` in a page or component.  The following example is in *TypeScript* to show how to extend the \n`Item` type to have Intellisense.  This is optional, as all of TypeScript.  Feel free to use JavaScript if you want.\n\n**NOTE**:  This is an example use in a Svelte page (it receives the data from its `load()` function).\n\n```ts\n<script lang=\"ts\">\n    import\n        Htable, { // Table component.\n        CaptionOrder, // Enumeration to control the order of the data in captions.\n        ItemGrouping, // Enumeration to control the item grouping behavior.\n        type Column, // TypeScript type.  It represents a single table column definition.\n        type Item, // Base TypeScript item type.  Extend this type as shown below.\n    } from \"svelte-htable\";\n\n    interface DataItem extends Item {\n        first_name: string;\n        last_name: string;\n        email: string;\n        gender: string;\n        country_code: string;\n        manager_id: number;\n    }\n    // This page expects the data to be provided through its load() function (Svelte stuff).\n    export let data: { data: DataItem[] };\n    // Define your table columns.\n    const columns: Column[] = [\n        {\n            key: \"id\", // property name in the JS object\n            title: \"ID\", // title shown in the column header\n        },\n        {\n            key: \"first_name\",\n            title: \"First Name\",\n        },\n        {\n            key: \"last_name\",\n            title: \"Last Name\",\n        },\n        {\n            key: \"birth_date\",\n            title: \"Birth Date\",\n            renderValue: (i, k) => new Date(i[k]).toLocaleDateString(), // Date formatting\n        },\n        {\n            key: \"age\", // Computed column.\n            title: \"Age\",\n            renderValue: (i, k) => {\n                const diff = Date.now() - Date.parse(i.birth_date);\n                return Math.floor(\n                    diff / (365 * 24 * 60 * 60 * 1000)\n                ).toString();\n            },\n        },\n        {\n            key: \"gender\",\n            title: \"Gender\",\n        },\n        {\n            key: \"country_code\",\n            title: \"Country Code\",\n        },\n        {\n            key: \"manager_id\",\n            title: \"Manager's ID\",\n        },\n    ];\n</script>\n<!-- Now use the component. -->\n<Htable\n    items={data.data}\n    {columns}\n    level={true}\n    showPath={true}\n    summary={(i) => `${i.last_name}, ${i.first_name}`}\n    pathSegment={(i) => i.last_name}\n    pathSeparator=\" > \"\n    maxPathSegmentLength={10}\n/>\n```\n\nFirst import the Htable component, and if you need to, also import the `CaptionOrder` and the `ItemGrouping` \nenumerations, which are used to control the order of things in sub-tables' captions as well as item ordering in the \ntables (not shown in the example).\n\n> **IMPORTANT**  This quickstart example will come out without styles.  It is up to you to provide the needed styling.\n\n## Required Data Structure\n\nIf you haven't realized yet, your data needs to follow a specific structure.  Each item is expected to have `id` and \n`subItems` properties as per the definition of the `Item` data type.  Data items with a non-empty array in their \n`subItems` property will generate a sub-table whose rows will be generated from the data items found in said array.\n\n## Styling the Table\n\nThere are two ways to style the tables generated by `svelte-htable`.  The most straightforward approach would be to \ntarget the `<table>` element using a regular CSS file (so the classes are not scoped to a component), or a Svelte \npage/component file using `:global()` to avoid Svelte from scoping the CSS.  Then the table automatically picks the \nstyles up as per the usual CSS rules.\n\nThe second way is to apply a CSS class to the component, declaring its styles either in a regular CSS file or a Svelte \npage/component file with `:global()`.  I would say this is probably the saner option because most likely you don't \nwant to target other tables in your project by mistake.\n\nThis should cover the basics for styling, but the component allows finer targetting of its internal parts.\n\n### Styling Sub-Tables\n\nAll sub-tables are decorated with the `sub` CSS class and also inherit the parent's CSS class.  This means that one \ncan write CSS selectors of the form `table.sub`|`table.someClass.sub` (or `:global(table.sub|table.someClass.sub)`) to \nonly target sub-tables.  The screenshot shown in this ReadMe used this technique to apply sub-tables a different text \ncolor.  Something like this:\n\n```css\ntable.data {\n    /* Main table and sub-tables obtain this background color because they all inherit the data class. */\n    background-color: darkblue;\n}\n\n/* But wait!  We want a different background color for sub-tables. */\ntable.data.sub {\n    background-color: darkgreen;\n}\n```\n\n> **NOTE**:  I hope those color names exist! :-)\n\nThis CSS will grant the main table a dark blue background, while sub-tables will gain a dark green background.\n\nBut maybe this is not good enough.  Maybe we want alternating background colors.  No problem.  Sub-tables also get \neither the `sub-odd` or `sub-even` CSS classes depending on whether their level is odd or even.  This can be used to \naccomplish alternating per-table styling.  The image shown at the beginning was created using these clases to apply \nalternating greenish backgrounds to sub-tables.  Hopefully this doesn't need an example?  I'll just mention a sample \nCSS selector:  `table.data.sub.sub-odd`.\n\nFinally, the `sub-X` CSS class is applied to the tables, where `X` is the table's level.  The main table is level 1, \nwhile all immediate sub-tables are level 2.  The main table has no extra CSS classes; the immediate sub-tables will \nhave the `sub` and `sub-2` CSS classes.  This CSS class should help you style exact-level tables.\n\n### Styling Sub-Table Captions\n\nSub-tables can show a caption on top with up to two pieces of information:  The table's level and the item's **path** \nvalue.  Since this is a table that displays hierarchical data, the concept of a path should be natural, and this is \nwhat is meant to be shown in the table's caption.  See the next section for information about this and other features.\n\nThe table's caption (a `<caption>` HTML element) is made up of two `<span>` elements inside an inline-flexed `<span>` \nelement.  Each of these are assigned a CSS class based on their position.  The one to the left has the `cpt-l` CSS \nclass; the one to the right, `cpt-r`.  Use these classes to style the pieces of information shown in the caption.\n\n> **NOTE**:  What's shown to the left or the right depends on the value of the `captionOrder` prop as explained in the \nnext section.\n\n### Styling Expansibles\n\nThe expansibles are `<details>` HTML elements.  As per their usage, what is shown when the contents are collapsed is \ninside a `<summary>` HTML element.  You may style by targetting this element.  This is an example CSS that assumes the \ntables have been applied the `data` CSS class:\n\n```css\ntable.data details > summary {\n    /* Add the CSS for what is visible when the elements are collapsed. */\n}\n```\n\nThis `<details>` element spans all table columns.  The row that contains the element is further applied a `sub` CSS \nclass to help styling.  An equivalent to the above could be:\n\n```css\ntable.data tr.sub details > summary {\n    /* Add the CSS for what is visible when the elements are collapsed. */\n}\n```\n\nThis is more specific than the previous example, so this should help in case specificity comes into play.\n\n### Styling Data Rows\n\nThe most common need is to style a table's rows in an alternating fashion.  `svelte-htable` covers this case by adding \neither the `odd` or `even` CSS class to every row in the `<tbody>` element of the table.  Style targetting these CSS \nclasses.\n\n## Htable's Props\n\nThe following is the complete list of supported props:\n\n| Property | Type | Description | Example |\n| - | - | - | - |\n| `columns` | `Column[]` | Required.  Column definitions. | `[{ key: 'id', name: 'ID'}]` |\n| `items` | `Item[]` | Required.  Data items. | `[{ id: 1, name: 'John', subItems: [{ id: 2, name: 'Clara' }]}]` |\n| `class` | String | Optional.  Used to apply CSS class(es). | `\"my-css-data-table\"` |\n| `level` | `boolean \\| ((level: number) => string)` | Optional.  When using a Boolean value, it shows or hides the level in caption; when providing a function, it is used to create what shows up as **Level** in the caption. | `true`; `l => 'Level: ' + l` |\n| `showPath` | Boolean | Optional (defaults to `false`).  Set to true to show the sub-tables' paths in their captions. | `true` |\n| `pathSeparator` | String | Optional (defaults to `'.'`).  Divider used to join path segments to create sub-tables' paths. | `' > '` |\n| `captionOrder` | Number (`CaptionOrder`) | Optional (defaults to `CaptionOrder.PathLevel`).  Specifies which data goes where in sub-tables' captions. | `CaptionOrder.LevelPath` |\n| `grouping` | Number (`ItemGrouping`) | Optional (defaults to `ItemGrouping.ExpansiblesFirst`).  Specifies how to group data items based on the existence of sub-items in them. | `ItemGrouping.ExpansiblesLast` |\n| `summary` | `string \\| ((item: Item) => string)` | Optional.  Used to control what is shown as the expansible item's summary. | `i => i.name` |\n| `pathSegment` | `string \\| ((item: Item) => string)` | Optional.  Used to define sub-tables' paths. | `i => i.employeeId` |\n| `maxPathSegmentLength` | Number | Optional.  If specified, path segments that exceed this length will be truncated. | `10` |\n| `initialOpenLevel` | Number | Optional (defaults to 1).  Assign a number greater than one to expand items with tables equal or less than the specified number. | 5 (will show table levels 2 through 5 as open) |\n| `nullText` | String | Optional (defaults to `(---)`).  Sets the representation of null property values used by the default value-rendering function. | `'(null)'` |\n\n## Caption-Related Props\n\nA sub-table's caption may display up to two pieces of data:  The sub-table's level and path.  One can specify on which \nside of the caption each value appears using the `captionOrder` prop, and whether or not they appear using the `level` \nand `showPath` props.\n\nThe `captionOrder` prop accepts any value of the `CaptionOrder` enumeration:\n\n| Name | Numerical Value | Description |\n| - | - | - |\n| `PathLevel` | 1 | The sub-tables' captions will show the table's path to the left and the table's level to the right. |\n| `LevelPath` | 2 | The sub-tables' captions will show the table's level to the left and the table's path to the right. |\n\n### About Path\n\nA sub-table's path is automatically constructed by using the data item's first property as defined by the column \ndefinitions, unless the `pathSegment` prop is specified with either a data item's property name, or a function that \ntakes the data item as function argument and returns the actual path segment value to use.  Each path segment is \njoined with other segments using the value of the `pathSeparator` prop.  If not specified, the default path separator \nis a period (`.`).  Any string can be used as path separator, but since the sub-table's caption's real estate is very \nlimited, try not to use long separators.\n\nBecause of this limited real estate in captions, and most likely because your data will be dynamic in nature and \ntherefore unpredictable, this component allows the specification of a maximum path segment length to help prevent \noverrunning the available space for both the level and the path data.  It works like this:  A path segment's value is \nobtained and measured against the value specified in the `maxPathSegmentLength` prop.  If the length exceeds the \nspecification, then the path segment is truncated and ellipsis (`...`) is added at the end, so that the combined \nlength is equal to `maxPathSegmentLength`.\n\nThe value of `maxPathSegmentLength` must be greater than 2.  The component doesn't check this in runtime; you'll just \nsee an error if you go below this value.\n\n### About Level\n\nThe level is just a measure of how deep the data has gone in terms of recursion.  The top table is level 1, and as \ntables are recursively created, the level is increased by one.  Tables with a level greater than one are called \nsub-tables and are granted special CSS classes as seen in the [Styling the Table](#styling-the-table) section.\n\nSince the table can be used to display text in any language, `svelte-htable` cannot possibly add any text to the \nlabel by itself.  So, in order to be able to display a simple string like `Level: 2`, you must provide a function \nvia the `level` prop.  Sure, you can just set `level={true}` and the level is displayed, but it will only display \nthe number, which turns out to be uninformative.  Still, the use of this prop is simple enough:\n\n```ts\n<Htable {columns} {items} level={l => `Level: ${l}`} />\n```\n\nThis does the simple trick of outputting the level labeled with the word **Level**.\n\n## Grouping Items\n\nIt may be desirable to rearrange the tables' rows according to their nature (expansible vs. non-expansible), so this \ncomponent exposes the `grouping` prop.  This prop accepts any value of the `ItemGrouping` enumeration.\n\n| Name | Numerical Value | Description |\n| - | - | - |\n| `Undefined` | 0 | The provided data items will be presented in the order they were provided. |\n| `ExpansiblesFirst` | 1 | The provided data items will be rearranged so the ones with sub-items will be shown first. |\n| `ExpansiblesLast` | 2 | The provided data items will be rearranged so the ones with sub-items will be shown last. |\n\n## Defining the Summaries\n\nThe summaries are the the text shown for expansible items.  Said items are represented with a `<details>` HTML element \nthat spans all table columns and its content is configurable.  As per the HTML specification, the first child of this \n`<details>` element is a `<summary>` element.\n\nThe contents of the `<summary>` element are what's displayed when the element is collapsed.  It is called the \n**summary** for obvious reasons.  After the summary, the sub-table is shown.\n\nThere are two ways to control what is shown in the summary:  By using the `summary` prop, or by using the `summary` \nslot.\n\n### The Summary Slot\n\nThis would be the preferred option.  Use the named slot `summary` to customize what is shown as the expansible conent.\n\nThis is taken from the test application in this repository:\n\n```ts\n<Htable\n    class=\"data\"\n    items={buildData(data.data)}\n    {columns}\n    level={l => `Level: ${l}`}\n    showPath={true}\n    captionOrder={CaptionOrder.LevelPath}\n    summary={(i) => `${i.last_name}, ${i.first_name}`}\n    grouping={ItemGrouping.ExpansiblesFirst}\n    pathSegment={(i) => i.last_name}\n    pathSeparator=\" > \"\n    maxPathSegmentLength={10}\n>\n    <svelte:fragment slot=\"summary\" let:item>\n        <img class=\"flag\" src=\"https://flagcdn.com/{item.country_code.toLowerCase()}.svg\" alt={item.country_code} />&nbsp;{item.last_name},&nbsp;{item.first_name}\n    </svelte:fragment>\n</Htable>\n```\n\nA Svelte fragment is being used to set the slot's content to an image and the employee's name in the \n`<last name>, <first name>` format.  This is what you see in the example screenshot at the beginning of this document.\n\n> **NOTE**:  The slot itself provides the item currently being rendered.\n\nThe example also shows the use of the `summary` prop.  When both are specified, the slot version will win.\n\n### The Summary Prop\n\nThe other way to set the the summary would be to use the `summary` prop.  It can be a string, in which case it is \nassumed to be the name of a property in the item, or it can be a function that accepts the item and returns whatever \nyou want as text in the summary.\n\nIf the example above did not use the summary slot, the function you see in the `summary` prop would be used, creating \na very similar summary, only this one would not contain the image the summary-slotted version produces.\n\n## Controlling Column Content\n\nIt is sometimes necessary to format data because the raw data might not be very friendly.  For example, dates in the \nISO-8601 format are not much of a looker.  To account for this, column definitions may define a `renderValue()` \nfunction that is called to obtain the column's contents.  If the function is not defined, `svelte-htable` provides a \ndefault function that only does 2 things:\n\n1. Undefined values are exchanged with empty strings.\n2. Null values are represented as `(---)`.\n\nThe null string is actually configurable through the `nullText` prop.  If you don't like this default, just set a new \none using this prop.\n\nAll value-rendering functions are given 2 arguments:  The row's item, and the column's key.\n\n> **IMPORTANT**: Any empty strings are replaced by the `column` slot's default template with a non-breaking space \n(`&nbsp;`) to ensure cell formatting, and you should too, if you opt to use the `column` slot.  To assist with this, \n`svelte-htable` exports the `StdCell` component with this logic.  See details [here](#stdcell).\n\n### Computed Columns\n\nThe `render()` function can be used to create calculated columns.  The example screenshot at the top shows the **Age** \ncolumn, which is calculated by using the following column definition in the `columns` array:\n\n```ts\n        {\n            key: \"age\",\n            title: \"Age\",\n            render: (i, k) => {\n                const diff = Date.now() - Date.parse(i.birth_date);\n                return Math.floor(\n                    diff / (365 * 24 * 60 * 60 * 1000)\n                ).toString();\n            },\n        },\n```\n\n---\n\nThe `renderValue()` method will only take you so far, and if complex HTML is needed inside the table cell, then you \nmust opt to use the `column` slot.\n\n> **Tip**:  You can, and is encouraged to, combine the use of `render()` with the `column` slot.\n\n### Using Slots for Table Data\n\nThe `Htable` component offers two mutually-exclusive slots to render data:  The `datarow` slot, and the `datacell` \nslot.  The latter is highly recommended because the former will incur in loss of certain features.\n\n#### The datacell Slot\n\nDynamic slots don't seem to be a thing (yet) in **Svelte**, so there is a single slot for all columns, and in order to \nuse it, one must use an `{#if}` block to differentiate between table cells.\n\nThis following example is what has been used to create the example screenshot:\n\n```html\n<svelte:fragment slot=\"datacell\" let:item let:col let:renderValue>\n    {@const value = renderValue(item, col.key)}\n    {#if col.key === \"id\"}\n        <div class=\"inverted\">{value}</div>\n    {:else if col.key === \"country_code\"}\n        <a\n            href=\"https://flagpedia.net/{item.country_code.toLowerCase()}\"\n            target=\"_blank\">{value}</a\n        >\n    {:else}\n        <StdCell itemData={value} />\n    {/if}\n</svelte:fragment>\n```\n\nThe slot provides 3 pieces of data:  The row's item, the column definition object and the column's `renderValue()` \nfunction, but it is not exactly the one found in the column definition object.  While column definitions may not \ncarry a `renderValue()` function (and therefore `col.renderValue` may very well be `undefined`), this slot-provided \nfunction is guaranteed to exist.  How?  Simple:  This is the defined `renderValue()` function inside the column \ndefinition object, **or** the default `renderValue()` function explained in the previous section.\n\nThe example also features the use of the `StdCell` component.  Let's quickly explain it.\n\n#### StdCell\n\nThis is a tiny component that has only one prop:  `itemData`.  It encapsulates the logic mentioned previously about \nexchanging empty strings with `&nbsp;`.  Its use is super simple:\n\n```html\n<Htable\n    ...\n>\n    <div class=\"my-class\" slot=\"column\" let:item let:col let:renderValue>\n        {@const itemData = renderValue(item, col.key)}\n        {#if somethingSpecial}\n            <SpecialMarkup />\n        {:else}\n            <StdCell {itemData} />\n        {/if}\n```\n\nBasically we use it as a default.\n\n#### The datarow Slot\n\nIf you ever need to gain control of how many columns a `<td>` element spans, or if you must apply CSS classes to the \n`<tr>` element, you may opt to use the `datarow` slot.\n\n> **WARNING**:  The use of this slot carries the loss of stock features.  Keep reading to learn about this.\n\nBecause you gain full control over the `<tr>` element, the `Htable` component can no longer provide the following \nfunctionality:\n\n- Automatic `odd`/`even` CSS classes in the `<tr>` element.\n- `StdCell` logic in the `<td>` elements.\n\nFurthermore, you must provide the `<tr>` element as the slot's root element.\n\nStill, your gains are evident.  Now you can:\n\n+ Apply any styles or attributes to the `<tr>` element because you fully control it.\n+ You may write the `<td>` elements more naturally, without the need of `{#if}` blocks to switch between the various \nHTML markups for each of the table columns.\n+ You gain full control of the `<td>` elements, including but not limited to, the ability to make it span mutliple \ncolumns.\n\nThis example creates the same table as the previous example, but making use of the `datarow` slot:\n\n```html\n<tr slot=\"datarow\" class:flag={item.country_code === flagCountryCode} let:item let:index let:renderValue>\n    {#each columns as col}\n        {@const value = (col.renderValue ?? renderValue)(item, col.key)}\n        <td>\n            {#if col.key === \"id\"}\n                <div class=\"inverted\">{value}</div>\n            {:else if col.key === \"country_code\"}\n                <a\n                    href=\"https://flagpedia.net/{item.country_code.toLowerCase()}\"\n                    target=\"_blank\">{value}</a\n                >\n            {:else}\n                <StdCell itemData={value} />\n            {/if}\n        </td>\n    {/each}\n</tr>\n```\n\nYes, I know, I still used `{#each}` + `{#if}` to create the columns.  I did not feel like re-writing this for 2 \nspecial columns out of possible 8.  But that's not the point here, so focus.\n\nThe point of the example is that now we can manipulate `<tr>`.  In this case, a CSS class named `flag` is \nconditionally applied to the row to produce a highlight effect based on a variable (`flagCountryCode`) bound to an \ninput textbox.\n\n### Controlling Header Content\n\nWhat is shown in the tables' headers is the text of the property `title` of the individual `Column` objects passed to \nthe component via its `columns` prop.\n\nHowever, if you need or want, you may opt to use the `headercell` slot.  It provides the column definition object and \nit is pretty much very simple to use.  This next example assumes the column definition objects also have a custom \nproperty named `uom` (stands for Unit of Measure).\n\n```html\n<Htable\n    ...\n>\n    <svelte:fragment slot=\"headercell\" let:col>\n        <em>{col.title} ({col.uom})</em>\n    </svelte:fragment>\n```\n\nThis would produce a header with a text similar to, say, `Distance (km)`.\n\n## Functionality\n\nYou can control which sub-tables are initially displayed using the `initialOpenLevel` prop.  Assign a number greater \nthan 2 to this prop and any sub-tables whose level is that number or less will be expanded by default.\n\nYou may also listen to the `toggle` event.  It is triggered whenever any sub-table is opened or closed.  The event \ncarries the following data:\n\n+ `item`:  The data item used to generate the sub-table (the one with the sub-items).\n+ `level`:  The sub-table's level.\n+ `path`:  The sub-table's path.\n+ `open`:  A Boolean value indicating if the table was opened (and its current state is open).\n\n---\n\nIf you have questions, would like to report a bug or request a feature, feel free to open an issue.\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 8],
		[3596, 10],
		[3603, 15],
		[3610, 13],
		[3624, 6],
		[3638, 1],
		[3652, 4],
		[3659, 1],
		[3666, 12],
		[3687, 2],
		[3708, 1],
		[3736, 1],
		[3743, 7],
		[3757, 2],
		[3771, 9],
		[3778, 1],
		[3785, 1],
		[3792, 2],
		[3806, 2],
		[3813, 24],
		[3834, 1],
		[3841, 47],
		[3848, 3],
		[3855, 1],
		[3862, 2],
		[3869, 1],
		[3883, 2],
		[3890, 13],
		[3911, 2],
		[3918, 1],
		[3925, 1],
		[3932, 3],
		[3939, 1],
		[3953, 1],
		[3960, 3],
		[3967, 1],
		[3974, 1],
		[3981, 1],
		[3988, 1],
		[4002, 2],
		[4009, 3],
		[4023, 2],
		[4037, 18],
		[4044, 13],
		[4051, 3],
		[4058, 1],
		[4065, 4],
		[4072, 1],
		[4100, 28],
		[4107, 1],
		[4114, 8],
		[4121, 11],
		[4128, 3]
	],
	"esm": true,
	"cjs": false
}
