{
	"name": "svelte-cache-store",
	"description": "Cache API data in Svelte stores, compatible with Svelte 4.",
	"repo_url": "",
	"authors": ["joachimhskeie"],
	"downloads": 7,
	"updated": "2024-10-12T12:16:04.512Z",
	"tags": ["miscellaneous"],
	"typescript": true,
	"version": "0.5.6",
	"svelte_range": "^5.0.0-next.260",
	"last_rune_check_version": "0.5.6",
	"github_stars": 0,
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-cache-store",
				"version": "0.5.6",
				"size": 126887
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# CacheStore for Svelte\n\nThis library provides a cache store for Svelte applications that simplifies fetching, creating, updating, and deleting items from a REST API that adheres to the simple-json-api specification. It also supports side-loading of related data and automatic cache management.\n\n## Features\n\n- **Centralized Cache Management**: Manage different types of data with separate caches.\n- **Lazy Fetching**: Data is only fetched from the server when needed, and cached for future use.\n- **Side-Loading Support**: Automatically handles side-loaded data returned by the API and caches it accordingly.\n- **Sorting**: Supports sorting of fetched data based on specified columns.\n- **Comprehensive CRUD Operations**: Simplified methods to create, read, update, and delete items.\n\n## Side-Loading Support\n\nThe cache store automatically handles side-loaded data. When an API response includes side-loaded data (e.g., related images returned along with blog posts), the store will add this data to the appropriate cache if the type is registered\n\n## Rationale\n\nI find myself implementing similar backend APIs when I develop applications. These APis are more often than not based on REST principles with JSON payloads. As a result, I have publised the start of a simple JSON API spec at [http://simple-json-api.com](http://simple-json-api.com). This specification makes it easy to write both backend and frontend code to handle the data communication between the applications in a uniform manner. This approach makes it possible to write a fairly small amount of code to get advanced functionality on the frontend-data-layer.\n\n# Installation\n\n```\nnpm install svelte-cache-store\n```\n\n\n# Usage\n\n## Registering the data entities to cache\n\nEach of the data-types that the CacheStore can handle needs to be registered, so that the CacheStore knows how to query the backend API. This means that it needs to provide the CacheStore with:\n\n- the singular form of the entity to cache\n- the plural form of the entity to cache\n- the URL prefix that your backend uses\n\nIf you are writing a Blog, then you might have two data types - BlogPost and BlogPostImages. \nBoth of these needs to be a Typescript type and registered with the store - typically in \nsrc/+layout.svelte:\n\n### BlogPost.ts\n\n```typescript\nexport interface BlogPost extends CacheItem {\n    title: string;\n    preamble: string;\n    content: string;\n    createdDate: string;\n    username: string;\n    isVisible: boolean;\n    images: string[];\n}\n```\n\n### BlogPostImage.ts\n\n```typescript\nexport interface BlogPostImage extends CacheItem{\n    imagePath: string;\n    blogPostId: string;\n}\n```\n\n### +layout.svelte\n```sveltehtml\n<script lang=\"ts\">\nimport {cacheStore} from \"svelte-cache-store\";\nimport type {BlogPost} from \"./BlogPost\";\nimport type {BlogPostImage} from \"./BlogPostImage\";\n\ncacheStore.registerType<BlogPost>('blogPost', 'blogPosts', '/my-api');\ncacheStore.registerType<BlogPostImage>('blogPostImage', 'blogPostImages', '/my-api');\n</script>\n\n<slot></slot>\n```\n\nThe code above registeres the types blogPost and blogPostImage with CacheStore. If you server live on http://myurl, then the URL to fetch all blogPosts would be: http://myurl/my-api/blogPosts\n\n## Fetching data\n\nData can be fetched in two ways:\n\n- **fetchAll<Type>(singularName)**\n- **fetchById<Type>(singularName, id)**\n\n### fetchById<Type extends CacheItem>(singularName, id)\n\nThis method fetches an item by its ID. If the item is already in the cache, it will be returned immediately; otherwise, it will be fetched from the API. Sideloaded data will be automatically added to the cache.\n\n```\nlet blogPost : BlogPost = await cacheStore.fetchById<BlogPost>('blogPost', '123');\n```\n\nThe data will be fetched via a GET to **/my-api/blogPosts/123**.\n\nThe return JSON will be something like this:\n\n```json\n{\n  \"blogPost\": {\n    \"id\": \"123\",\n    \"title\": \"My Blog Post\",\n    \"preamble\": \"This is a blog post\",\n    \"content\": \"This is the content of the blog post\",\n    \"createdDate\": \"2021-10-10\",\n    \"username\": \"user\",\n    \"isVisible\": true,\n    \"images\": [\"456\"]\n  }\n}\n```\n\n### fetchAll<Type extends CacheItem>(singularName)\n\nThis method fetches all items of a specific type. If the items are already in the cache, they will be returned immediately; otherwise, they will be fetched from the API. Sideloaded data will be automatically added to the cache.\n\n**sortColumns**: An optional array of sorting criteria.\n\n```\nlet blogPosts : BlogPost[] = await cacheStore.fetchAll<BlogPost>('blogPost', [{ sortColumn: \n'createdDate', sortOrder: 'desc' }]);\n```\n\nThe data will be fetched via a GET to **/my-api/blogPosts**.\n\nThe return JSON will be something like this:\n\n```json\n{\n  \"blogPosts\": [\n    {\n      \"id\": \"123\",\n      \"title\": \"My Blog Post\",\n      \"preamble\": \"This is a blog post\",\n      \"content\": \"This is the content of the blog post\",\n      \"createdDate\": \"2021-10-10\",\n      \"username\": \"user\",\n      \"isVisible\": true,\n      \"images\": [\"456\"]\n    },\n    {\n      \"id\": \"124\",\n      \"title\": \"My Second Blog Post\",\n      \"preamble\": \"This is a blog post\",\n      \"content\": \"This is the content of the blog post\",\n      \"createdDate\": \"2021-10-10\",\n      \"username\": \"user\",\n      \"isVisible\": true,\n      \"images\": [\"457\"]\n    }\n  ]\n}\n```\n\n### reloadById<Type extends CacheItem>(singularName, id)\n\nThis method forces a re-fetch of the item from the API, even if it is already in the cache. The updated data will be placed in the cache\n\n```\nlet refreshedBlogPost = await cacheStore.reloadById('blogPost', '123');\n```\n\n### reloadAll<Type extends CacheItem>(singularName)\n\nThis method forces a re-fetch of all items from the API, even if they are already in the cache. The updated data will be placed in the cache\n\n```\nlet refreshedBlogPosts = await cacheStore.reloadAll('blogPost', [{ sortColumn: 'createdDate', sortOrder: 'desc' }]);\n```\n\n### create<Type extends CacheItem>(singularName, object)\n\nThis method creates a new item via the API and adds it to the cache.\n\n```\nlet blogPost : BlogPost = await cacheStore.create('blogPost', myBlogPost);\n```\n\nThe data will be stored via a POST to **/my-api/blogPosts**.\n\n### update<Type extends CacheItem>(singualrName, id, object)\n\nThis method updates an item by its ID via the API and updates the cache with the new data.\n\n```\nblogPost = await cacheStore.update('blogPost', '123', myBlogPost);\n```\n\nThe data will be fetched via a PUT to **/my-api/blogPost/123s**.\n\n### remove(singularName, id)\n\nThis method deletes an item by its ID via the API and removes it from the cache.\n\n```\nawait cacheStore.remove('blogPost', '123');\n```\n\nThe data will be deleted via a DELETE to **/my-api/blogPosts/123**.\n\n# Example\n\nEach data type that CacheStore should handle, needs to be registered. This is typically done application-wide in src/+layout.svelte:\n\n```javascript\n<script>\nimport {cacheStore} from \"svelte-cache-store\";\nimport type {BlogPost} from \"./BlogPost\";\nimport type {BlogPostImage} from \"./BlogPostImage\";\n    \ncacheStore.registerType<BlogPost>('blogPost', 'blogPosts', '/my-api');\ncacheStore.registerType<BlogPostImage>('blogPostImage', 'blogPostImages', '/my-api');\n</script>\n\n<slot></slot>\n```\n\nTo fetch, create, update and delete data, this is normally done in the page-components. For the blog application, all blog posts might fetched in the /src/routes/+page.svelte component.\n\n```\n<script>\n    import {cacheStore} from \"svelte-cache-store\";\n    import {onMount} from \"svelte\";\n    import type {BlogPost} from \"$lib/models/BlogPost\";\n    \n    let blogPosts : BlogPost[] = [];\n    onMount(async () => {\n        // Fetch all blog posts, sorted by 'createdDate' in descending order\n        const result = await cacheStore.fetchAll<BlogPost>('blogPost', [{ sort: 'createdDate', \n        order: 'desc' }]);\n\n        // Filter the blog posts to include only those where data.isVisible is true\n        blogPosts = result.filter(post => post.data && post.data.isVisible);\n    });\n</script>\n\n<div class=\"header\">\n    <!-- Your logo goes here -->\n</div>\n\n<h1>Blog Posts</h1>\n\n{#if blogPosts.length === 0}\n    <p>No blog posts found.</p>\n{:else}\n    <ul>\n        {#each blogPosts as blogPost}\n            <li>\n                <a href={`/blogPost/${blogPost.id}`}>{blogPost.title}</a>\n            </li>\n        {/each}\n    </ul>\n{/if}\n```\n\nFrom the cache, the items state (loading, updating, deleting, loaded, error) is kept in \nthe state-property. If any error message is received while fetching data from the backend, \nit can be found in the *errorMessage*-property.\n\nWhen the user navigates to a single blogPost, the blog should be presented, along with any images \nthat belong to the blogPost, in /src/routes/blogPost/[blogId]/+page.svelte:\n\n```sveltehtml\n<script lang=\"ts\">\n    import {cacheStore} from \"svelte-cache-store\";\n    import {onMount} from \"svelte\";\n    import {page} from \"$app/stores\";\n    import Markdown from \"$lib/components/Markdown.svelte\";\n    import type {BlogPost} from \"$lib/models/BlogPost\";\n    import type {BlogPostImage} from \"$lib/models/BlogPostImage\";\n    \n    let blogPost : BlogPost;\n    let blogImages : BlogPost[] = [];\n    onMount(async () => {\n        blogPost = await cacheStore.fetchById<BlogPost>('blogPost', $page.params.id);\n        if (blogPost.state === 'loaded' && blogPost.images) {\n            for (const image of blogPost.images) {\n                let img : BlogPostImage = await cacheStore.fetchById<BlogPostImage>\n    ('blogPostImage', image);\n                console.log(img);\n                blogImages = [...blogImages, img];\n            }\n        }\n    });\n\n</script>\n\n<div><a href=\"/\">Back</a></div>\n\n{#if blogPost?.state === 'error'}\n    <p style=\"color: red;\">Error: {blogPost.errorMessage || 'Unknown error'}</p>\n{:else if blogPost?.state === 'loaded'}\n    <h1>{blogPost.title}</h1>\n\n    {#each blogImages as image}\n        <img src={image.imagePath} />\n    {/each}\n    <p>Created by {blogPost.username} on {blogPost.createdDate}</p>\n\n    <p>{blogPost.preamble}</p>\n\n    <p><Markdown toHtml={blogPost.content} /></p>\n{:else if blogPost?.state === 'loading'}\n    <p>Loading...</p>\n{/if}\n```\n\nAs you can see from the above code, we can implement loading indicators, as well as error messages fairly easily with this setup. Fetching data is also streamlined accross each data type. \n",
	"legacy_svelte": false,
	"downloads_history": [
		[3918, 200],
		[3925, 18],
		[3932, 66],
		[3939, 15],
		[3946, 9],
		[3953, 3],
		[3960, 2],
		[3967, 3],
		[3974, 1],
		[3981, 1],
		[3988, 8],
		[3995, 2],
		[4002, 1],
		[4009, 5],
		[4016, 4],
		[4023, 5],
		[4030, 3],
		[4037, 14],
		[4044, 8],
		[4051, 3],
		[4065, 1],
		[4072, 3],
		[4100, 4],
		[4107, 9],
		[4114, 7],
		[4121, 11],
		[4128, 1]
	]
}
