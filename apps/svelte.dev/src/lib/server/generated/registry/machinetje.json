{
	"name": "machinetje",
	"description": "Tiny state machines for Svelte 5+ applications.",
	"repo_url": "https://github.com/OscarBouwmans/Machinetje",
	"authors": ["oscarbouwmans"],
	"homepage": "https://github.com/OscarBouwmans/Machinetje#readme",
	"downloads": 4,
	"updated": "2024-05-29T09:01:47.521Z",
	"tags": ["miscellaneous"],
	"github_stars": 0,
	"typescript": true,
	"version": "0.4.0",
	"svelte_range": "^5.0.0-next.143",
	"kit_range": "^2.5.10",
	"last_rune_check_version": "0.4.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "machinetje",
				"version": "0.4.0",
				"size": 22622
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# Machinetje\nTiny state machines for Svelte 5+\n\n## Motivation\n_Machinetje_ in Dutch means _little machine_, which perfectly describes this package. It's a small state machine solution, intended to be a good match with Svelte 5+.\n\n## Machine Definition\n\nStart by describing the possible states and their transitions, ending with the initial state. This may be done in a seperate `.js`/`.ts` file, to keep the logic seperate from your Components.\n\n```JavaScript\n// resource-machine.js\n\nimport { machinetje } from 'machinetje';\n\nexport const resourceMachine = machinetje(\n    {\n//      ðŸ‘‡ state\n        idle: {\n            on: {\n//              ðŸ‘‡ action    ðŸ‘‡ target state\n                download: 'loading'\n            }\n        },\n        loading: {\n            on: {\n                cancel: 'idle',\n                success: 'done',\n                failure: 'error'\n            }\n        },\n        done: {},\n        error: {\n            on: {\n                retry: 'loading'\n            }\n        }\n    },\n//  ðŸ‘‡ initial state\n    'idle',\n//  ðŸ‘‡ initial context\n    {\n        responseText: null,\n        errorMessage: null\n    }\n);\n```\n\nUse `context` to store data (a.k.a. extended state) into your machinetje, such as fetch responses, error messages, remaining retry attemps, etc. You can write to the context when dispatching an action, or at the start of an effect, as shown later.\n\n## Reading state, dispatching actions\n\nIn your component files, you can start a new instance of the machinetje:\n\n```Svelte\n<!-- SomeComponent.svelte -->\n\n<script>\n    import { resourceMachine } from './resource-machine.js';\n\n    const resource = resourceMachine();\n\n    let fileName = $state('');\n\n    function download() {\n        // dispatch actions to your machinetje to change its state:\n        resource.dispatch('download', fileName);\n        //                 ðŸ‘† action   ðŸ‘† action parameter\n    }\n\n    function cancel() {\n        resource.dispatch('cancel');\n    }\n</script>\n\n{#if resource.state === 'idle'}\n    <input bind:value={fileName} />\n    <button onclick={download}>Download file</button>\n{:else if resource.state === 'loading'}\n    <p>Downloading resourceâ€¦</p>\n    <button onclick={cancel}>Cancel</button>\n{:else if resource.state === 'done'}\n    <p>{resource.context.responseText}</p>\n<!-- etcâ€¦ -->\n```\n\nAlternatively, use the `<SelectState>` helper component with snippets:\n\n```Svelte\n<!-- SomeComponent.svelte -->\n\n<script>\n    import { SelectState } from 'machinetje';\n    import { resourceMachine } from './resource-machine.js';\n\n    const resource = resourceMachine();\n\n    let fileName = $state('');\n</script>\n\n<SelectState machinetje={resource}>\n    {#snippet idle({ dispatch })}\n        <input bind:value={fileName} />\n        <button onclick={() => dispatch('download')}>Download</button>\n    {/snippet}\n    {#snippet loading({ dispatch })}\n        <p>Downloading resourceâ€¦</p>\n        <button onclick={() => dispatch('cancel')}>Cancel</button>\n    {/snippet}\n    {#snippet done({ context })}\n        <p>{context.responseText}</p>\n    <!-- etcâ€¦ -->\n</SelectState>\n```\n\n## Effects\n\nEffects let you write to the context of your machinetje, and interact with the world around it. Within effects, use the provided `dispatch` property to pass on data to the next state via actions.\n\n```JavaScript\n// resource-machine.js\n\nexport const resourceMachine = machinetje({\n    idle: {\n        on: {\n            download: 'loading'\n        }\n    },\n    loading: {\n        effect: loadResource,\n        on: {\n            cancel: 'idle',\n            success: 'done',\n            failure: 'error'\n        }\n    },\n    done: {\n        effect({ value, setContext }) {\n            setContext({ responseText: value });\n        },\n    },\n    error: {\n        effect({ value, setContext }) {\n            setContext({ errorMessage: value });\n        },\n        on: {\n            retry: 'loading'\n        },\n    }\n}, 'idle', { responseText: null, errorMessage: null });\n\nasync function loadResource({ value, setContext, dispatch, signal }) {\n    // set a clear context to remove any potential old errors\n    setContext({});\n\n    // `value` represents the optional extra parameter provided to `dispatch`\n    if (!value) {\n        return dispatch('failure', 'No file name provided');\n    }\n    const resourceUrl = `example.com/resource/${value}.zip`;\n\n    try {\n        // use the `signal` to allow cancelation of the request\n        const response = await fetch(resourceUrl, { signal });\n        const responseText = await response.text();\n        if (!response.ok) {\n            throw new Error(responseText);\n        }\n        // dispatch 'success' action, and place the responseText in the context\n        dispatch('success', responseText);\n    }\n    catch (error) {\n        dispatch('failure', error.message);\n    }\n}\n```\n\nWhen the effect is an `async` function, use the provided `signal` to handle cancelation cases (see [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)), as exampled above. This signal will be aborted whenever a dispatched action causes a state transition.\n\nAlternatively, a sync effect can return a cleanup function:\n\n```JavaScript\n// heavy-processing-machine.js\n\nconst heavyProcessingMachine = machinetje({\n    ready: {\n        on: {\n            start: 'processing',\n        }\n    },\n    processing: {\n        on: {\n            result: 'finished',\n            cancel: 'ready',\n        },\n        effect: doTheHardWork\n    },\n    finished: {\n        effect({ value, setContext }) {\n            setContext({ result: value });\n        }\n    },\n}, 'ready', { result: null });\n\nfunction doTheHardWork({ dispatch }) {\n    const worker = new Worker('heavy-script.js');\n\n    worker.onmessage = (event) => {\n        dispatch('result', event.data);\n    };\n\n    return cleanup() {\n        worker.terminate();\n    };\n}\n\n// AnotherComponent.svelte\nimport { heavyProcessingMachine } from './heavy-processing-machine.js';\n\nconst heavyProcessing = heavyProcessingMachine();\nheavyProcessing.dispatch('start');\nheavyProcessing.dispatch('cancel'); // <= causes the cleanup function to run\n```\n\n## Setting Context\n\nContext can be set in an effect, under the following conditions:\n- the context is set _synchronously_\n- the context is set _before_ any `dispatch`\n\nIf these conditions are not met, the `setContext` call is ignored and a warning is logged to the console.\n\n```JavaScript\n// some-machine.js\n\nexport const someMachine = machinetje({\n    idle: {\n        async effect({ setContext }) {\n            // this works:\n            setContext({ value: 'Hello' });\n\n            // this would not update the context:\n            setTimeout(() => setContext({ value: 'World' }), 1);\n\n            // this also would not update the context:\n            await somePromise();\n            setContext({ value: 'World' });\n        },\n        on: {\n            work: 'busy',\n        }\n    },\n    busy: {\n        effect({ setContext, dispatch }) {\n            // this works:\n            setContext({ value: 'Hello' });\n            dispatch('done');\n\n            // calls after dispatch are ignored:\n            setContext({ value: 'World' }); // <= ignored\n        },\n        on: {\n            done: 'idle',\n        }\n    }\n}, 'idle', { value: null });\n```\n\n## State Machine Recovery\n\nMachinetjes can be recovered from a serialized state. Serializing a machinetje's full state is done by reading the `state` and `context` properties from the instance. The serialized state can be stored somewhere (e.g. in LocalStorage), and later used to recover the machinetje:\n\n```JavaScript\nimport { someMachine } from './some-machine.js';\n\nconst instance = someMachine();\n\n// storing the state\nconst { state, context } = instance;\nconst serialized = JSON.stringify({ state, context });\nlocalStorage.setItem('stored-state', serialized);\n\n// recovering the state\nconst serialized = localStorage.getItem('stored-state');\nconst { state, context } = JSON.parse(serialized);\nconst recovered = someMachine(state, context);\n```\n\nNote that the recovered machinetje is a new instance. If the current recovered state has an effect, it will run, even if it had already run to completion in the original instance. This is so that if the machinetje is recovered in a resource loading state, for example, it will again start the effect to load the resource.\n\n## Examples\n\n### Fetching a resource\n\n```JavaScript\n// resource-machine.js\n\nexport const resourceMachine = machinetje({\n    idle: {\n        on: {\n            download: 'loading'\n        }\n    },\n    loading: {\n        effect: loadResource,\n        on: {\n            cancel: 'idle',\n            success: 'done',\n            failure: 'error'\n        }\n    },\n    done: {\n        effect({ value, setContext }) {\n            setContext({ responseText: value });\n        }\n    },\n    error: {\n        effect({ value, setContext, context, dispatch }) {\n            setContext({ errorMessage: value });\n            autoRetry({ context, setContext, dispatch, value });\n        },\n        on: {\n            retry: 'loading'\n        }\n    }\n}, 'idle', { responseText: null, errorMessage: null, remainingAutoRetries: 2 });\n\nasync function loadResource({ setContext, dispatch, signal }) {\n    setContext({});\n\n    try {\n        const response = await fetch('example.com/resource', { signal });\n        const responseText = await response.text();\n        if (!response.ok) {\n            throw new Error(responseText);\n        }\n        setContext({ responseText });\n        dispatch('success', responseText);\n    }\n    catch (error) {\n        setContext({ errorMessage: error.message });\n        dispatch('failure', error.message);\n    }\n}\n\nfunction autoRetry({ context, setContext, dispatch }) {\n    if (context.remainingAutoRetries <= 0) {\n        return;\n    }\n    const remainingAutoRetries = context.remainingAutoRetries - 1;\n    setContext({ remainingAutoRetries });\n    dispatch('retry');\n}\n```\n\n```Svelte\n<!-- Resource.svelte -->\n\n<script>\n    import { resourceMachine } from './resource-machine.js';\n\n    const resource = resourceMachine();\n</script>\n\n<SelectState machinetje={resource}>\n    {#snippet idle({ dispatch })}\n        <button onclick={() => dispatch('download')}>Download</button>\n    {/snippet}\n    {#snippet loading({ dispatch })}\n        <p>Downloading resourceâ€¦</p>\n        <button onclick={() => dispatch('cancel')}>Cancel</button>\n    {/snippet}\n    {#snippet done({ context })}\n        <p>{context.responseText}</p>\n    {/snippet}\n    {#snippet error({ dispatch, context })}\n        <p>{context.errorMessage}</p>\n        <button onclick={() => dispatch('retry')}>Retry</button>\n    {/snippet}\n</SelectState>\n```\n\n### A simple stopwatch\n\n```JavaScript\n// stopwatch-machine.js\n\nexport const stopwatchMachine = machinetje({\n    stopped: {\n        effect: ({ setContext }) => {\n            setContext({ startTime: null });\n        },\n        on: {\n            start: 'running'\n        }\n    },\n    running: {\n        effect: ({ setContext }) => {\n            setContext({ startTime: new Date() });\n        },\n        on: {\n            stop: 'stopped'\n        }\n    }\n}, 'stopped', { startTime: null });\n```\n\n```Svelte\n<!-- Stopwatch.svelte -->\n\n<script>\n    import { stopwatchMachine } from './stopwatch-machine.js';\n\n    const stopwatch = stopwatchMachine();\n\n    let currentTime = $state(0);\n\n    $effect(() => {\n        if (stopwatch.state !== 'running') {\n            currentTime = 0;\n            return;\n        }\n\n        let nextFrame;\n        function renderLoop() {\n            const now = Date.now();\n            const elapsed = now.getTime() - stopwatch.context.startTime.getTime();\n            currentTime = elapsed / 1000;\n            nextFrame = requestAnimationFrame(renderLoop);\n        };\n        renderLoop();\n        return () => cancelAnimationFrame(nextFrame);\n    });\n</script>\n\n<p>{currentTime}</p>\n\n<SelectState machinetje={stopwatch}>\n    {#snippet stopped({ dispatch })}\n        <button onclick={() => dispatch('start')}>Start</button>\n    {/snippet}\n    {#snippet running({ dispatch })}\n        <button onclick={() => dispatch('stop')}>Stop</button>\n    {/snippet}\n</SelectState>\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3694, 51],
		[3701, 74],
		[3708, 8],
		[3715, 74],
		[3722, 57],
		[3729, 7],
		[3736, 5],
		[3743, 1],
		[3750, 2],
		[3757, 3],
		[3764, 6],
		[3778, 5],
		[3792, 2],
		[3799, 68],
		[3806, 4],
		[3813, 2],
		[3820, 2],
		[3827, 1],
		[3834, 15],
		[3841, 3],
		[3848, 3],
		[3855, 1],
		[3862, 2],
		[3876, 4],
		[3890, 4],
		[3897, 1],
		[3925, 1],
		[3946, 5],
		[3953, 2],
		[3974, 1],
		[3988, 1],
		[3995, 1],
		[4016, 11],
		[4023, 2],
		[4030, 1],
		[4037, 7],
		[4044, 9],
		[4051, 3],
		[4065, 1],
		[4100, 4],
		[4107, 8],
		[4114, 4],
		[4121, 9],
		[4128, 3]
	]
}
