{
	"name": "svelte-asyncable",
	"description": "Create async stores for Svelte applications.",
	"repo_url": "https://github.com/sveltetools/svelte-asyncable",
	"authors": ["paulmaly"],
	"homepage": "https://github.com/sveltetools/svelte-asyncable#readme",
	"downloads": 2732,
	"updated": "2024-09-26T15:45:57.061Z",
	"tags": ["miscellaneous"],
	"github_stars": 169,
	"typescript": true,
	"version": "2.2.1",
	"svelte_range": "4.x",
	"last_rune_check_version": "2.2.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-asyncable",
				"version": "2.2.1",
				"size": 219737
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# Super tiny, declarative, optimistic, async store for SvelteJS.\n\n[![NPM version](https://img.shields.io/npm/v/svelte-asyncable.svg?style=flat)](https://www.npmjs.com/package/svelte-asyncable) [![NPM downloads](https://img.shields.io/npm/dm/svelte-asyncable.svg?style=flat)](https://www.npmjs.com/package/svelte-asyncable)\n\n## Features\n\n- Extends the [Svelete store contract](https://svelte.dev/docs#4_Prefix_stores_with_$_to_access_their_values) with support for asynchronous values.\n- Store contains a Promise of a value.\n- Lazy-initialization on-demand.\n- Transparent and declarative way to describing side-effects.\n- Lets you update the async data without manual resolving.\n- Can derive to the other store(s).\n- Immutable from the box.\n- Optimistic UI pattern included.\n- Result of asynchronous call cached for lifetime of last surviving subscriber.\n\n## Install\n\n```bash\nnpm i svelte-asyncable --save\n```\n\n```bash\nyarn add svelte-asyncable\n```\n\nCDN: [UNPKG](https://unpkg.com/svelte-asyncable/) | [jsDelivr](https://cdn.jsdelivr.net/npm/svelte-asyncable/) (available as `window.Asyncable`)\n\nIf you are **not** using ES6, instead of importing add \n\n```html\n<script src=\"/path/to/svelte-asyncable/index.js\"></script>\n```\n\njust before closing body tag.\n\n## Usage\n\n### Store with async side-effect that works as a `getter`.\n\nCreate your async store with the `asyncable` constructor.  It takes a callback or `getter` that allows you to establish an initial value of the store.\n\n```javascript\nimport { asyncable } from 'svelte-asyncable';\n\nconst user = asyncable(async () => {\n  const res = await fetch('/user/me');\n  return res.json();\n});\n```\n\nPlease note, the result of this callback is not evaluated until it is first subscribed to or otherwise requested. (lazy approach). \n\nThere are two methods to access the stored promise, `subscribe` and `get`.  \n\n`subscribe` is a reactive subscription familiar from the Svelte store contract:\n```javascript\nuser.subscribe(async userStore => {\n  console.log('user', await userStore); // will be printed after each side-effect\n});\n```\n\n`get` returns a copy of the promise that will not update with the store:\n\n```javascript\n// a point in time copy of the promise in the store\n\nconst userStore = await user.get();\n```\n\nPlease note, the subscription callback will be triggered with the actual value only after a side-effect.\n\nIf the `getter` or callback provided to `asyncable` returns explicit `undefined` (or just return is omitted), the current value of the store won't updated. This may be useful, if we wish to only conditionally update the store.  For example, when using `svelte-pathfinder` if `$path` or `$query` are updated, we may only wish to update the posts store on when in the posts route:\n\n```javascript\nconst posts = asyncable(($path, $query) => {\n    if ($path.toString() === '/posts') {\n      return fetch(`/posts?page=${$query.params.page || 1}`).then(res => res.json());\n    }\n  },\n  null, \n  [ path, query ]\n);\n```\n\n### Store with async side-effect that works as a `setter`.\n\nYou can also pass async `setter` callback as a second argument. This function will be is triggered on each update/set operation but not after a `getter` call and receives the new and previous value of the store:\n\n```javascript\nconst user = asyncable(fetchUser, async ($newValue, $prevValue) => {\n  await fetch('/user/me', {\n    method: 'PUT',\n    body: JSON.stringify($newValue)\n  })\n});\n```\n\nEvery time the store is changed this `setter` or side-effect will be performed.  The store may be modified selectively with `update` or completely overwritten with `set`.\n\n```javascript\nuser.update($user => {\n  $user.visits++;\n  return $user;\n});\n\n// or just set\n\nuser.set(user);\n```\n\nAs the `setter` callback receives previous value, in addition to the new, you may compare current and previous values and make a more conscious side-effect. If `setter` fails the store will automatically rollback to the previous value.\n\n```javascript\nconst user = asyncable(fetchUser, async ($newValue, $prevValue) => {\n  if ($newValue.email !== $prevValue.email) {\n    throw new Error('Email cannot be modified.');\n  }\n  await saveUser($newValue);\n});\n```\n\n### Read-only asyncable store.\n\nIf you pass a falsy value (n.b. `undefined` excluded) as a second argument the asyncable store will be read-only.\n\n```javascript\nconst tags = asyncable(fetchTags, null);\n\ntags.subscribe(async $tags => {\n  console.log('tags changed', await $tags); // will never triggered\n});\n\n// changes won't actually be applied\ntags.update($tags => {\n  $tags.push('new tag');\n  return $tags;\n});\n```\n\nIf you pass `undefined` as a second argument to `asyncable`, the store will be writable but without `setter` side-effect. The second parameter's default value is `undefined` so it is only required in the case you need to pass a third parameter.  This will be useful in case bellow.\n\n### Dependency to another store(s).\n\nAlso, an asyncable store may depend on another store(s). Just pass an array of such stores as a third argument to `asyncable`. These values will be available to the `getter`.  An asyncable may even depend on another asyncable store:\n\n```javascript\nconst userPosts = asyncable(async $user => {\n  const user = await $user;\n  return fetchPostsByUser(user.id);\n}, undefined, [ user ]);\n\nuserPosts.subscribe(async posts => {\n  console.log('user posts', await posts);\n});\n```\n\nThe `getter` will be triggered with the new values of related stores each time they change.\n\n### Using with Svelte auto-subscriptions.\n\n```svelte\n{#await $user}\n  <p>Loading user...</p>\n{:then user}\n  <b>{user.firstName}</b>\n{:catch err}\n  <mark>User failed.</mark>\n{/await}\n\n<script>\n  import { user } from './store.js';\n</script>\n```\n\n### Simple synchronization with localStorage.\n\n```javascript\nfunction localStore(key, defaultValue) {\n  return asyncable(\n    () => JSON.parse(localStorage.getItem(key) || defaultValue), \n    val => localStorage.setItem(key, JSON.stringify(val))\n  );\n}\n\n\nconst todos = localStore('todos', []);\n\nfunction addTodoItem(todo) {\n  todos.update($todos => {\n    $todos.push(todo);\n    return $todos;\n  });\n}\n\n```\n\n### Get synchronous value from async store:\n\n```javascript\nimport { syncable } from 'svelte-asyncable';\n\nconst todosSync = syncable(todos, []);\n```\n\nNow you can use sync version of asyncable store in any places you don't need to have pending/fail states.\n\n### Caching:\n\nThe ```getter``` is only run once at first subscription to the store.  Subsequent `subscribe` or `get` calls simply share this value while at least one subscription is active.  If all subscriptions are destroyed, the ```getter``` is rerun on next subscription. \n\nHowever, if the data on which your store depends changes infrequently, you may wish for a store to persist for the lifetime of the application.  In order to achieve this you may conditionally return your initial value on the absence of an existing value.\n\n```javascript\nexport const pinsStore = asyncable(async () => {\n    const $pinstStore = await pinsStore.get();\n    if ($pinstStore.length > 0) return $pinstStore;\n    return getAllPins();\n});\n```\n\n## License\n\nMIT &copy; [PaulMaly](https://github.com/PaulMaly)\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 400],
		[3596, 558],
		[3603, 672],
		[3610, 696],
		[3617, 865],
		[3624, 647],
		[3631, 786],
		[3638, 824],
		[3645, 136],
		[3652, 237],
		[3659, 629],
		[3666, 655],
		[3673, 539],
		[3680, 695],
		[3687, 415],
		[3694, 1083],
		[3701, 1188],
		[3708, 1604],
		[3715, 1173],
		[3722, 1541],
		[3729, 1421],
		[3736, 1321],
		[3743, 1325],
		[3750, 901],
		[3757, 1371],
		[3764, 1135],
		[3771, 469],
		[3778, 488],
		[3785, 1210],
		[3792, 1550],
		[3799, 1311],
		[3806, 1613],
		[3813, 1407],
		[3820, 975],
		[3827, 1355],
		[3834, 1042],
		[3841, 2965],
		[3848, 2122],
		[3855, 2561],
		[3862, 1796],
		[3869, 791],
		[3876, 2052],
		[3883, 1950],
		[3890, 2025],
		[3897, 1418],
		[3904, 1796],
		[3911, 1782],
		[3918, 1813],
		[3925, 2058],
		[3932, 2286],
		[3939, 2684],
		[3946, 2536],
		[3953, 2224],
		[3960, 1214],
		[3967, 1085],
		[3974, 2553],
		[3981, 1135],
		[3988, 1928],
		[3995, 1849],
		[4002, 2187],
		[4009, 712],
		[4016, 962],
		[4023, 1806],
		[4030, 1858],
		[4037, 1444],
		[4044, 1613],
		[4051, 1352],
		[4058, 1833],
		[4065, 1572],
		[4072, 1785],
		[4079, 2068],
		[4086, 1968],
		[4093, 1936],
		[4100, 1697],
		[4107, 2552],
		[4114, 2732],
		[4121, 2648],
		[4128, 2060]
	]
}
