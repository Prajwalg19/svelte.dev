{
	"name": "@supabase/auth-helpers-sveltekit",
	"description": "Provides auth helpers for Supabase in SvelteKit.",
	"repo_url": "https://github.com/supabase/auth-helpers",
	"authors": [],
	"homepage": "https://github.com/supabase/auth-helpers/tree/main/packages/sveltekit#readme",
	"downloads": 3406,
	"updated": "2024-04-09T10:33:33.451Z",
	"tags": ["auth"],
	"github_stars": 900,
	"typescript": true,
	"version": "0.13.0",
	"svelte_range": "^4.0.0",
	"kit_range": "^1.30.3 || ^2.0.0",
	"last_rune_check_version": "0.13.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@supabase/auth-helpers-sveltekit",
				"version": "0.13.0",
				"size": 31968
			},
			{
				"name": "@supabase/auth-helpers-shared",
				"version": "0.7.0",
				"size": 72710
			},
			{
				"name": "jose",
				"version": "4.15.9",
				"size": 548521
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2]
		],
		"circular": []
	},
	"readme": "# @supabase/auth-helpers-sveltekit (BETA)\n\nThis submodule provides convenience helpers for implementing user authentication in [SvelteKit](https://kit.svelte.dev/) applications.\n\n## Installation\n\nUsing [npm](https://npmjs.org):\n\n```sh\nnpm install @supabase/auth-helpers-sveltekit\n```\n\nThis library supports the following tooling versions:\n\n- Node.js: `^16.15.0`\n\n## Getting Started\n\n### Configuration\n\nSet up the fillowing env vars. For local development you can set them in a `.env` file. See an example [here](../../examples/sveltekit/.env.example).\n\n```bash\n# Find these in your Supabase project settings > API\nPUBLIC_SUPABASE_URL=https://your-project.supabase.co\nPUBLIC_SUPABASE_ANON_KEY=your-anon-key\n```\n\n### SupabaseClient setup\n\nCreate a server supabase client in a handle hook:\n\n```ts\n// src/hooks.server.ts\nimport { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public';\nimport { createSupabaseServerClient } from '@supabase/auth-helpers-sveltekit';\nimport type { Handle } from '@sveltejs/kit';\n\nexport const handle: Handle = async ({ event, resolve }) => {\n  event.locals.supabase = createSupabaseServerClient({\n    supabaseUrl: PUBLIC_SUPABASE_URL,\n    supabaseKey: PUBLIC_SUPABASE_ANON_KEY,\n    event\n  });\n\n  /**\n   * a little helper that is written for convenience so that instead\n   * of calling `const { data: { session } } = await supabase.auth.getSession()`\n   * you just call this `await getSession()`\n   */\n  event.locals.getSession = async () => {\n    const {\n      data: { session }\n    } = await event.locals.supabase.auth.getSession();\n    return session;\n  };\n\n  return resolve(event, {\n    filterSerializedResponseHeaders(name) {\n      return name === 'content-range';\n    }\n  });\n};\n```\n\n> Note that we are specifying `filterSerializedResponseHeaders` here. We need to tell SvelteKit that supabase needs the `content-range` header.\n\n### Send session to client\n\nIn order to make the session available to the UI (pages, layouts) we need to pass the session in the root layout server load function:\n\n```ts\n// src/routes/+layout.server.ts\nimport type { LayoutServerLoad } from './$types';\n\nexport const load: LayoutServerLoad = async ({ locals: { getSession } }) => {\n  return {\n    session: getSession()\n  };\n};\n```\n\n### Shared Load functions and pages\n\nTo be able to use Supabase in shared load functions and inside pages you need to create a Supabase client in the root layout load:\n\n```ts\n// src/routes/+layout.ts\nimport { PUBLIC_SUPABASE_ANON_KEY, PUBLIC_SUPABASE_URL } from '$env/static/public';\nimport { createSupabaseLoadClient } from '@supabase/auth-helpers-sveltekit';\nimport type { LayoutLoad } from './$types';\nimport type { Database } from '../DatabaseDefinitions';\n\nexport const load: LayoutLoad = async ({ fetch, data, depends }) => {\n  depends('supabase:auth');\n\n  const supabase = createSupabaseLoadClient<Database>({\n    supabaseUrl: PUBLIC_SUPABASE_URL,\n    supabaseKey: PUBLIC_SUPABASE_ANON_KEY,\n    event: { fetch },\n    serverSession: data.session\n  });\n\n  const {\n    data: { session }\n  } = await supabase.auth.getSession();\n\n  return { supabase, session };\n};\n```\n\nThe client can be accessed inside pages by `$page.data.supabase` or `data.supabase` when using `export let data: PageData`.\n\nThe usage of `depends` tells sveltekit that this load function should be executed whenever `invalidate` is called to keep the page store in sync.\n\n`createSupabaseLoadClient` caches the client when running in a browser environment and therefore does not create a new client for every time the load function runs.\n\n### Setting up the event listener on the client side\n\nWe need to create an event listener in the root `+layout.svelte` file in order catch supabase events being triggered.\n\n```svelte\n<!-- src/routes/+layout.svelte -->\n<script lang=\"ts\">\n  import { invalidate } from '$app/navigation';\n  import { onMount } from 'svelte';\n  import type { LayoutData } from './$types';\n\n  export let data: LayoutData;\n\n  $: ({ supabase, session } = data);\n\n  onMount(() => {\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange((event, _session) => {\n      if (_session?.expires_at !== session?.expires_at) {\n        invalidate('supabase:auth');\n      }\n    });\n\n    return () => subscription.unsubscribe();\n  });\n</script>\n\n<slot />\n```\n\nThe usage of `invalidate` tells sveltekit that the root `+layout.ts` load function should be executed whenever the session updates to keep the page store in sync.\n\n### Generate types from your database\n\nIn order to get the most out of TypeScript and itÂ´s intellisense, you should import the generated Database types into the `app.d.ts` type definition file that comes with your SvelteKit project, where `import('./DatabaseDefinitions')` points to the generated types file outlined in [v2 docs here](https://supabase.com/docs/reference/javascript/release-notes#typescript-support) after you have logged in, linked, and generated types through the Supabase CLI.\n\n```ts\n// src/app.d.ts\n\nimport { SupabaseClient, Session } from '@supabase/supabase-js';\nimport { Database } from './DatabaseDefinitions';\n\ndeclare global {\n  namespace App {\n    interface Locals {\n      supabase: SupabaseClient<Database>;\n      getSession(): Promise<Session | null>;\n    }\n    interface PageData {\n      session: Session | null;\n    }\n    // interface Error {}\n    // interface Platform {}\n  }\n}\n```\n\n## Client-side data fetching with RLS\n\nFor [row level security](https://supabase.com/docs/guides/auth/row-level-security) to work properly when fetching data client-side, you need to use supabaseClient from `PageData` and only run your query once the session is defined client-side:\n\n```html\n<!-- src/routes/profile/+page.svelte -->\n<script lang=\"ts\">\n  import type { PageData } from './$types';\n\n  export let data: PageData;\n\n  $: ({ supabase, session } = data);\n\n  let loadedData = [];\n  async function loadData() {\n    const { data } = await supabase.from('test').select('*').limit(20);\n    loadedData = data;\n  }\n\n  $: if (session) {\n    loadData();\n  }\n</script>\n\n{#if session}\n<p>client-side data fetching with RLS</p>\n<pre>{JSON.stringify(loadedData, null, 2)}</pre>\n{/if}\n```\n\n## Server-side data fetching with RLS\n\n```html\n<!-- src/routes/profile/+page.svelte -->\n<script lang=\"ts\">\n  import type { PageData } from './$types';\n\n  export let data: PageData;\n  $: ({ user, tableData } = data);\n</script>\n\n<div>Protected content for {user.email}</div>\n<pre>{JSON.stringify(tableData, null, 2)}</pre>\n<pre>{JSON.stringify(user, null, 2)}</pre>\n```\n\n```ts\n// src/routes/profile/+page.ts\nimport type { PageLoad } from './$types';\nimport { redirect } from '@sveltejs/kit';\n\nexport const load: PageLoad = async ({ parent }) => {\n  const { supabase, session } = await parent();\n  if (!session) {\n    throw redirect(303, '/');\n  }\n  const { data: tableData } = await supabase.from('test').select('*');\n\n  return {\n    user: session.user,\n    tableData\n  };\n};\n```\n\n## Protecting API routes\n\nWrap an API Route to check that the user has a valid session. If they're not logged in the session is `null`.\n\n```ts\n// src/routes/api/protected-route/+server.ts\nimport type { RequestHandler } from './$types';\nimport { json, error } from '@sveltejs/kit';\n\nexport const GET: RequestHandler = async ({ locals: { supabase, getSession } }) => {\n  const session = await getSession();\n  if (!session) {\n    // the user is not signed in\n    throw error(401, { message: 'Unauthorized' });\n  }\n  const { data } = await supabase.from('test').select('*');\n\n  return json({ data });\n};\n```\n\nIf you visit `/api/protected-route` without a valid session cookie, you will get a 401 response.\n\n## Protecting Actions\n\nWrap an Action to check that the user has a valid session. If they're not logged in the session is `null`.\n\n```ts\n// src/routes/posts/+page.server.ts\nimport type { Actions } from './$types';\nimport { error, fail } from '@sveltejs/kit';\n\nexport const actions: Actions = {\n  createPost: async ({ request, locals: { supabase, getSession } }) => {\n    const session = await getSession();\n\n    if (!session) {\n      // the user is not signed in\n      throw error(401, { message: 'Unauthorized' });\n    }\n    // we are save, let the user create the post\n    const formData = await request.formData();\n    const content = formData.get('content');\n\n    const { error: createPostError, data: newPost } = await supabase\n      .from('posts')\n      .insert({ content });\n\n    if (createPostError) {\n      return fail(500, {\n        supabaseErrorMessage: createPostError.message\n      });\n    }\n    return {\n      newPost\n    };\n  }\n};\n```\n\nIf you try to submit a form with the action `?/createPost` without a valid session cookie, you will get a 401 error response.\n\n## Saving and deleting the session\n\n```ts\nimport type { Actions } from './$types';\nimport { fail, redirect } from '@sveltejs/kit';\nimport { AuthApiError } from '@supabase/supabase-js';\n\nexport const actions: Actions = {\n  signin: async ({ request, locals: { supabase } }) => {\n    const formData = await request.formData();\n\n    const email = formData.get('email') as string;\n    const password = formData.get('password') as string;\n\n    const { error } = await supabase.auth.signInWithPassword({\n      email,\n      password\n    });\n\n    if (error) {\n      if (error instanceof AuthApiError && error.status === 400) {\n        return fail(400, {\n          error: 'Invalid credentials.',\n          values: {\n            email\n          }\n        });\n      }\n      return fail(500, {\n        error: 'Server error. Try again later.',\n        values: {\n          email\n        }\n      });\n    }\n\n    throw redirect(303, '/dashboard');\n  },\n\n  signout: async ({ locals: { supabase } }) => {\n    await supabase.auth.signOut();\n    throw redirect(303, '/');\n  }\n};\n```\n\n## Protecting multiple routes\n\nTo avoid writing the same auth logic in every single route you can use the handle hook to\nprotect multiple routes at once.\n\n```ts\n// src/hooks.server.ts\nimport type { RequestHandler } from './$types';\nimport { getSupabase } from '@supabase/auth-helpers-sveltekit';\nimport { redirect, error } from '@sveltejs/kit';\n\nexport const handle: Handle = async ({ event, resolve }) => {\n  // protect requests to all routes that start with /protected-routes\n  if (event.url.pathname.startsWith('/protected-routes')) {\n    const session = await event.locals.getSession();\n    if (!session) {\n      // the user is not signed in\n      throw redirect(303, '/');\n    }\n  }\n\n  // protect POST requests to all routes that start with /protected-posts\n  if (event.url.pathname.startsWith('/protected-posts') && event.request.method === 'POST') {\n    const session = await event.locals.getSession();\n    if (!session) {\n      // the user is not signed in\n      throw error(303, '/');\n    }\n  }\n\n  return resolve(event);\n};\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 4428],
		[3596, 5834],
		[3603, 5945],
		[3610, 5590],
		[3617, 5909],
		[3624, 5064],
		[3631, 5602],
		[3638, 5694],
		[3645, 3161],
		[3652, 3549],
		[3659, 4799],
		[3666, 4994],
		[3673, 5528],
		[3680, 4816],
		[3687, 5102],
		[3694, 5738],
		[3701, 5422],
		[3708, 7158],
		[3715, 5244],
		[3722, 5428],
		[3729, 4369],
		[3736, 4152],
		[3743, 4502],
		[3750, 4764],
		[3757, 4729],
		[3764, 4782],
		[3771, 4746],
		[3778, 3844],
		[3785, 4436],
		[3792, 3818],
		[3799, 4134],
		[3806, 3850],
		[3813, 4102],
		[3820, 4079],
		[3827, 3899],
		[3834, 3961],
		[3841, 4170],
		[3848, 4020],
		[3855, 4881],
		[3862, 4228],
		[3869, 4020],
		[3876, 4014],
		[3883, 4905],
		[3890, 4389],
		[3897, 4206],
		[3904, 4024],
		[3911, 3598],
		[3918, 4388],
		[3925, 3711],
		[3932, 3351],
		[3939, 3305],
		[3946, 3853],
		[3953, 4303],
		[3960, 4026],
		[3967, 4116],
		[3974, 3768],
		[3981, 3219],
		[3988, 3607],
		[3995, 2904],
		[4002, 3086],
		[4009, 1723],
		[4016, 2201],
		[4023, 2909],
		[4030, 4348],
		[4037, 3384],
		[4044, 3599],
		[4051, 3325],
		[4058, 3913],
		[4065, 3224],
		[4072, 3958],
		[4079, 3952],
		[4086, 3896],
		[4093, 3415],
		[4100, 2915],
		[4107, 3316],
		[4114, 3406],
		[4121, 2611],
		[4128, 2677]
	]
}
