{
	"name": "gettext-extractor-svelte",
	"description": "Extract gettext messages from Svelte files.",
	"repo_url": "https://github.com/floratmin/gettext-extractor-svelte",
	"authors": ["floratmin"],
	"homepage": "https://github.com/floratmin/gettext-extractor-svelte#readme",
	"downloads": 16,
	"updated": "2023-10-05T06:33:16.688Z",
	"tags": ["tooling"],
	"github_stars": 4,
	"typescript": true,
	"version": "5.1.0",
	"svelte_range": "^4.2.1",
	"last_rune_check_version": "5.1.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "gettext-extractor-svelte",
				"version": "5.1.0",
				"size": 126127
			},
			{
				"name": "@floratmin/svelte-fragment-divider",
				"version": "4.5.0",
				"size": 14554
			},
			{
				"name": "node-html-parser",
				"version": "6.1.13",
				"size": 165463
			},
			{
				"name": "he",
				"version": "1.2.0",
				"size": 124138
			},
			{
				"name": "css-select",
				"version": "5.1.0",
				"size": 224084
			},
			{
				"name": "boolbase",
				"version": "1.0.0"
			},
			{
				"name": "css-what",
				"version": "6.1.0",
				"size": 66038
			},
			{
				"name": "domhandler",
				"version": "5.0.3",
				"size": 75339
			},
			{
				"name": "domelementtype",
				"version": "2.3.0",
				"size": 11359
			},
			{
				"name": "domutils",
				"version": "3.2.2",
				"size": 166738
			},
			{
				"name": "dom-serializer",
				"version": "2.0.0",
				"size": 28813
			},
			{
				"name": "entities",
				"version": "4.5.0",
				"size": 412892
			},
			{
				"name": "nth-check",
				"version": "2.1.1",
				"size": 42555
			},
			{
				"name": "svelte",
				"version": "4.2.19",
				"size": 2633608
			},
			{
				"name": "acorn",
				"version": "8.14.1",
				"size": 547473
			},
			{
				"name": "code-red",
				"version": "1.0.4",
				"size": 55185
			},
			{
				"name": "@jridgewell/sourcemap-codec",
				"version": "1.5.0",
				"size": 112815
			},
			{
				"name": "@types/estree",
				"version": "1.0.7",
				"size": 26147
			},
			{
				"name": "estree-walker",
				"version": "3.0.3",
				"size": 17599
			},
			{
				"name": "periscopic",
				"version": "3.1.0",
				"size": 11219
			},
			{
				"name": "is-reference",
				"version": "3.0.3",
				"size": 3953
			},
			{
				"name": "css-tree",
				"version": "2.3.1",
				"size": 1190591
			},
			{
				"name": "mdn-data",
				"version": "2.0.30",
				"size": 602138
			},
			{
				"name": "source-map-js",
				"version": "1.2.1",
				"size": 139872
			},
			{
				"name": "aria-query",
				"version": "5.3.2",
				"size": 176114
			},
			{
				"name": "magic-string",
				"version": "0.30.17",
				"size": 467464
			},
			{
				"name": "axobject-query",
				"version": "4.1.0",
				"size": 110878
			},
			{
				"name": "locate-character",
				"version": "3.0.0",
				"size": 5325
			},
			{
				"name": "@ampproject/remapping",
				"version": "2.3.0",
				"size": 78946
			},
			{
				"name": "@jridgewell/gen-mapping",
				"version": "0.3.8",
				"size": 81596
			},
			{
				"name": "@jridgewell/set-array",
				"version": "1.2.1",
				"size": 17945
			},
			{
				"name": "@jridgewell/trace-mapping",
				"version": "0.3.25",
				"size": 169330
			},
			{
				"name": "@jridgewell/resolve-uri",
				"version": "3.1.2",
				"size": 53153
			},
			{
				"name": "gettext-extractor",
				"version": "3.8.0",
				"size": 72508
			},
			{
				"name": "@types/glob",
				"version": "7.2.0",
				"size": 6608
			},
			{
				"name": "@types/minimatch",
				"version": "5.1.2",
				"size": 12522
			},
			{
				"name": "@types/node",
				"version": "22.15.3",
				"size": 2350386
			},
			{
				"name": "undici-types",
				"version": "6.21.0",
				"size": 83680
			},
			{
				"name": "@types/parse5",
				"version": "5.0.3",
				"size": 20363
			},
			{
				"name": "css-selector-parser",
				"version": "1.4.1",
				"size": 38937
			},
			{
				"name": "glob",
				"version": "7.2.3",
				"size": 55064
			},
			{
				"name": "once",
				"version": "1.4.0"
			},
			{
				"name": "wrappy",
				"version": "1.0.2"
			},
			{
				"name": "inflight",
				"version": "1.0.6"
			},
			{
				"name": "inherits",
				"version": "2.0.4",
				"size": 3958
			},
			{
				"name": "minimatch",
				"version": "3.1.2",
				"size": 34902
			},
			{
				"name": "brace-expansion",
				"version": "1.1.11",
				"size": 11059
			},
			{
				"name": "balanced-match",
				"version": "1.0.2",
				"size": 6939
			},
			{
				"name": "concat-map",
				"version": "0.0.1"
			},
			{
				"name": "fs.realpath",
				"version": "1.0.0"
			},
			{
				"name": "path-is-absolute",
				"version": "1.0.1"
			},
			{
				"name": "parse5",
				"version": "6.0.1",
				"size": 331125
			},
			{
				"name": "pofile",
				"version": "1.0.11",
				"size": 126524
			},
			{
				"name": "typescript",
				"version": "5.8.3",
				"size": 22867703
			},
			{
				"name": "pofile",
				"version": "1.1.4",
				"size": 22479
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2],
			[2, 3],
			[2, 4],
			[4, 5],
			[4, 6],
			[4, 7],
			[7, 8],
			[4, 9],
			[9, 10],
			[10, 8],
			[10, 7],
			[10, 11],
			[9, 8],
			[9, 7],
			[4, 12],
			[12, 5],
			[1, 13],
			[13, 14],
			[13, 15],
			[15, 16],
			[15, 17],
			[15, 14],
			[15, 18],
			[18, 17],
			[15, 19],
			[19, 17],
			[19, 18],
			[19, 20],
			[20, 17],
			[13, 21],
			[21, 22],
			[21, 23],
			[13, 24],
			[13, 19],
			[13, 20],
			[13, 25],
			[25, 16],
			[13, 17],
			[13, 18],
			[13, 26],
			[13, 27],
			[13, 28],
			[28, 29],
			[29, 30],
			[29, 16],
			[29, 31],
			[31, 32],
			[31, 16],
			[28, 31],
			[13, 31],
			[13, 16],
			[0, 33],
			[33, 34],
			[34, 35],
			[34, 36],
			[36, 37],
			[33, 38],
			[33, 39],
			[33, 40],
			[40, 41],
			[41, 42],
			[40, 43],
			[43, 41],
			[43, 42],
			[40, 44],
			[40, 45],
			[45, 46],
			[46, 47],
			[46, 48],
			[40, 49],
			[40, 50],
			[33, 51],
			[33, 52],
			[33, 53],
			[0, 54],
			[0, 13]
		],
		"circular": []
	},
	"readme": "# [gettext-extractor](https://github.com/lukasgeiter/gettext-extractor) for svelte files\nThis extractor extracts also all the called functions and the function definition into a separate dictionary.\n\n### Installation\n\nnpm install gettext-extractor-svelte\n\n### Usage:\n\n```ts\nimport {\n    SvelteGettextExtractor, \n    callExpressionExtractor, \n    ICustomJsExtractorOptions,\n    FunctionExtractorBuilder\n} from 'gettext-extractor-svelte';\n\nconst extractor = new SvelteGettextExtractor();\nconst functionExtractor = new FunctionExtractorBuilder();\nconst findTranslationClassExpression = functionExtractor.variableDeclaration(\n    'Foo', functionExtractor.classExpression(undefined, [\n        functionExtractor.methodDeclaration('bar', true)\n    ])\n);\n\nconst options: ICustomJsExtractorOptions = {\n    arguments: {\n        text: 0,\n        context: 1,\n        comments: 2\n    },\n    comments: {\n        commentString: 'comment',\n        props: {\n            props: ['{', '}']\n        }\n    },\n    identifierKeys: ['text', 'context'],\n    translatorFunction: {\n        functionExtractor: findTranslationClassExpression,\n        identifier: 'translatorFunction',\n        restrictToFile: './src/translator.ts'\n    }\n}\n\nextractor.createSvelteParser()\n    .addExtractor(callExpressionExtractor('t', options))\n    .parseFilesGlob('./src/**/*.svelte');\n\nconst messages = extractor.getMessages();\nconst functionDict = extractor.getFunctions();\nconst messageDict = extractor.getMessageDictionary();\n```\nFrom the following svelte file named `src/App.svelte`:\n```sveltehtml\n<script lang=\"ts\">\n    import { t } from './translator-function';\n    import Component from './Component.svelte';\n    export let place: string;\n    let caption = t(\n        'FooCaption', \n        'Context', \n        {comment: 'Comment', path: 'https://www.example.com'}\n    );\n</script>\n\n<body>\n    <h1>{caption}</h1>\n    <p>{t('Foo')}</p>\n    {#each [t('Bar'), t('Baz')] as text}\n        <p>{text}</p>\n        <Component label=\"{t('Bax', 'Context', {comment: 'Comment'})}\">\n            {t(\n                'Hello {PLACE}', \n                'Context', \n                { \n                    comment: 'Multiline\\nComment', \n                    props: {PLACE: 'The place where you are'},\n                    messageformat: 'This could be a messageformat function'\n                },\n                {PLACE: place}\n            )}\n        </Component>\n    {/each}\n</body>\n```\nand the following translation function in file `src/translator.ts`:\n```ts\nlet foo = class Bar {\n    bar(translationObject: any) {\n        return 'I am translated';\n    }\n}\n```\nwe extract the following messages:\n```js\n[\n    {\n        text: 'FooCaption',\n        context: 'Context',\n        comments: [\n            'Comment',\n            'path: https://www.example.com'\n        ],\n        references: [\n            'src/App.svelte:5'\n        ],\n    },\n    {\n        text: 'Foo',\n        references: [\n            'src/App.svelte:14'\n        ],\n    },\n    {\n        text: 'Bar',\n        references: [\n            'src/App.svelte:15'\n        ],\n    },\n    {\n        text: 'Baz',\n        references: [\n            'src/App.svelte:15'\n        ],\n    },\n    {\n        text: 'Bax',\n        context: 'Context',\n        comments: [\n            'Comment',\n        ],\n        references: [\n            'src/App.svelte:17'\n        ],\n    },\n    {\n        text: 'Hello {PLACE}',\n        context: 'Context',\n        comments: [\n            'Multiline',\n            'Comment',\n            'messageformat: This could be a messageformat function',\n            '{PLACE}: The place where you are'\n        ],\n        references: [\n            'src/App.svelte:18'\n        ],\n    },\n]\n```\nthe following functions:\n```js\n{\n    'src/App.svelte': [\n        {\n            functionString: `_(\n        'FooCaption',\n        'Context',\n        {comment: 'Comment', path: 'https://www.example.com'}\n    )`,\n            functionData: {\n                functionName: '_',\n                functionArgs: []\n            },\n            identifier: '{\"text\":\"FooCaption\",\"context\":\"Context\"}',\n            startChar: 162,\n            endChar: 273\n        },                \n        {\n            functionString: \"_('Foo')\",\n            functionData: {\n                functionName: '_',\n                functionArgs: []\n            },\n            identifier: '{\"text\":\"Foo\"}',\n            startChar: 324,\n            endChar: 332\n        },\n        {\n            functionString: \"_('Bar')\",\n            functionData: {\n                functionName: '_',\n                functionArgs: []\n            },\n            identifier: '{\"text\":\"Bar\"}',\n            startChar: 350,\n            endChar: 358\n        },\n        {\n            functionString: \"_('Baz')\",\n            functionData: {\n                functionName: '_',\n                functionArgs: []\n            },\n            identifier: '{\"text\":\"Baz\"}',\n            startChar: 360,\n            endChar: 368\n        },\n        {\n            functionString: \"_('Bax')\",\n            functionData: {\n                functionName: '_',\n                functionArgs: []\n            },\n            identifier: '{\"text\":\"Bax\"}',\n            startChar: 428,\n            endChar: 436\n        },\n        {\n            functionString: `_(\n                'Hello {PLACE}',\n                'Context',\n                {\n                    comment: 'Multiline\\\\nComment',\n                    props: {PLACE: 'The place where you are'},\n                    messageformat: 'This could be a messageformat function'\n                },\n                {PLACE: place}\n            )`,\n            functionData: {\n                functionName: '_',\n                functionArgs: ['{PLACE: place}']\n            },\n            identifier: '{\"text\":\"Hello {PLACE}\",\"context\":\"Context\"}',\n            startChar: 486,\n            endChar: 820\n        } \n    ],\n    'src/translator.ts': [\n        {\n            functionString:\n`bar(translationObject: any) {\n        return 'I am translated';\n    }`,\n            identifier: 'translatorFunction',\n            definition: true, // marks that this entry is an extracted translation function\n            startChar: 26,\n            endChar: 95\n        }\n    ]\n}\n```\nand the mapping of identifiers to text as an object\n```js\n{\n    '{\"text\":\"Foo\"}': 'Foo',\n    '{\"text\":\"Bar\"}': 'Bar',\n    '{\"text\":\"Baz\"}': 'Baz',\n    '{\"text\":\"Bax\"}': 'Bax',\n    '{\"text\":\"FooCaption\",\"context\":\"Context\"}': 'FooCaption',\n    '{\"text\":\"Hello {PLACE}\",\"context\":\"Context\"}': 'Hello {PLACE}'\n}\n\n```\n### Additional methods for SvelteGettextExtractor\n\n### &nbsp;&nbsp;`createSvelteParser()`\nCreate parser for parsing `.svelte` files\n\n##### Return Value\n*SvelteParser* · Can be used in the same way as parser created with [`createJsParser()`](https://github.com/lukasgeiter/gettext-extractor/wiki/API-Reference#createjsparserextractors), except the following added parse option:\n\n| **Name**              | **Type**                                           | **Details**                                           |\n|-----------------------|----------------------------------------------------|-------------------------------------------------------|\n| `options`             | *object*                                           | Additional parse option                               |\n| `translatorFunctions` | *TTranslatorFunction &vert; TTranslatorFunction[]* | Translation Function Definition to extract functions. |\n\n### <a id=\"get-functions\"></a>&nbsp;&nbsp;`getFunctions()`\nGets all parsed function calls\n\n##### Return Value\n*object* · Dictionary with keys of file name and values of a list of function objects with properties as described below\n\n| **Name**              | **Type**   | **Details**                                                                |\n|-----------------------|------------|----------------------------------------------------------------------------|\n| `functionString`      | *string*   | String of the function call in the source code                             |\n| `functionData`        | *object*   | Object containing keys functionName and functionArgs                       |\n| →&nbsp;`functionName` | *string*   | Name of the called function                                                |\n| →&nbsp;`functionArgs` | *string[]* | Arguments without arguments defining text, textPlural, context and comment |\n| `identifier`          | *string*   | Identifier string constructed trough options.identifierKeys                |\n| `definition`          | *true*     | When set marks that string is part of translation function definition      |\n| `startChar`           | *number*   | Index where the function call string starts                                |\n| `endChar`             | *number*   | Index where the function call string ends                                  |\n\n### &nbsp;&nbsp;`getLastAddedFunctions()`\nReceive array of functions, which got added in the last call of `parseJsString`, `parseSvelteString`.\n\n##### Return Value\n*array* · Same as values of dictionary described in [`getFunctions()`](#get-functions)\n\n### &nbsp;&nbsp;`getFunctionsByFileName(fileName)`\nGets all parsed function calls in a file\n\n#### Parameters\n| **Name**   | **Type** | **Details**                 |\n|------------|----------|-----------------------------|\n| `fileName` | *string* | **Required** · Name of file |\n\n##### Return Value\n*array* · Same as values of dictionary described in [`getFunctions()`](#get-functions)\n\n### &nbsp;&nbsp;`saveFunctionJSON(fileName)`\nSave functions dictionary as a JSON file.\n\n#### Parameters\n| **Name**   | **Type** | **Details**                 |\n|------------|----------|-----------------------------|\n| `fileName` | *string* | **Required** · Name of file |\n\n#### Return Value\n*void*\n\n### &nbsp;&nbsp;`saveFunctionJSONAsync(fileName)`\nSave functions dictionary as a JSON file asynchronously.\n\n#### Parameters\n| **Name**   | **Type** | **Details**                 |\n|------------|----------|-----------------------------|\n| `fileName` | *string* | **Required** · Name of file |\n\n#### Return Value\n*Promise*\n\n### &nbsp;&nbsp;`getMessageDictionary()`\nRecieve a dictionary mapping message text to function identifiers.\n\n##### Return Value\n*object* · Dictionary with identifier strings as keys and message text as value\n\n###  <a id=\"get-messages-with-id\"></a>&nbsp;&nbsp;`getMessagesWithId()`\nRecieve array of messages with identifier.\n\n##### Return Value\n| **Name**     | **Type**   | **Details**                                                   |\n|--------------|------------|---------------------------------------------------------------|\n| `text`       | *string*   | Message string                                                |\n| `textPlural` | *string*   | Plural version of the message string                          |\n| `context`    | *string*   | Message context                                               |\n| `references` | *string[]* | Array of file references where the message was extracted from |\n| `comments`   | *string[]* | Array of comments for this message                            |\n| `identifier` | *string*   | Identifier string constructed trough options.identifierKeys   |\n\n### &nbsp;&nbsp;`getLastAddedMessages()`\nReceive array of messages with identifier, which got added in the last call of `parseJsString`, `parseSvelteString` or `parseHtmlString`.\n\n##### Return Value\n*array* · List of message objects (same properties as for [`getMessagesWithId()`](#get-messages-with-id))\n\n### &nbsp;&nbsp;`getTransformedMessages<T = any>(func: (messages: IMessage[]) => T)`\nTransform message object with custom function.\n\n#### Parameters\n| **Name**   | **Type** | **Details**                 |\n|------------|----------|-----------------------------|\n| `func` | *(messages: IMessage[]) => T* | **Required** · Transformer function |\n\n##### Return Value\n*T* · Depends on your function\n\nFor all other available options please look at the package [gettext-extractor](https://github.com/lukasgeiter/gettext-extractor)\n\n# JS Parser for [gettext-extractor](https://github.com/lukasgeiter/gettext-extractor)\n\nExtract comments provided by a string or an object in the translator function.\n\n```ts\nimport { callExpressionExtractor, ICustomJsExtractorOptions } \n    from 'gettext-extractor-svelte';\nimport { GettextExtractor } from 'gettext-extractor'; // Works also with SvelteGettextExtractor\n\nconst options: ICustomJsExtractorOptions = {\n    arguments: {\n        text: 0,\n        textPlural: 1,\n        comments: 2,\n        context: 3,\n    },\n    comments: {\n        commentString: 'comment',\n        props: {\n            props: ['{', '}']\n        }\n    }\n};\n\nconst extractor = new GettextExtractor();\n\nextractor\n    .createJsParser()\n    .addExtractor(callExpressionExtractor('_', options))\n    .parseFilesGlob('src/**/*.@(ts|js|tsx|jsx)');\n```\n\n### `callExpressionExtractor(calleeName, options)`\n\n#### Parameters\n| Name          | Type   | Details                                                                 |\n|---------------|--------|-------------------------------------------------------------------------|\n| `calleeName`  | *string* or<br>*string[]* | **Required** · Name(s) of the function(s)            |\n| `options`     | *object*                  | Options to configure the extractor function          |\n| → `arguments` | *object*                  | **Required** · See [Argument Mapping](#argument-mapping) below          |\n| → `comments`  | *object*                  | See [Comment Options](#comment-options) below                           |\n| → `identifierKeys`  | *<'text' &vert; 'textPlural' &vert; 'context'>[]* | Fields for constructing ids to map messages to functions, defaults to all. At least one of these keys should match each message function. Defaults to `['text', 'context']` |\n| →&nbsp;`translatorFunction` | *object* | See [Translator Function Options](#translator-function-options) below      |\n| → `content`   | *object*                  | See [Content Options](#content-options) below                           |\n\n##### <a id=\"argument-mapping\"></a>Argument Mapping\n| Name          | Type     | Details                                                             |\n|---------------|----------|---------------------------------------------------------------------|\n| `text`        | *number* | **Required** · Position of the argument containing the message text |\n| `textPlural`  | *number* | Position of the argument containing the plural message text         |\n| `context`     | *number* | Position of the argument containing the message context             |\n| `comments`    | *number* | Position of the argument containing the comments string or object   |\n\n##### <a id=\"comment-options\"></a>Comment Options\nIf ommitted the comment is expected to be a string. If fallback is true, the comment has to be an object, otherwise it can be a string or an object.\n\n| Name                 | Type      | Default   | Details                                                               |\n|----------------------|-----------|-----------|-----------------------------------------------------------------------|\n| `commentString`      | *string*  | `comment` | Key for providing plain comments                                      |\n| `props`              | *object*  |           | Each key under `props` has a value of an array with two strings. In the comment object we can provide key value pairs under each key defined under `props`. Each of these keys gets wrapped in between the provided two strings. Then after a semicolon the value is concatenated. |\n| `throwWhenMalformed` | *boolean* | `true`    | If set to `true`, throws an error when in the comment object any value is not a plain string |\n| `fallback`           | *boolean* | `false`   | If set to `true`, an omitted argument fallbacks to the next argument if the next argument is of different type|\n\nIf not trough commentString or props specified keys are used in the comment object, then these keys (concatenated with dots when they are nested) are added\nto the comments with a semicolon followed by the value of the key.\n\n##### <a id=\"content-options\"></a>Content Options\n| Name                  | Type                    | Default   | Details                                                |\n|-----------------------|-------------------------|-----------|--------------------------------------------------------|\n| `trimWhiteSpace`      | *boolean*               | `false`   | If set to `true`, white space at the very beginning and at the end of the content will get removed<br>Normally this behaves like `.trim()`, however if `preseveIndentation` is `true`, the indentation of the first line is kept as well.|\n| `preserveIndentation` | *boolean*               | `true`    | If set to `false`, white space at the beginning of the line will get removed |\n| `replaceNewLines`     | *false* or <br>*string* | `false`   | If a string is provided all new lines will be replaced with it |\n\n##### <a id=\"translator-function-options\"></a>Function Extractor Options\n| Name                  | Type                    | Default   | Details                                                                           |\n|-----------------------|-------------------------|-----------|-----------------------------------------------------------------------------------|\n| `functionExtractor`   | *FunctionExtractor*     |           | The function extractor describing the typescript nodes of the function to extract |\n| `identifier`          | *string*                |           | The identifier under which the function will be added to the dict                 |\n| `restrictToFile`      | *string*                |           | When set than only the specified file will be parsed for the function             |\n\n##### Return Value\n*function* · An extractor function that extracts messages from call expressions.\n\n#### Example\nWith the example settings from the usage example and the following functions\n```ts\n// We can provide comments as string\nconst string1 = _(\n    'Foo',\n    'Plural',\n    'Comment',\n    'Context'\n);\n// Or we can provide comments as object\nconst string2 = _(\n    'Hello {PLACE}',\n    'Plural',\n    {\n        comment: 'Comment',\n        props: {\n            PLACE: 'The place of interest'\n        },\n        path: 'https://www.example.com',\n        nested: {\n            key1: 'Key1',\n            key2: 'Key2'\n        }\n    }\n);\n// When type of argument does not match declared type, then all following arguments are ignored\nconst string3 = _(\n    'Foo2',\n    {\n        comment: 'Comment'\n    },\n    'Context'\n)\n// We can omit empty arguments with `null`, `undefined` or `0`\nconst string4 = _(\n    'Foo3',\n    null,\n    null,\n    'Context'\n);\n```\nWe extract the following messages\n```ts\n[\n    {\n        text: 'Foo',\n        textPlural: 'Plural',\n        coments: ['Comment'],\n        context: 'Context'\n    },\n    {\n        text: 'Hello {PLACE}',\n        textPlural: 'Plural',\n        comments: [\n            'Comment',\n            'path: https://www.example.com',\n            '{PLACE}: The place of interest',\n            'nested.key1: Key1',\n            'nested.key2: Key2'\n        ]\n    },\n    {\n        text: 'Foo2'\n    },\n    {\n        text: 'Foo3',\n        context: 'Context'\n    }\n]\n```\nIf we have the option `fallback: true` set:\n```ts\nconst options: ICustomJsExtractorOptions = {\n    arguments: {\n        text: 0,\n        textPlural: 1,\n        comments: 2,\n        context: 3,\n    },\n    comments: {\n        commentString: 'comment',\n        props: {\n            props: ['{', '}']\n        },\n        fallback: true\n    }\n};\n\n```\nand the following functions\n```ts\nconst string1 = (worldPlace: string) => _(\n    'Hello {PLACE}', \n    'Plural', \n    {\n        comment: 'Comment', \n        props: {\n            PLACE: 'The place of interest'\n        }, \n        path: 'http://www.example.com', \n        nested: {\n            key1: 'Key1',\n            key2: 'Key2'\n        }\n    },\n    'Context',\n    {\n        PLACE: worldPlace\n    }\n);\n// when omitting the second argument the third argument can take the place of the second argument \n// if the arguments are of different type. If there are more arguments, they also change their\n// place accordingly.\nconst string2 = _(\n    'Foo',\n    {\n        comment: 'No Plural here.'\n    }\n);\n// omit comment object\nconst string3 = _(\n    'Foo2',\n    'Plural',\n    'Context'\n);\n// skip textPlural and comment object, allowed placeholders are `null`, `undefined` or `0`\nconst string4 = _(\n    'Foo3',\n    null,\n    null,\n    'Context'\n);\n// if argument is not string or comment object than rest of arguments are ignored\nconst string5 = (props: {PROPS: string}) => _(\n    'My {PROPS}',\n    {\n        props: {\n            PROPS: 'Some props'\n        }\n    },\n    props\n);\n```\n\nwe extract the following messages\n```js\n[\n    {\n        text: 'Hello {PLACE}',\n        textPlural: 'Plural',\n        comments: [\n            'Comment',\n            'path: http://www.example.com',\n            '{PLACE}: The place of interest',\n            'nested.key1: Key1',\n            'nested.key2: Key2'\n        ],\n        context: 'Context'\n    },\n    {\n        text: 'Foo',\n        comments: [\n            'No Plural here.'\n        ],\n    },\n    {\n        text: 'Foo2',\n        textPlural: 'Plural',\n        context: 'Context'\n    },\n    {\n        text: 'Foo3',\n        context: 'Context'\n    },\n    {\n        text: 'My {PROPS}',\n        comments: [\n            '{PROPS}: Some props'\n        ]\n    }\n]\n```\nIf any argument is not a string or comment object then the parsing is cut off starting from this argument. If there are\nother arguments in between these arguments, their position is not considered in the fallback.\n\n# JS Node Parser for [gettext-extractor](https://github.com/lukasgeiter/gettext-extractor)\nExtracts nodes provided by `TTranslatorFunction` or by providing `TTranslatorFunction[]` on each `.parseString` or `.parseSvelteString` method call.\n\n```ts\nimport { nodeExtractor, TTranslatorFunction, FunctionExtractorBuilder, SvelteGettextExtractor } from 'gettext-extractor-svelte';\n\nconst functionExtractor = new FunctionExtractorBuilder();\nconst importDeclaration = functionExtractor.importDeclaration(\n    './translations',\n    functionExtractor.importClause(\n        't'\n    ),\n    true,\n);\n\nconst translatorFunctions: TTranslatorFunction[] = [\n    {\n        identifier: 'translationFunctionImport',\n        functionName: 't',\n        functionExtractor: importDeclaration\n    }\n];\n\nconst extractor = new SvelteGettextExtractor();\n\nextractor.createJsParser()\n    .addExtractor(nodeExtractor())\n    .parseString('import t from \"./translations\";', 'src/app.js', {translatorFunctions});\n\nextractor.getFunctions() === {\n    'src/app.js': [\n        {\n            functionString: 'import t from \"./translations\";',\n            functionData: {\n                functionName: 't',\n                functionArgs: []\n            },\n            startChar: 0,\n            endChar: 31,\n            identifier: 'translationFunctionImport',\n            definition: true\n        }\n    ]\n}; // true\n```\n\n### `nodeExtractor(translatorFunction)`\n\n#### Parameters\n| Name          | Type   | Details                                                                 |\n|---------------|--------|-------------------------------------------------------------------------|\n| `translatorFunction` | *TTranslatorFunction* or *TTranslatorFunction[]* | See [Translator Function Options](#translator-function-options2) below      |\n\n##### <a id=\"translator-function-options2\"></a>Function Extractor Options\n| Name                  | Type                    | Default   | Details                                                                           |\n|-----------------------|-------------------------|-----------|-----------------------------------------------------------------------------------|\n| `functionExtractor`   | *FunctionExtractor*     |           | The function extractor describing the typescript nodes of the function to extract |\n| `identifier`          | *string*                |           | The identifier under which the function will be added to the dict                 |\n| `restrictToFile`      | *string*                |           | When set than only the specified file will be parsed for the function             |\n# Function Extractor Builder\n\n```js\nimport {\n    FunctionExtractorBuilder\n} from 'gettext-extractor-svelte';\n\nconst functionExtractor = new FunctionExtractorBuilder();\n```\n## Methods for FunctionExtractorBuilder\n\n### &nbsp;&nbsp;`objectLiteralExpression(properties?, getPos?)`\nMarks object literal expressions\n\n#### Parameters\n| **Name**     | **Type**               | **Default** | **Details**                                                                |\n|--------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `properties` | *FunctionExtractor []* |             | List of function extractors defining the properties of the object          |\n| `getPos`     | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`variableDeclaration(variableName, initializer?, getPos?)`\nMarks variable declarations\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `variableName` | *string*               |             | **Required** · Name of declared variable                                   |\n| `initializer`  | *FunctionExtractor*    |             | Function extractor defining the initializer                                |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`propertyAssignment(keyName, initializer?, getPos?)`\nMarks property assignment\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `keyName`      | *string*               |             | **Required** · Name of property                                            |\n| `initializer`  | *FunctionExtractor*    |             | Function extractor defining the initializer                                |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`methodDeclaration(methodName, getPos?)`\nMarks method declaration\n\n#### Parameters\n| **Name**     | **Type**               | **Default** | **Details**                                                                |\n|--------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `methodName` | *string*               |             | **Required** · Name of method                                              |\n| `getPos`     | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`arrowFunction(getPos?)`\nMarks arrow function\n\n#### Parameters\n| **Name**     | **Type**               | **Default** | **Details**                                                                |\n|--------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `getPos`     | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`propertyDeclaration(propertyName, initializer?, getPos?)`\nMarks property declaration\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `propertyName` | *string*               |             | **Required** · Name of property                                            |\n| `properties`   | *FunctionExtractor*    |             | Function extractor defining the initializer                                |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`functionDeclaration(functionName, getPos?)`\nMarks function declaration\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `functionName` | *string*               |             | **Required** · Name of function declaration                                                |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`functionExpression(functionName?, getPos?)`\nMarks function expression\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `functionName` | *string*               |             | Name of function expression                                                |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`classDeclaration(className, members?, getPos?)`\nMarks class declarations\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `className`    | *string*               |             | **Required** · Name of class                                               |\n| `members`      | *FunctionExtractor[]*  |             | Array of function extractors defining the members of the class             |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`classExpression(className?, members?, getPos?)`\nMarks class expression\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `className`    | *string*               |             | Name of class                                                              |\n| `members`      | *FunctionExtractor[]*  |             | Array of function extractors defining the members of the class             |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`getAccessor(accessorName, body?, getPos?)`\nMarks get accessor\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `accessorName` | *string*               |             | **Required** · Name of accessor                                            |\n| `body`         | *FunctionExtractor*    |             | Function extractor defining the body of the get accessor                   |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`setAccessor(accessorName, body?, getPos?)`\nMarks set accessor\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `accessorName` | *string*               |             | **Required** · Name of accessor                                            |\n| `body`         | *FunctionExtractor*    |             | Function extractor defining the body of the set accessor                   |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`expressionStatement(identifier, right?, getPos?)`\nMarks expression statement\n\n#### Parameters\n| **Name**       | **Type**               | **Default** | **Details**                                                                |\n|----------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `identifier`   | *string*               |             | **Required** · Name of identifier on the left side of expression statement |\n| `right`        | *FunctionExtractor*    |             | Function extractor defining the right side of the expression statement     |\n| `getPos`       | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`labeledStatement(statement?, getPos?)`\nMarks labeled statement\n\n#### Parameters\n| **Name**     | **Type**               | **Default** | **Details**                                                                |\n|--------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `statement`  | *FunctionExtractor*    |             | Function extractor for defining the right side of the labeled statement    |\n| `getPos`     | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`importDeclaration(moduleSpecifier, importClause?, getPos?)`\nMarks import declaration\n\n#### Parameters\n| **Name**          | **Type**               | **Default** | **Details**                                                                |\n|-------------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `moduleSpecifier` | *string*               |             | **Required** · Name of module imported in this declaration                 |\n| `importClause`    | *FunctionExtractor*    |             | Function extractor defining the import clause                              |\n| `getPos`          | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`importClause(name?, elements?, getPos?)`\nMarks import clause\n\n#### Parameters\n| **Name**          | **Type**               | **Default** | **Details**                                                                |\n|-------------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `name`            | *string*               |             | Name of main import in this clause                                         |\n| `elements`        | *FunctionExtractor[]*  |             | List of function extractors defining the imported elements                 |\n| `getPos`          | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`importSpecifier(name, getPos?)`\nMarks import specifier\n\n#### Parameters\n| **Name**          | **Type**               | **Default** | **Details**                                                                |\n|-------------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `name`            | *string*               |             | Name of import in this specifier                                           |\n| `getPos`          | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`variableStatment(declarations?, getPos?)`\nMarks variable statement\n\n#### Parameters\n| **Name**          | **Type**               | **Default** | **Details**                                                                |\n|-------------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `declarations`    | *FunctionExtractor[]*  |             | List of variable declared in this statement                                |\n| `getPos`          | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n\n### &nbsp;&nbsp;`newExpression(name, getPos?)`\nMarks new expression\n\n#### Parameters\n| **Name**          | **Type**               | **Default** | **Details**                                                                |\n|-------------------|------------------------|-------------|----------------------------------------------------------------------------|\n| `name`            | *string*               |             | Name of new expression                                                     |\n| `getPos`          | *boolean*              | `false`     | Return start and end position in call expression to extract node as string |\n\n##### Return Value\n*FunctionExtractor* \n",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 2],
		[3596, 57],
		[3610, 3],
		[3617, 5],
		[3631, 2],
		[3638, 1],
		[3645, 6],
		[3659, 3],
		[3666, 35],
		[3673, 28],
		[3687, 1],
		[3701, 27],
		[3708, 1],
		[3715, 1],
		[3722, 4],
		[3729, 1],
		[3736, 1],
		[3743, 1],
		[3750, 3],
		[3757, 3],
		[3764, 12],
		[3771, 20],
		[3778, 1],
		[3785, 1],
		[3792, 3],
		[3799, 1],
		[3806, 2],
		[3813, 2],
		[3827, 1],
		[3834, 3],
		[3841, 12],
		[3848, 1],
		[3855, 132],
		[3862, 6],
		[3869, 2],
		[3876, 2],
		[3883, 6],
		[3890, 30],
		[3897, 4],
		[3904, 1],
		[3911, 3],
		[3918, 4],
		[3925, 1],
		[3939, 3],
		[3946, 1],
		[3953, 3],
		[3960, 3],
		[3981, 3],
		[3988, 2],
		[3995, 9],
		[4002, 2],
		[4009, 4],
		[4016, 9],
		[4023, 1],
		[4030, 3],
		[4037, 38],
		[4044, 31],
		[4051, 7],
		[4058, 2],
		[4065, 3],
		[4079, 1],
		[4086, 14],
		[4093, 28],
		[4100, 56],
		[4107, 6],
		[4114, 16],
		[4121, 13],
		[4128, 36]
	],
	"esm": false,
	"cjs": true
}
