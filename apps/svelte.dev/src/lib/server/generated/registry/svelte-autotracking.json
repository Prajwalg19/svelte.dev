{
	"name": "svelte-autotracking",
	"description": "Simplify Svelte store usage with autotracking and decorators.",
	"repo_url": "https://github.com/manufitoussi/svelte-autotracking",
	"authors": ["manufitoussi"],
	"homepage": "https://github.com/manufitoussi/svelte-autotracking",
	"downloads": 47,
	"updated": "2024-05-04T23:51:27.790Z",
	"tags": ["miscellaneous"],
	"github_stars": 2,
	"typescript": true,
	"version": "0.2.0",
	"svelte_range": "^4.2.12",
	"last_rune_check_version": "0.2.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-autotracking",
				"version": "0.2.0",
				"size": 39102
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# Svelte Autotracking\n\n![example workflow](https://github.com/manufitoussi/svelte-autotracking/actions/workflows/ci.yml/badge.svg)\n\n\n> A library to automatically track changes on Svelte stores with decorators.\n\nIt's freely inspired by the [`@tracked` decorator](https://api.emberjs.com/ember/release/functions/@glimmer%2Ftracking/tracked) from Ember.js, and it's meant to be used with [Svelte stores](https://svelte.dev/docs/svelte-store).\n\nIf you're using Svelte stores, you know that you need create complex logic (like derived stores and custom store) to track changes on your components. Even the simplest of them.\n\nThis library aims to simplify this process by providing a set of decorators and helpers that you can use to :\n- automatically track changes on your object logic\n- and automaticaly create stores to be cosumed by your components.\n\n> You have just to concentrate on your logic, create your objects and let the library handle the rest.\n\n## Example\n\nYou can create a class with autotracking capabilities by extending the `Autotracking` class and using the `@tracked` decorator on the properties you want to track.\n\n```ts\n\nimport { Autotracking, tracked } from \"svelte-autotracking\";\n\n/**\n * Counter class with autotracking capabilities.\n */\nexport class Counter extends Autotracking {\n\n  @tracked\n  _count = 0;\n\n  get count() {\n    return this._count;\n  }\n\n  increment() {\n    this._count += 1;\n  }\n\n  decrement() {\n    this._count -= 1;\n  }\n\n}\n\n```\n\nAnd then, you can use it in your Svelte components like this:\n\n```html\n<script>\n  import { Counter } from \"./Counter.js\";\n  import { useStore } from \"svelte-autotracking\";\n\n  const counter = useStore(new Counter());\n</script>\n\n<h1>{$counter.count}</h1>\n<button on:click={() => $counter.increment()}>+</button>\n<button on:click={() => $counter.decrement()}>-</button>\n```\n\nSo, when you click on the buttons, the `count` property will be automatically updated and the component will re-render. And even if you create a derived class from the `Counter`.\n\n\n## Installation\n\n```bash\nnpm install svelte-autotracking\n```\n\nor \n\n```bash\nyarn add svelte-autotracking\n```\n\n## Requirements : Decorators\n\nThis library uses the [decorators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields#decorators) feature of JavaScript, which is currently a stage 2 proposal. So, you need to enable it in your project.\n\nIf you're using TypeScript, you can enable it by adding the following configuration to your `tsconfig.json` file:\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"target\": \"ES6\" // or higher\n  }\n}\n```\n\nIf you're using Babel, you can enable it by installing the `@babel/plugin-proposal-decorators` plugin:\n\n```bash \nnpm install --save-dev @babel/plugin-proposal-decorators\n```\n\nAnd then, add it to your Babel configuration:\n\n```json\n{\n  \"plugins\": [\n    [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }]\n  ]\n}\n```\n\n\n---\n\n\n## How to use this library\n\n### `Autotracking` class\n\nYou can create a class with autotracking capabilities by extending the `Autotracking` class.\n\n```ts\nimport { Autotracking } from \"svelte-autotracking\";\n\nclass MyClass extends Autotracking {\n  // your code here\n}\n```\n\n### `@tracked` decorator\n\nYou can use the `@tracked` decorator to automatically track changes on the properties of your class.\n\n```ts\nimport { Autotracking, tracked } from \"svelte-autotracking\";\n\nexport class MyClass extends Autotracking {\n  @tracked\n  property = \"value\";\n\n  method(newValue: string) {\n    this.property = newValue;\n  }\n}\n```\n\nSo, when you change the `property` value, the component will re-render. even :\n  - if you change the value directly\n  - if you change the value in a method (like `method` in the example above)\n  - if you change the value in a nested object\n  - if you derive a new class from `MyClass`\n\n\n### `useStore` function\n\nYou can use the `useStore` function to create a store from an instance of a class with autotracking capabilities.\n\n```ts\nimport { MyClass } from \"./MyClass.js\";\n\nconst myClass = new MyClass();\nconst store = useStore(myClass);\n```\n\nAnd then, you can use the `store` in your Svelte components like this:\n\n```html\n<script>\n  import { MyClass } from \"./MyClass.js\";\n  import { useStore } from \"svelte-autotracking\";\n\n  const myClass = new MyClass();\n  const store = useStore(myClass);\n</script>\n\n<h1>{$store.property}</h1>\n<button on:click={() => $store.property = \"new value\"}>Change value</button>\n<button on:click={() => $store.method(\"another new value\")}>Change value by method</button>\n```\n\nSo, when you click on the buttons, the `property` value will be automatically updated and the component will re-render.\n\n### Add capabilities to an existing class\n\nYou can add autotracking capabilities to class by using the `Autotracked` decorator.\n\n```ts\nimport { Autotracked, tracked, type IAutotrackable } from \"svelte-autotracking\";\n\n@Autotracked\nexport class MyClass {\n  \n  @tracked\n  property = \"value\";\n\n  method(newValue: string) {\n    this.property = newValue;\n  }\n}\n\ninterface MyClass extends IAutotrackable<Named> { }\n\n```\nIn this example, the `MyClass` class will have autotracking capabilities, and you can use it in your Svelte components.\n\n> ⚠️ Don't forget to add the `IAutotrackable` interface to the class.<br>\n> The `@Autotracked` decorator is a class decorator that adds the autotracking capabilities to the class. And the `IAutotrackable` interface is a generic interface that extends the `IAutotrackable` interface with the properties of the class. Without it, in the component, you will not have class features recognition.\n\n### use the `@tracked` decorator in a nested object\n\nSometimes, you may want to track changes on a nested object. You can do this by using the `@tracked` decorator on the properties of the nested object and declaring the nested object as autotrackable but by using its parent class.\n\n```ts\nimport { Autotracking, AutotrackingFromStore, tracked, type IAutotrackable } from 'svelte-autotracking';\n\nexport class Owner extends Autotracking {\n  nested: Nested;\n\n  constructor() {\n    super();\n    this.nested = new Nested(this);\n  }\n}\n\ninterface INested extends IAutotrackable<Owner> {\n  owner: Owner;\n}\n\nexport default class Nested extends AutotrackingFromStore(\n  // function to get the owner that brings the autotracking capabilities\n  function (this: INested) { return this.owner; }\n) implements INested {\n\n  owner: Owner;\n\n  @tracked\n  count = 0;\n\n  constructor(owner: Owner) {\n    super();\n    this.owner = owner;\n  }\n\n  increment() {\n    this.count++;\n  }\n\n  decrement() {\n    this.count--;\n  }\n}\n\n```\n\nIn this example, the `Nested` class is a nested object of the `Owner` class. And the `Owner` class is the parent class of the `Nested` class. So, you can use the `@tracked` decorator on the properties of the `Nested` class and declare the `Nested` class as autotrackable by using the `IAutotrackable` interface with the `Owner` class.\n\nAnd then, you can use the `Nested` class in your Svelte components like this:\n\n```html\n<script>\n  import { Owner } from \"./Owner.js\";\n  import { useStore } from \"svelte-autotracking\";\n\n  const owner = useStore(new Owner());\n  const nested = owner.nested;\n\n</script>\n\n<h1>{$nested.count}</h1>\n\nor\n\n<h1>{$owner.nested.count}</h1>\n\n<button on:click={() => $nested.increment()}>+</button>\n<button on:click={() => $nested.decrement()}>-</button>\n```\n\n### Trigger a manual update\n\nYou can trigger a manual update by calling the `triggerUpdate` method the autotracked object.\n\n```ts\nimport { triggerUpdate } from \"svelte-autotracking\";\nimport { MyClass } from \"./MyClass.js\";\n\nconst myClass = new MyClass();\n\n// trigger a manual update\ntriggerUpdate(myClass);\n\n```\n\n### Use the `@updateAfter` decorator\n\nYou can use the `@updateAfter` decorator to automatically update the store when a method is called event if no property is decorated with `@tracked`.\n\n```ts\n\nimport { Autotracking, tracked, updateAfter } from \"svelte-autotracking\";\n\nexport class MyClass extends Autotracking {\n  property = \"value\";\n\n  @updateAfter\n  method(newValue: string) {\n    this.property = newValue;\n  }\n}\n\n```\n\nIn this example, the `method` method will automatically update the store when it's called, even if the `property` property is not decorated with `@tracked`. So, in a Svelte component, when you call the `method` method, the component will re-render.\n\n### Silent change value without triggering an update\n\nYou can change the value of a property without triggering an update by using the `silentSet` function.\n\n```ts\nimport { silentSet } from \"svelte-autotracking\";\n\nconst myClass = new MyClass();\n\n// change the value without triggering an update\nsilentSet(myClass, \"property\", \"new value\");\n\n```\n\n## Explanation\n\nThe `@tracked` decorator is a property decorator that automatically tracks changes on the property of a class. When you change the value of the property, the component will re-render.\n\nAutotracking automatically adds a writable store and `@tracked` decorator add a call to the update function of the store when the property is changed. that's all.\n\n\n---\n\n## Author\n\nSee `AUTHORS.md` for more information.\n\n---\n\n## License\n\nThis project is licensed under the `MIT License`. See `LICENSE.md` for details.\n\n---\n\n_&copy;2024 Emmanuel FITOUSSI_\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3771, 205],
		[3778, 64],
		[3785, 15],
		[3792, 4],
		[3799, 24],
		[3806, 23],
		[3813, 20],
		[3820, 11],
		[3827, 3],
		[3834, 6],
		[3841, 2],
		[3848, 8],
		[3855, 15],
		[3862, 21],
		[3869, 29],
		[3876, 9],
		[3883, 27],
		[3890, 45],
		[3897, 35],
		[3904, 38],
		[3911, 87],
		[3918, 25],
		[3925, 19],
		[3932, 18],
		[3939, 12],
		[3946, 39],
		[3953, 10],
		[3960, 78],
		[3967, 18],
		[3974, 43],
		[3981, 27],
		[3988, 18],
		[3995, 19],
		[4002, 26],
		[4016, 9],
		[4023, 16],
		[4030, 6],
		[4037, 12],
		[4044, 18],
		[4051, 4],
		[4058, 3],
		[4065, 6],
		[4072, 11],
		[4079, 23],
		[4086, 4],
		[4093, 8],
		[4100, 25],
		[4107, 24],
		[4114, 47],
		[4121, 15],
		[4128, 7]
	]
}
