{
	"name": "svesta",
	"description": "Tiny Svelte state management library for Svelte/SvelteKit.",
	"repo_url": "https://github.com/steveesamson/svesta",
	"authors": ["steveesamson"],
	"homepage": "https://steveesamson.github.io/svesta",
	"downloads": 12,
	"updated": "2025-04-03T02:25:27.088Z",
	"tags": ["miscellaneous"],
	"github_stars": 3,
	"typescript": true,
	"version": "1.0.2",
	"svelte_range": "^5.0.0",
	"kit_range": "^2.16.0",
	"last_rune_check_version": "1.0.2",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svesta",
				"version": "1.0.2",
				"size": 62780
			},
			{
				"name": "socket.io-client",
				"version": "4.8.1",
				"size": 1414277
			},
			{
				"name": "@socket.io/component-emitter",
				"version": "3.1.2",
				"size": 21216
			},
			{
				"name": "debug",
				"version": "4.3.7",
				"size": 42060
			},
			{
				"name": "ms",
				"version": "2.1.3",
				"size": 6721
			},
			{
				"name": "engine.io-client",
				"version": "6.6.3",
				"size": 863361
			},
			{
				"name": "engine.io-parser",
				"version": "5.2.3",
				"size": 45773
			},
			{
				"name": "ws",
				"version": "8.17.1",
				"size": 141358
			},
			{
				"name": "xmlhttprequest-ssl",
				"version": "2.1.2",
				"size": 25414
			},
			{
				"name": "socket.io-parser",
				"version": "4.2.4",
				"size": 58497
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2],
			[1, 3],
			[3, 4],
			[1, 5],
			[5, 2],
			[5, 3],
			[5, 6],
			[5, 7],
			[5, 8],
			[1, 9],
			[9, 3],
			[9, 2]
		],
		"circular": []
	},
	"readme": "# svesta\n\n`svesta` - is a tiny `sve`lte `sta`te management library for `svelte/sveltekit`.\n\n[Docs](https://steveesamson.github.io/svesta)\n[Demo](https://steveesamson.github.io/svesta/demo)\n\n## Installation\n\n```bash\n# In your project directory\nnpm install svesta\n\nor\n\n# In your project directory\nyarn add svesta\n```\n\nThere are 6 major exported components in `svesta`, they are:\n\n- `Transport`: This allows the creation of requests, which starts as `fetch` but could migrate to `WebSocket`, especially, when `Transport` is `configure`d with a realTime as in `{ realTime: { transport:['websocket','polling'],... } }`. `realTime` accepts valid valid `socket.io-client` props.\n\n- `useStore`: The main component of `svesta`. It is responsible for creating reactive stores for providing a `REST`ful interface for any `REST` API while supporting real-time data exchanges.\n\n- `Resource`: `Resource` is a `svelte` component, which helps manage the network and resolution of promises to notify of `loading`, `errors` or `data` availability on success.\n\n- `useEvents`: This allows components exchange informations in a reliable manner, using events.\n\n- `network`: `network` allows the determination of network states. It exposed a `status` attribute that helps you do that. For instance, when `network.status.online` is `true => online` and `false => offline`.\n\n- `Offline`: A `svelte` component, which displays its `children` when `network.status.online` is `false`. It helps in monitoring network activities.\n\nLet us examine each component in detail.\n\n### 1. Transport\n\n`Transport` is useful in requesting any arbitrary HTTP(S) endpoint. `Transport` exposes 2 methods, `configure` and `instance`:\n\n- `configure`: It allows the customization of HTTP(S) requests. Such customization could be achieved as below, especially in your `+layout.[t|j]s`:\n\n```ts\nimport { type TransportConfig, Transport } from 'svesta';\n\nconst configOptions: TransportConfig = {\n\t// Log out details or not. Default is false.\n\tDEBUG: true,\n\t// Set the base URL. Default is ''.\n\tBASE_URL: 'https://some-base-url',\n\t// External fetch implementation could be passed.\n\t// Default is undefined.\n\t// Either window.fetch or fetch from\n\t// +page.[t|j]s' onload as shown in our example.\n\tfetch: window.fetch,\n\t// Allow or disallow migration to web socket.\n\t// Default is undefined.\n\trealTime: { transport: ['websocket'] },\n\t// Allows the override of the base fetch RequestInit.\n\t// Default is undefined.\n\tinit: RequestInit,\n\t// If you do not want the transport to be a top-level(default)\n\t// one, tag it with a context\n\t// This allows you have multiple transport instances.\n\tcontext: 'news' // This is used in accessing the instance later\n};\n\nTransport.configure(configOptions);\n```\n\n> Best practices favors doing all your Transport configuration in the `+layout.[t|j]s` in a manageable way. While `Transport.configure` could be done within your view's `$effect` or in your `+page.[j|t]s`, the recommended place to do the setupu is the `+layout.[j|t]s` like below:\n\n#### In +layout.ts\n\n```ts\nimport { Transport } from 'svesta';\n\n// This is configured on the default context\nTransport.configure({ BASE_URL: 'https://reqres.in/api' });\n\nexport const prerender = true;\n```\n\n- `instance`: By default, `Transport` creates a `default` instance, which gets returned when no argument is passed to `instance`. If you do not want the transport to be a top-level(default) one, tag it with a context. This allows you have multiple transport instances. The field is also used in accessing the instance later. `instance` accepts either a `TransportInstanceProps` type.\n\n```ts\nimport { Transport } from 'svesta';\n// Just for news, as configured above\nconst newsTransport = Transport.instance('news');\n```\n\n#### In +page.[t|j]s\n\nTransport `instance` plays well with `+page.[t|j]s` allowing us to specify what `fetch` to use.\n\n##### Default context\n\n```ts\n// from sveltekit\nimport { Transport } from 'svesta';\nimport type { PageLoad } from './$types.js';\nimport { resultTransformer } from '..';\n\nexport const load: PageLoad = async ({ fetch }) => {\n\t// This is happening on the server and we have a ref to a fetch\n\t// implementation, let's use it by passing it to the configure\n\t// method of Transport\n\n\t//Default transport\n\tconst transport = Transport.instance({ fetch });\n\n\tconst { error, ...rest } = await transport.get('/users');\n\n\treturn { ...resultTransformer(rest), error };\n};\n```\n\n##### News context\n\n```ts\n// from sveltekit\nimport { Transport } from 'svesta';\nimport type { PageLoad } from './$types.js';\nimport { resultTransformer } from '..';\n\nexport const load: PageLoad = async ({ fetch }) => {\n\t// This is happening on the server and we have a ref to a fetch\n\t// implementation, let's use it by passing it to the configure\n\t// method of Transport\n\n\t// Scoped only for news\n\t// Must have been configured too\n\tconst transport = Transport.instance({ context: 'news', fetch });\n\n\tconst { error, ...rest } = await transport.get('/users');\n\n\treturn { ...resultTransformer(rest), error };\n};\n```\n\n`Transport` competently handles `GET`, `POST`, `PUT`, `PATCH`, `OPTIONS` and `DELETE` HTTP methods via the exposed methods: `.get`, `.post`, `.put`, `.patch`, `.delete`, `.options` and `.upload`. An example could look like the following:\n\n```ts\n// Using the default instance\nconst { error, data } = await Trasport.instance().post('/users', {\n\tname: 'Name',\n\taddress: 'Some address'\n});\n```\n\n```ts\n// Using some context(news) instance\nconst newsTransport = Transport.instance('news');\nconst { error, data } = await newsTransport.post('/users', {\n\tname: 'Name',\n\taddress: 'Some address'\n});\n```\n\n> Note that you must have configured the `news` transport `context` before using it like so:\n\n```ts\nTransport.configure({context:'news',....});\n```\n\n`Transport` also exposes a `loading`, which actually, is a field indicative of whether an active request is happening.\n\n### 3. useStore\n\nIf the target of requests are `REST`ful APIs, then the appropriate component from `svesta` is the `useStore`. `useStore` defines 2 parameters:\n\n- `resourceName`: This is a `string` that represents the name or path of REST resource. This is required.\n- `storeOption`: This is a `StoreProps<T>`, explained in detail below. This is optional.\n\n> Note: `useStore` uses `Transport` under the hood, therefore, configurations set on `Transport.configure` also affect `useStore`.\n\n```ts\nimport { type StoreProps, useStore } from 'svesta';\n\n// Create a store props\nconst usersProps: StoreProps<User> = {\n\t// Parameters. Default {}\n\tparams: {},\n\t// Query order asc, desc or [asc|desc]|<field>\n\t// e.g \"desc|id\". Default is 'asc'\n\torderAndBy: 'asc',\n\t// namespace allows you proxy a resource with another name\n\t// E.g. 'profile' could still be used as 'users' namespace.\n\t// That is profile is not known to you system but 'users'\n\t// namespace defaults to ''.\n\tnamespace: '',\n\t// You can pre-populate a store by passing `initData`\n\t// of StoreState<T> type\n\t// It defaults to {}\n\tinitData: {},\n\t// includes helps control what fields are returned\n\t// It is pipe-separated string of resource names.\n\t// resource name is comma-saparate string of fields\n\t// E.g. 'users:name, age, gender | accounts: accountId, balance' where\n\t// users and accounts are resource names and their fields are listed after `:`\n\t// The above example is for when there are relationship\n\t// in multiple resources(join).\n\t// It defaults to ''.\n\tincludes: '',\n\t// resultTransformer is a StoreResultTransformer type, a function you can pass\n\t// to intercept and convert the data from your API to what\n\t// `useStore` understands, the StoreState type.\n\t// This is important when using the `.sync` method of store\n\t// to synchronize/fetch data from your APIs.\n\t// It accepts the raw data from your API and\n\t// returns the transformed data. See transformer.js above.\n\t// It defaults to undefined\n\tresultTransformer: undefined,\n\t// queryTransformer is a StoreQueryTransformer type, a function you can pass\n\t// to intercept and convert your query to what your API expects.\n\t// This is important when using the `.sync` method of store\n\t// to synchronize/fetch data from your APIs.\n\t// It accepts the raw query and\n\t// returns the transformed query for your API.\n\t// It defaults to undefined\n\tqueryTransformer: undefined,\n\t//Specifies transport context\n\ttransportContext: undefined\n};\n\n// Let's create a users store\nconst users = useStore(\n\t// resource name, not path please. Required\n\t'users',\n\t// store props. Optional\n\tusersProps\n);\n\n// Of all the store arguments, the `resource name/path` is mandatory\n// StoreProps is optional and could be omitted, for instance:\nconst people = useStore('users');\n```\n\n`useStore` maintains its internal structure as a `StoreState<T>`. In our example above, `T` is `User`. The structure as as shown below:\n\n```ts\ntype StoreState<T> = {\n\t// result target\n\tdata: T[];\n\t// total record count\n\trecordCount: number;\n\t// Number of pages for limit per page\n\tpages?: number;\n\t// What page number are we on?\n\tpage?: number;\n\t// Record per page\n\tlimit?: number;\n\t// Are we processing network?\n\tloading?: boolean;\n\t// Are there error based on request\n\terror?: string | null | undefined;\n\t// Params that produced result or error\n\tparams?: Params;\n\ttransportContext?: string;\n};\n```\n\nThe reason for a `resultTransformer`, is to convert API responses that do not conform to `StoreState<T>`. Look at the API in our example, that is, [regres.in](https://reqres.in/api). `regres.in` API returns its response as:\n\n```ts\ntype IngressType = {\n\tpage: number;\n\tper_page: number;\n\ttotal: number;\n\ttotal_pages: numbers;\n\tdata: unknow;\n};\n```\n\nHowever, `useStore` cannot store data like this, hence, the need to implement a result transformer to convert as below:\n\n```ts\nexport const resultTransformer = <User>(raw: IngressType): StoreResult<User> => {\n\t// raw is what comes from regres.in\n\tconst { page, per_page: limit, total: recordCount, total_pages: pages, data } = raw;\n\t// return what conforms to StoreState\n\treturn { page, limit, recordCount, pages, data };\n};\n```\n\n`useStore` exposes `result`, which is a state object comprising of:\n\n- `loading`: A `boolean` indicative of on-going network request or not.\n- `error`: A `string` that is non-empty whenever `store` request resolves with some error.\n- `data`: An object of type `T[]` representing the data from API when store request resolves with no `error`.\n\n```ts\nimport { useStore } from 'svesta';\n\nconst {\n\tsync,\n\tresult: { loading, data, error }\n} = useStore('users');\n$effect(() => {\n\tsync();\n});\n```\n\n```js\n<header>Users</header>\n{#if loading}\n\t<p>Loading users...</p>\n{/if}\n{#if !!error}\n\t<p>Error:{error}</p>\n{/if}\n{#if data }\n\t{#each users as user}\n\t\t<p>Name: {user.first_name} {user.last_name}</p>\n\t{/each}\n{/if}\n```\n\n`useStore` exposes the following methods:\n\n- `.sync`: This synchronizes the store by fetching the first page from the resource. This could also be used to pre-populate the store by passing data. This is typically a `GET` scoped to the resource only. When this executes, it populates the store and notifies all views depending on the store for appropriate view updates.\n  > This is asynchronous, therefore, if you need the population before something else, you must `await` its call.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// force sync\naccounts.sync();\n// or with initial data\n// initData is of type StoreState<Account>\naccounts.sync(initData)\n```\n\n- `.next`: This synchronizes the store by fetching the `next` page from the resource depending. This is typically a `GET` scoped to the resource only. When this executes, it populates the store and notifies all views depending on the store for appropriate view updates.\n\n  > This is asynchronous, therefore, if you need the population before something else, you must `await` its call. Important to note also is that previous store data are replaced by the new result.\n\n- `.prev`: This synchronizes the store by fetching the `previous` page from the resource depending. This is typically a `GET` scoped to the resource only. When this executes, it populates the store and notifies all views depending on the store for appropriate view updates.\n\n  > This is asynchronous, therefore, if you need the population before something else, you must `await` its call. Important to note also is that previous store data are replaced by the new result.\n\n- `.more`: This synchronizes the store by fetching `more` pages from the resource but rather than replace the store data like in the case of `.next` or `.prev`, it appends result to the existing store data, useful in endless loading. This is typically a `GET` scoped to the resource only. When this executes, it populates the store and notifies all views depending on the store for appropriate view updates.\n\n  > This is asynchronous, therefore, if you need the population before something else, you must `await` its call. Important to note also is that the new result is added/appended to the previous store data not replaced.\n\n```ts\nimport { useStore, Resource, type StoreResult } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\nconst onNext = () => accounts.next();\nconst onPrev = () => accounts.prev();\nconst onMore = () => accounts.more();\n```\n\nUsing `Resource`(we'll explain next), we can have the following:\n\n```js\n{#snippet resolve({ loading, data, error, page, pages }:StoreResult<Account>)}\n\t{#if data}\n\t\t<AccountList users=\"{data}\" />\n\t\t<div class=\"buttons\">\n\t\t\t<button onclick={handlePrev} disabled={ page === 1 }>Previous page</button>\n\t\t\t<button onclick={handleNext} disabled={ page=== pages }>Next page</button>\n\t\t\t<button onclick={onMore} disabled={page === pages}>\n\t\t\t\tMore(append to view)...\n\t\t\t</button>\n\t\t</div>\n\t{/if}\n\n\t{#if loading}\n\t\t<p class=\"spinner\">Fetching data...</p>\n\t{if}\n\t{#if error}\n\t\t<p class=\"danger\">Error: {error}</p>\n\t{if}\n{/snippet}\n\n<Resource store=\"{accounts}\" {resolve} />\n</Account>\n```\n\n- `.pageTo`: This synchronizes the store by fetching the `next/previous` page from the resource depending on `offset` passed. This work with offsets. This is typically a `GET` scoped to the resource only. When this executes, it populates the store and notifies all views depending on the store for appropriate view updates.\n\n  > This is asynchronous, therefore, if you need the population before something else, you must `await` its call. Important to note also is that previous store data are replaced by the new result.\n\n- `.save`: This does a scoped `POST` or `PUT` based on resource. For new data, i.e, data without `id`, it does `POST` otherwise, it does a `PUT`. When this executes, it updates the store and notifies all views depending on the store for appropriate view updates. It returns a `Promise<TransportResponse<T>>`.\n  > This is asynchronous, therefore, if you need the saving before something else, you must `await` its call.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// Fire and forget\naccounts.save({accountName:'Account Name', accountNo:1234});\n\n// Fire and inspect\nconst { error, message, data, status } = await accounts.save({accountName:'Account Name', accountNo:1234});\n// Do something with fields\n\n```\n\n- `.destroy`: This does a scoped `DELETE` based on resource. It expects a `WithID` type that must contain the `id`. When this executes, it updates the store and notifies all views depending on the store for appropriate view updates. It returns a `Promise<TransportResponse<T>>`.\n  > This is asynchronous, therefore, if you need the saving before something else, you must `await` its call.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// Fire and forget\naccounts.destroy({id:12345678});\n\n// Fire and inspect\nconst {\n\terror,\n\tmessage,\n\tdata,\n\tstatus\n\t} = await accounts.destroy({id:12345678});\n// Do something with fields\n\n```\n\n- `.search`: This does a scoped `GET` based on resource but appends a `&search=<searchTerm>` to the endpoint. It expects a `searchTerm`, a string. When this executes, it updates the store and notifies all views depending on the store for appropriate view updates. It returns a `Promise<void>`.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// Fire and forget\n// Seach can be added and customized via `queryTransformer`\naccounts.search('google');\n```\n\n- `.get`: This does a scoped `GET` based on resource but appends the passed `path` to resource `url`. When this executes, it does not updates the store. It returns a `Promise<TransportResponse<T>>`.\n\n```ts\n\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n$effect(async () => {\n    // The following will make a GET request to `/accounts/checking`\n    // path using the passed params\n    const { data, error} = await accounts.get('/checking',{...});\n})\n```\n\n- `.post`: This does a scoped `POST` based on resource but appends the passed `path` to resource `url`. When this executes, it does not updates the store. It returns a `Promise<TransportResponse<T>>`.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n$effect(async () => {\n    // The following will make a request to POST `/accounts/checking`\n    // path using the passed params\n    const { data, error} = await accounts.post('/checking',{...});\n})\n```\n\n- `.find`: This does searches the store to locate the first item that match the search `value`, using the passed `key` or `undefined` when there are no match. `HTTP` request could be involved, especially if store was not `sync`ed yet. It returns a `Promise<T | undefined>`.\n  > This is asynchronous, therefore, you must `await` its call.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// Seach for `12345` on the `accountId` field\nconst targetAccount = await accounts.find(key:'accountId', value:12345);\n// Check and use targetAccount\n```\n\n- `.filter`: This does filtering based on passed `query` param of type `Partial<T>`. `HTTP` request is involved. It returns a `void`. When this executes, it updates the store and notifies all views depending on the store for appropriate view updates.\n\n```ts\nimport { useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// Filters for  `accountName` that equals 'Steve Samson'\n accounts.filter({accountName:'Steve Samson'});\n```\n\n- `.on`: This does allows the registering of event listeners on stores so we can react to those events should they fire. Possible events are `refresh`, `create`, `destroy`, `update`.\n\n```ts\nimport { type EventHandler, useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\nconst onAccountUpdate:EventHandler = (account:Account) =>{\n    console.log(`${account} was updated!`);\n};\n\n// onAccountUpdate will be called when update\n// happens on any account in the store\naccounts.on('update',onAccountUpdate);\n```\n\nThe following methods of store do not make network requests when used but they propagate changes to the view. They are added for the purpose of prototyping without persistence. These methods are:\n\n- `.debug`: This logs store info to the console. Useful during dev.\n- `.add`: Add items to store\n- `.remove`: Removes specific item from store\n- `.patch`: Updates specific item in store\n\n```ts\n\nimport { type EventHandler, useStore } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('accounts',...);\n// id is required\nconst account = {accountName:'Account Name', accountNo:2345566, id:new Date().getTime()};\naccounts.add(account);\naccounts.patch({...account, accountName:'Updated Account Name'});\naccounts.remove(account);\n\n```\n\n### 3. Resource\n\nAs mentioned earlier, `Resource`, is a `svelte` component, which helps manage the network requests while using `store` to manage REST resources. `Resource` also handles resolution of promises and notify of `result` during an on-going network request, `errors` on events of HTTP `errors` or `data` availability on success.\n\n`Resource` accepts 2 props:\n\n- `store`: A type of `Store<T>`, which by all means is an instance of `useStore`. This prop is required.\n- `resolve`: A `svelte runes snippet` of type `Snippet<[StoreResult<T>]>` that get called when `Resource` resolves the `store` passed to it. It is responsible for rendering the data from `store` when store resolves. This prop is required.\n\nSee example in demo app.\n\n`Resource` is just a `svelte` component used as below:\n\n```ts\n// svelte file\n<script>\nimport { useStore, type StoreResult } from 'svesta';\nimport type Account from '...';\n\nconst accounts = useStore<Account>('some');\n\n</script>\n\n```\n\n```js\n{#snippet resolve({ data, loading, error, page, pages }:StoreResult<Account\n\t>)}\n\n\t<AccountList users=\"{data}\" />\n\n\t{#if loading}\n\n\t<p>Loading data...</p>\n\n\t{/if} {#if data}\n\t<div class=\"buttons\">\n\t\t<button onclick={accounts.prev} disabled={page === 1}>Previous page</button>\n\t\t<button onclick={accounts.next } disabled={page === pages}>Next page</button>\n\t\t<button onclick={accounts.more } disabled={ page === pages }>\n\t\t\tmore(append to view)...\n\t\t</button>\n\t</div>\n\t{/if} {#if error}\n\n\t<h4>Oh, error?</h4>\n\t<p>{error}</p>\n\n\t{/if} {/snippet}\n\n\t<Resource store=\"{accounts}\" resolve=\"{resolve}\" />\n</Account>\n```\n\n### 4. useEvents\n\n`useEvents`: This allows components exchange informations in a reliable manner, using events rather than passing props. For instance, see the following:\n\n```ts\n import {type UseEvent, useEvents } from \"svesta\";\n // Here loading is the scope of the created event\n const loadEvent: UseEvent<boolean> = useEvents<boolean>('loading', false);\n ...\n ...\n function start(){\n\tloadEvent.value = true;\n }\n function done(){\n\tloadEvent.value = false;\n }\n\n```\n\nIn another component, we can track and use the created `loadEvent` like so:\n\n```ts\n<script>\n import {type UseEvent, useEvents } from \"svesta\";\n // Here loading is the scope of the created event\n const loader: UseEvent<boolean> = useEvents<boolean>('loading', false);\n</script>\n```\n\n```html\n{#if loader.value}\n<p>Loading...</p>\n{/if}\n```\n\n### 5. network\n\n`network` allows the determination of network states. It exposed a `status` attribute that helps you do that. For instance, when `network.status.online` is `true => online` and `false => offline`. This can be used both in view and non-view components. For instance, the `Offline` component was build by using `network`.\n\n### 6. Offline\n\nThis is a `svelte` component, which displays its `children` when `network.status.online` is `false`. It helps in monitoring network activities in view components. The usage as as shown below:\n\n```ts\nimport { Offline } from 'svesta';\n```\n\n```html\n<Offline>\n\t<p>Content to show when offline.</p>\n</Offline>\n```\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3659, 63],
		[3666, 96],
		[3673, 17],
		[3680, 1],
		[3687, 6],
		[3694, 4],
		[3701, 3],
		[3708, 1],
		[3715, 4],
		[3722, 2],
		[3729, 2],
		[3736, 3],
		[3743, 1],
		[3750, 2],
		[3757, 1],
		[3764, 1],
		[3771, 1],
		[3778, 7],
		[3785, 1],
		[3792, 3],
		[3806, 1],
		[3813, 1],
		[3834, 15],
		[3841, 66],
		[3848, 9],
		[3855, 5],
		[3862, 5],
		[3869, 77],
		[3876, 4],
		[3883, 1],
		[3890, 6],
		[3897, 5],
		[3904, 5],
		[3911, 3],
		[3918, 1],
		[3925, 3],
		[3932, 2],
		[3939, 3],
		[3946, 1],
		[3953, 2],
		[3967, 2],
		[3974, 3],
		[3981, 1],
		[3988, 4],
		[3995, 2],
		[4002, 5],
		[4009, 3],
		[4016, 11],
		[4023, 4],
		[4030, 5],
		[4037, 18],
		[4044, 7],
		[4051, 2],
		[4058, 2],
		[4065, 1],
		[4072, 1],
		[4086, 1],
		[4093, 1],
		[4100, 5],
		[4107, 69],
		[4114, 12],
		[4121, 9],
		[4128, 8],
		[4135, 7]
	]
}
