{
	"name": "@dexq/svelte-scrollspy",
	"description": "Track scroll position of Svelte elements using Intersection Observer.",
	"repo_url": "https://github.com/dexterklui/svelte-scrollspy",
	"authors": ["dexlui"],
	"homepage": "https://github.com/dexterklui/svelte-scrollspy#readme",
	"downloads": 6,
	"updated": "2023-11-26T14:24:04.525Z",
	"tags": ["miscellaneous"],
	"github_stars": 4,
	"typescript": true,
	"version": "0.0.1",
	"svelte_range": "^4.0.0",
	"kit_range": "^1.27.4",
	"last_rune_check_version": "0.0.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@dexq/svelte-scrollspy",
				"version": "0.0.1",
				"size": 18372
			}
		],
		"dependencies": [],
		"circular": []
	},
	"legacy_svelte": false,
	"readme": "# Svelte ScrollSpy\n\nSvelte ScrollSpy is a [Svelte store](https://svelte.dev/docs/svelte-store) that\ntracks the intersecting state of a set of elements. The store provides a\n[Svelte action](https://svelte.dev/docs/svelte-action) that allows you to easily\nregister any element for tracking.\n\n# Installation\n\n## NPM\n\n```\nnpm i -D svelte-scrollspy\n```\n\n## Yarn\n\n```\nyarn add -D svelte-scrollspy\n```\n\n## bun\n\n```\nbun i -d svelte-scrollspy\n```\n\n# Why Svelte ScrollSpy?\n\nAlthough there are many intersection observer libraries out there, this library\nleverages the power of Svelte actions to provide a simple and intuitive API.\nHere are some of the benefits of using this library in a Svelte project.\n\n- Have a cleaner DOM without needing to add wrapper elements.\n- Easily register any elements, even nested elements, for tracking.\n- No need to worry about cleaning up when elements being tracked are removed\n  from the DOM. Callbacks in Svelte action automatically do that.\n\n# API\n\nThe object stored in the ScrollSpy store has the following properties:\n\n| Property           | Description                                                                                                                                   |\n| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| `amount`           | The number of targets being spied on.                                                                                                         |\n| `targets`          | The ordered set of all targets being spied on, in the order of them being added as a target.                                                  |\n| `activeTargets`    | The ordered set of all intersecting targets, in the order of entering intersection.                                                           |\n| `activeTarget`     | The target that became active most recently and is still active. I.e. the last item in `activeTargets`.                                       |\n| `lastActiveTarget` | The target that became active most recently. It may or may not be active now. If this target is no longer being spied on, this value is null. |\n| `activeId`         | The id of `activeTarget`.                                                                                                                     |\n| `lastActiveId`     | The id of `lastActiveTarget`.                                                                                                                 |\n| `isActive`         | A function that checks if an element is active. Returns `null` if the given element is not a target being spied on.                           |\n\nThe ScrollSpy store also has the following methods besides the `subscribe`\nmethod of a Svelte store.\n\n| Method     | Description                                                                                                                                                                                                                 |\n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `spy`      | A svelte action to add an element to the target list and start spying on it.                                                                                                                                                |\n| `unspy`    | Stop spying on a target and remove it from the target list. Accepts either the element itself or the id as the argument. This method is automatically called on all registered targets after they are removed from the DOM. |\n| `unspyAll` | Stop spying on all existing targets and remove them from the target list.                                                                                                                                                   |\n\n# Usage\n\n## Basic\n\nTo use ScrollSpy to track the current section in view on the page. First create\na scroll spy store with the imported `createScrollSpy` function. You can pass in\nan IntersectionObserverInit object to configure the IntersectionObserver used\nfor tracking.\n\nIn the example, we set the `rootMargin` to `-50% 0px` so that a section starts\nintersecting when it touches the vertical center of the viewport.\n\n```javascript\nimport createScrollSpy from \"svelte-scrollspy\";\nexport const scrollSpy = createScrollSpy({ rootMargin: \"-50% 0px\" });\n```\n\nThen in any component file you can import the created store and use its `spy`\nmethod as a Svelte action to start spying on that element.\n\n```svelte\n<script>\n  import scrollSpy from \"$lib/stores/scroll-spy\";\n</script>\n\n<section id=\"my-section\" use:scrollSpy.spy><!-- ... --></section>\n<!-- Other sections... -->\n```\n\nElement id is not required for spying. We gave an id to the element here only\nfor scrolling with URL hash. Now, it is easy to make a navbar that highlights\nthe current section.\n\n```svelte\n<script>\n  import scrollSpy from \"$lib/stores/scroll-spy\";\n  import kebabCaseToCapWords from \"$lib/utils.js\";\n</script>\n\n<nav>\n  <ul>\n    {#each $scrollSpy.targets as section (section)}\n      <li class={$scrollSpy.lastActiveTarget === section ? \"active\" : \"\"}>\n        <a href={\"#\" + section.id}>{kebabCaseToCapWords(section.id)}</a>\n      </li>\n    {/each}\n  </ul>\n</nav>\n\n<style>\n  /* Styling... */\n</style>\n```\n\n## Restricting What Can Be Spied On\n\nYou can augment Scroll Spy with additional properties and methods. For example,\nwe can enforce that all elements being spied on must have an ID, and we can\nassign an arbitrary label to each element when they are registered.\n\nTo do this, we create our custom Svelte store by extending the functionality of\nScroll Spy.\n\n```javascript\nimport createScrollSpy from 'svelte-scrollspy';\nimport type { ActionReturn } from 'svelte/action';\n\nexport const sectionSpy = (() => {\n  // use spy store's functionality\n  const spy = createScrollSpy({ rootMargin: '-50% 0px' });\n\n  return {\n    ...spy,\n\n    // Overwrite spy() to add restriction on targets and apply custom attribute\n\n    /**\n     * A svelte action to register an element as a section to spy on. The\n     * element must have an id.\n     *\n     * @param [label] - an arbitrary label for the section. This action assigns\n     *   the label value to the element's `data-section-label` attribute. If no\n     *   label is given, the element's id is transformed into a capitalized\n     *   string and used as the label.\n     */\n    spy(\n      target: string | Element,\n      label?: string,\n    ): ActionReturn<string, { id: string }> {\n      const elem =\n        target instanceof Element ? target : document.getElementById(target);\n\n      if (!elem || !elem.id) return {};\n\n      label ??= elem.id // kebab-case to Capitalized Words\n        .replace(/-./g, (m) => \" \" + m[1].toUpperCase())\n        .replace(/^(.)/, (m) => m.toUpperCase());\n\n      const { destroy } = spy.spy(elem);\n      if (destroy) elem.setAttribute(\"data-section-label\", label);\n      return { destroy };\n    },\n  };\n})();\n```\n\nWe can then use our custom store to assign labels with Svelte action syntax.\n\n```svelte\n<section id=\"my-section\" use:sectionSpy.spy={\"My Label\"}><!-- ... --></section>\n<!-- Other sections... -->\n<footer>You're at the section: {$sectionSpy.activeLabel}</footer>\n```\n\n## Adding Custom Properties to the Store\n\nYou can even add custom properties to the store.\n\n```typescript\nexport const sectionSpy = (() => {\n  const spy = createSpy({ rootMargin: \"-50% 0px\" });\n\n  // extend spy store's properties\n  interface SectionSpy extends Spy {\n    /** The label of the active target (attribute: \"data-section-label\") */\n    activeLabel: string | null;\n\n    /**\n     * The label of the last active section (attribute: \"data-section-label\")\n     */\n    lastActiveLabel: string | null;\n  }\n\n  function getSectionSpy(): SectionSpy {\n    return {\n      ...get(spy),\n      get activeLabel() {\n        return this.activeTarget?.getAttribute(\"data-section-label\") ?? null;\n      },\n      get lastActiveLabel() {\n        return (\n          this.lastActiveTarget?.getAttribute(\"data-section-label\") ?? null\n        );\n      },\n    };\n  }\n\n  // Create our own custom store\n  const { subscribe, set } = writable<SectionSpy>(getSectionSpy());\n  // Update our custom store whenever the spy store updates\n  spy.subscribe(() => set(getSectionSpy()));\n\n  return {\n    ...spy,\n    subscribe,\n\n    // Implement our own spy() method to add restriction on spied targets and\n    // add custom attribute to the targets\n    spy(\n      target: string | Element,\n      label?: string,\n    ): ActionReturn<string, { id: string }> {\n      const elem =\n        target instanceof Element ? target : document.getElementById(target);\n\n      if (!elem || !elem.id) return {};\n\n      label ??= elem.id // kebab-case to Capitalized Words\n        .replace(/-./g, (m) => \" \" + m[1].toUpperCase())\n        .replace(/^(.)/, (m) => m.toUpperCase());\n\n      const { destroy } = spy.spy(elem);\n      if (destroy) elem.setAttribute(\"data-section-label\", label);\n      return { destroy };\n    },\n  };\n})();\n```\n\n# License\n\n[MIT](./LICENSE)\n",
	"downloads_history": [
		[3610, 57],
		[3617, 21],
		[3624, 1],
		[3631, 1],
		[3638, 2],
		[3645, 2],
		[3652, 2],
		[3659, 2],
		[3666, 6],
		[3673, 1],
		[3680, 1],
		[3687, 1],
		[3715, 2],
		[3722, 2],
		[3729, 2],
		[3736, 2],
		[3764, 3],
		[3771, 1],
		[3778, 2],
		[3785, 2],
		[3799, 1],
		[3806, 2],
		[3813, 2],
		[3827, 1],
		[3834, 6],
		[3841, 1],
		[3862, 3],
		[3876, 1],
		[3883, 2],
		[3890, 1],
		[3897, 1],
		[3904, 1],
		[3911, 3],
		[3932, 1],
		[3939, 2],
		[3960, 1],
		[3981, 1],
		[3988, 3],
		[4009, 2],
		[4016, 2],
		[4023, 1],
		[4037, 2],
		[4044, 7],
		[4051, 2],
		[4058, 1],
		[4072, 1],
		[4079, 4],
		[4086, 2],
		[4093, 2],
		[4100, 3],
		[4107, 3],
		[4114, 6],
		[4121, 11],
		[4128, 1]
	]
}
