{
	"name": "svelte-loadable",
	"description": "Dynamically load Svelte components with loading states.",
	"repo_url": "https://github.com/kaisermann/svelte-loadable",
	"authors": ["kaisermann"],
	"homepage": "https://github.com/kaisermann/svelte-loadable#readme",
	"downloads": 343,
	"updated": "2022-03-05T08:21:50.292Z",
	"tags": ["miscellaneous"],
	"github_stars": 325,
	"typescript": false,
	"version": "2.0.1",
	"svelte_range": "^3.20.1",
	"last_rune_check_version": "2.0.1",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-loadable",
				"version": "2.0.1",
				"size": 12708
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# svelte-loadable\n\n> Dynamically load a svelte component. Based on [react-loadable](https://github.com/jamiebuilds/react-loadable).\n\n## Usage\n\nJust pass a `loader` method which return a async module import:\n\n```html\n<script>\n  import Loadable from 'svelte-loadable'\n</script>\n\n<Loadable loader={() => import('./AsyncComponent.svelte')} />\n```\n\nUse `unloader` to prevent `Loadable` from caching the component which will cause it to call `loader` each time the component is used after being unmounted.\n\n```html\n<script>\n  import Loadable from 'svelte-loadable'\n\n  // unloader callback\n  function unloader() {\n    // some code here\n  }\n</script>\n\n<!-- unloader as boolean -->\n<Loadable ... unloader />\n<Loadable ... unloader=\"{true}\" />\n<Loadable ... unloader=\"{someBooleanValue}\" />\n\n<!-- unloader as predefined function in script tag above -->\n<Loadable ... {unloader} />\n<!-- unloader as an inline function -->\n<Loadable ... unloader={() => { /* some code here */ }} />\n\n<!-- example using SystemJS Module Loader which has the ability to unload (delete) a previously loaded module -->\n<Loadable loader={() => System.import('./AsyncComponent.svelte')} unloader={()\n=> System.delete(System.resolve('./AsyncComponent.svelte'))} />\n```\n\n### Props\n\n- `loader`: a function which `import()` your component to the `<Loadable>` component.\n- `delay`: minimum delay in `msecs` for showing the `loading slot`. Default: 200\n- `timeout`: time in `msecs` for showing the `timeout slot`.\n- `unloader`: `true` to prevent the component from being cached or a `function` which will also prevent the component from being cached after being unmounted and will be called immediately after it is removed from cache.\n\nAny other prop will be passed directly onto the rendered component if the `default` slot is defined:\n\n```html\n<Loadable loader=\"{...}\" foo=\"cookie\" bar=\"potato\" />\n<!-- `foo` and `bar` will be available to the rendered component -->\n```\n\nIf the default slot is used, it's up to the developer to render the component:\n\n```html\n<Loadable loader=\"{...}\" let:component>\n  <svelte:component this=\"{component}\" foo=\"cookie\" bar=\"potato\" />\n</Loadable>\n```\n\n### Events\n\n- `on:load`: a function which is executed right after the `<Loadable>` component is loaded.\n\n```html\n<Loadable on:load={() => console.log('The component has been loaded')}\nloader={...} />\n```\n\nOtherwise, if your callback contains more code, you can wrap it into a function, and call it without parentheses\n\n```html\n<Loadable on:load=\"{callback}\" loader=\"{...}\" />\n```\n\n### Slots\n\n- `loading`: customizes the loading state;\n- `error`: customizes the error state. You can `let:error` to have access to the error variable, and `let:retry` to have access to the retry method.\n- `timeout`: customizes the timeout state. Will only appear if `timeout` prop is defined;\n- `default`: customizes the imported component render (add props, etc). You can `let:component` to access the imported component constructor.\n\n#### Basic Example\n\n```html\n<script>\n  import Loadable from 'svelte-loadable'\n</script>\n\n<Loadable loader={() => import('./AsyncComponent.svelte')}>\n  <div slot=\"loading\">Loading...</div>\n  <div slot=\"error\" let:error let:retry>\n    {error}\n    <br>\n    <button on:click={retry}>Try again</button>\n  </div>\n</Loadable>\n```\n\n### Registering a loader\n\n#### Or, preventing \"flash of loading\"\n\nBy default, Svelte Loadable will dynamically load the specified loader (import statement) every time the component is initialized and reinitialized. This creates a delay between initial rendering, and rending the loaded component, even for components which have previously been loaded. To work around that, Svelte Loadable provides an optional cache, which can be used to predefine a loader, and keep track of whether it has already been loaded. When a loader is registered, it will render immediately on the next initialization.\n\nTo set that up, you'll need to `register` the loader at definition time in a module script block, instead of passing the loader directly to the loadable component instance, then pass the resulting loader on to the loadable component. It looks like this (with `svelte-routing`).\n\n_NOTE:_ A resolve function is necessary for most SSR solutions. The function must return an absolute path, which will be used for indexing, and for loading before hydration. The specific way to generate that may vary by platform. A babel plugin for Svelte Loadable to help generate that automatically is forthcoming.\n\n**App.svelte:**\n\n```html\n<script context=\"module\">\n  import { register } from 'svelte-loadable'\n\n  // Loaders must be registered outside of the render tree.\n  const PageLoader = register({\n    loader: () => import('./pages/Page.svelte'),\n    resolve: () => require.resolve('./pages/Page.svelte'),\n  })\n  const HomeLoader = register({\n    loader: () => import('./home/Home.svelte'),\n    resolve: () => require.resolve('./home/Home.svelte'),\n  })\n</script>\n\n<script>\n  import { Router, Link, Route } from 'svelte-routing'\n  import Loadable from 'svelte-loadable'\n\n  export let url = ''\n</script>\n\n<Router url=\"{url}\">\n  <Route path=\"/pages/:slug\" let:params>\n    <Loadable loader=\"{PageLoader}\" slug=\"{params.slug}\">\n      <div slot=\"loading\">Loading...</div>\n    </Loadable>\n  </Route>\n  <Route path=\"/\">\n    <Loadable loader=\"{HomeLoader}\" />\n  </Route>\n</Router>\n```\n\nAnother advantage is that if the same module is registered in two different places in the tree, the previous loader will be used instead of creating a second loader.\n\nThis comes with additional benefits and opportunities as well. There is now a `preloadAll` method, which can be used to proactively (and recursively) preload all the modules after the initial render of the application, if desired. That method can also be used server side to preload all the necessary components to pull off server side rendering (SSR).\n\n### Additional Methods\n\n#### preloadAll()\n\nPreloads all registered Loaders. Works server side, and client side.\n\n```js\nimport { preloadAll } from 'svelte-loadable'\n\n// Somewhere in your code, after the initial tree is rendered:\npreloadAll().then(() => {...});\n```\n\n### The 'svelte-loadable-capture' Context for SSR\n\nTo facilitate the creation of SSR solutions, Svelte Loadable uses a context which can be set up by an SSR solution in a `LoadableProvider` using the string identifier 'svelte-loadable-capture'. Svelte Loadable expects the context to provide a method, to which it will pass the registered loader function. For an example implementation, check out [`npdev:svelte-loadable`](https://github.com/CaptainN/npdev-svelte-loadable) a Meteor SSR solution.\n\n---\n\nFor more examples, please check the [`example/src/App.svelte`](https://github.com/kaisermann/svelte-loadable/blob/master/example/src/App.svelte) file.\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 254],
		[3596, 655],
		[3603, 519],
		[3610, 486],
		[3617, 514],
		[3624, 388],
		[3631, 327],
		[3638, 393],
		[3645, 159],
		[3652, 414],
		[3659, 385],
		[3666, 319],
		[3673, 368],
		[3680, 484],
		[3687, 315],
		[3694, 393],
		[3701, 353],
		[3708, 650],
		[3715, 412],
		[3722, 316],
		[3729, 336],
		[3736, 163],
		[3743, 845],
		[3750, 1080],
		[3757, 10108],
		[3764, 4508],
		[3771, 292],
		[3778, 169],
		[3785, 101],
		[3792, 215],
		[3799, 144],
		[3806, 283],
		[3813, 173],
		[3820, 127],
		[3827, 223],
		[3834, 313],
		[3841, 189],
		[3848, 383],
		[3855, 264],
		[3862, 596],
		[3869, 348],
		[3876, 272],
		[3883, 368],
		[3890, 288],
		[3897, 254],
		[3904, 447],
		[3911, 602],
		[3918, 514],
		[3925, 459],
		[3932, 511],
		[3939, 555],
		[3946, 583],
		[3953, 395],
		[3960, 386],
		[3967, 479],
		[3974, 323],
		[3981, 236],
		[3988, 276],
		[3995, 367],
		[4002, 577],
		[4009, 218],
		[4016, 261],
		[4023, 652],
		[4030, 648],
		[4037, 436],
		[4044, 560],
		[4051, 461],
		[4058, 512],
		[4065, 344],
		[4072, 511],
		[4079, 532],
		[4086, 531],
		[4093, 468],
		[4100, 363],
		[4107, 293],
		[4114, 343],
		[4121, 544],
		[4128, 687]
	],
	"esm": false,
	"cjs": true
}
