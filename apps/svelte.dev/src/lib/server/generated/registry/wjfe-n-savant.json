{
	"name": "@wjfe/n-savant",
	"description": "Client-side router for Svelte v5 SPAs, inventing multi hash routing.",
	"repo_url": "",
	"authors": ["webjose"],
	"downloads": 11,
	"updated": "2025-03-07T02:31:45.548Z",
	"tags": ["router"],
	"typescript": true,
	"version": "0.3.0",
	"svelte_range": "^5.0.0",
	"kit_range": "^2.0.0",
	"last_rune_check_version": "0.3.0",
	"github_stars": 0,
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@wjfe/n-savant",
				"version": "0.3.0",
				"size": 129011
			}
		],
		"dependencies": [],
		"circular": []
	},
	"readme": "# @wjfe/n-savant\r\n\r\n> The client-side router for Svelte v5 SPA's that invented multi hash routing.\r\n\r\n## Features\r\n\r\n> [!NOTE]\r\n> #### Small and Unique!\r\n> \r\n> + Less than **1.000** lines of code, including TypeScript typing.\r\n> + Always-on path and hash routing.  Simultaneous and independent routing modes.\r\n> + The router that invented multi hash routing.\r\n\r\n+ **Reactivity-based**:  All data is reactive, reducing the need for events and imperative programming.\r\n+ **Always-on path and hash routing**:  Add routers that use the URL's path name or the URL's hash value in the same \r\napplication.  Both routing modes are possible simultaneously.\r\n+ **Multi-hash routing**:  This is the first router in the world to do this:  You can create named paths in the hash \r\nvalue of the URL and create router hierarchies that use a specific named path.\r\n\r\n### `<Router>` Component\r\n\r\n+ **Multi-matching routes**:  All routes are evaluated, which is useful to mount micro-frontends.\r\n+ **Base paths**:  Specify base paths that are inherited by routes and nesting routers.\r\n+ **Nesting routers**:  Add child routers inside routers for fine-grained control.\r\n+ **Liberty**:  Place anything anywhere inside.  No child restrictions.\r\n\r\n### `<Route>` Component\r\n\r\n+ **Exact path matching**:  Exact match by default; specify the rest parameter to relax the condition.\r\n+ **Path as string or regular expression**:  Define paths however's best for you.\r\n+ **Route parameters**:  Define route parameters inside string paths or regular expression paths.\r\n+ **Rest parameter**:  Collect \"the rest\" of the path.\r\n+ **Optional parameters**:  Parameters may be specified as optional.\r\n+ **Additional matching logic**:  Add a predicate function to further restrict a route's matching ability.\r\n+ **Path is optional**:  Forgo path specification entirely and handle route matching entirely with code.\r\n+ **Superb Intellisense**:  The route parameters are strongly typed when defining them inside a string path.\r\n+ **Disconnected UI pieces**:  Repeat route keys in `Route` components to show disconnected pieces of UI for a given \r\nroute's key.\r\n\r\n### `<Fallback>` Component\r\n\r\n+ **Non-matching content**:  Show users something when there are no matching routes.\r\n+ **Disconnected content**:  Add as many `Fallback` components as needed in various places.\r\n\r\n### `<Link>` Component\r\n\r\n+ **Drop-in replacement**:  Exchange `<a>` tags with `<Link>` tags and you're done.\r\n+ **Specify state**:  Set history state upon hyperlink click.\r\n+ **Active state based on route key**:  Automatically set active state and `aria-current` by specifying the route's key.\r\n+ **Replace or push**:  Select the method for pushing state.\r\n\r\n### `<LinkContext>` Component\r\n\r\n+ **Centralize `<Link>` configuration**:  Configures a special context that all `<Link>` components follow.\r\n\r\n### `<RouterTrace>` Component\r\n\r\n+ **Tracing Information**:  Drop it inside a router to display its route status data, including the internal regular \r\nexpressions that are generated from string path patterns.\r\n+ **Specify a specific router**:  Ability to give it a specific router engine object, allowing tracing of router engine \r\nobjects created in code.\r\n+ **Track child routers**:  See and traverse the router hierarchy.\r\n\r\n### `location` Global Object\r\n\r\n+ **Reactive URL**:  URL object that's always in sync with the browser's URL.\r\n+ **Reactive state**:  Reactive state property that's always in sync with the history state.\r\n+ **Reactive hash paths**:  Reactive dictionary object for all hash paths.\r\n+ **Programatic navigation**:  Use the the `navigate()` method to trigger navigation programatically.\r\n\r\n#### In Full Mode...\r\n\r\n+ **Cancellable `beforeNavigate` event**:  Get notified of navigation events, and cancel when appropriate.\r\n+ **`navigationCancelled` event**:  Get notified whenever navigation is cancelled.\r\n+ **History API interception**:  Gain control over the history object to avoid external code/routers from \r\nde-synchronizing state.\r\n+ **Micro-frontends**:  Full mode's features are great for micro-frontend scenarios where other routers (from \r\npotentially other technologies) might interfere with the router's functionality.\r\n\r\n## Quickstart\r\n\r\n1. Install the package.\r\n2. Initialize the library.\r\n3. Define the routes inside routers.\r\n4. Modify/Add your navigation links.\r\n\r\n### Install the package\r\n\r\n```bash\r\nnpm i @wjfe/n-savant\r\n```\r\n\r\n### Initialize the Library\r\n\r\n```typescript\r\n// In your main.ts, or somewhere BEFORE any routers are created:\r\nimport { init } from \"@wjfe/n-savant\";\r\n\r\n// Default:  Lite mode, implicit path routing, no router hierarchy tracing, single hash mode.\r\ninit();\r\n\r\n// If all you care about is (traditional) hash routing, the recommendation is to change the implicit mode:\r\ninit({ implicitMode: 'hash' });\r\n```\r\n\r\n### Define the Routes\r\n\r\n`<Route>`s are added inside `<Router>`s.  `<Router>`s can be nested inside other `<Router>`s.  `<Route>`s can render \r\n`<Router>`s or other `<Route>`s, etc.  You get the idea:  You do as you wish.\r\n\r\n```svelte\r\n<script lang=\"ts\">\r\n    import { Router, Route } from \"@wjfe/n-savant\";\r\n    import NavBar from \"./lib/NavBar.svelte\";\r\n    import UserView from \"./lib/UserView.svelte\";\r\n</script>\r\n\r\n<Route>\r\n    <NavBar />\r\n    <div class=\"container\">\r\n        <Router>\r\n            <!-- content outside routes is always rendered -->\r\n            <h1>Routing Demo</h1>\r\n            <Route key=\"users\" path=\"/users\">\r\n                <!-- content here -->\r\n            </Route>\r\n            <Route key=\"user\" path=\"/users/:userId\">\r\n                <!-- access parameters via the snippet parameter -->\r\n                {#snippet children(params)}\r\n                    <UserView id={params.userId} /> <!-- Intellisense will work here!! -->\r\n                {/snippet}\r\n            </Route>\r\n            ...\r\n        </Router>\r\n    </div>\r\n</Route>\r\n```\r\n\r\n### Navigation Links\r\n\r\nThe previous step added the `<NavBar />` component inside the router.  This is the best practice for full `<Link>` \r\nfunctionality.  Still, this is not mandatory.\r\n\r\n```svelte\r\n<!-- NavBar.svelte -->\r\n<script lang=\"ts\">\r\n    import { Link } from \"@wjfe/n-savant\";\r\n</script>\r\n\r\n<nav>\r\n    <div class=\"nav-links\">\r\n        <ul>\r\n            <li class=\"nav-link\">\r\n                <Link href=\"/users\" activeState={{ key: 'users', class: 'active' }}>All Users</Link>\r\n            </li>\r\n            ...\r\n        </ul>\r\n    </div>\r\n</nav>\r\n```\r\n\r\n## Micro-Frontend Goodness\r\n\r\nThis router's implementation intends to cater for micro-frontends as best as possible.  The following are features and \r\nstrategies that are possible with this router.\r\n\r\n### Multi-Route Matching\r\n\r\nRouters always evaluate all defined routes, so it is possible for more than one route to match.  This facilitates the \r\nlayout of micro-frontends.  For example, a navigation micro-frontend could be inside a route that either always matches \r\nor matches most of the time, so navigation links are available the mayority/all of the time.\r\n\r\n### Simultaneous, Always-On Path and Hash Routing\r\n\r\nComponents (`Router`, `Route`, `Link`, `Fallback` and `RouterTrace`) with the same value of the `hash` property belong \r\nto the same \"universe\".  Components with different hash values belong to different universes, and these universes are \r\nparallel universes.  Components with hash value `false` use the URL's path name and will never interfere with routers \r\nthat use hash routing (hash value `true` or a path's name).  The main micro-frontend(s) may route using the URL's path \r\nname, while specialty MFE's could route using the path in the hash part of the URL.\r\n\r\n### Multi-Hash Routing\r\n\r\nAs of Februrary 2025, no other router in the world can do this.\r\n\r\nImagine a scenario where your MFE application would like to show side-by-side two micro-frontends that are \r\nrouter-enabled (meaning they use or need to work with a path).  With traditional routing, you could not have this setup \r\nbecause one MFE would take over the path, leaving the other MFE without one.\r\n\r\nMutli-hash routing creates named paths in the hash value, giving routers the ability to share the hash value with other \r\nrouters.  A hash value of the form `#path1=/path/1;path2=/path/2;...` could power side-by-side MFE's on, say, 4K \r\nlayouts.\r\n\r\n### EXPERIMENTAL - Replacing the `single-spa` Router\r\n\r\nIt is the author's intent to implement micro-frontends with only `single-spa` parcels and this router.  In other words, \r\nabandon the use of `registerApplication()` and `start()` and just mount parcels using this router.\r\n\r\n[single-spa](https://single-spa.js.org)\r\n\r\n## Unintrusive Philosophy\r\n\r\nThis mini router library imposes minimal restrictions.  Here are some features provided by other much larger codebases \r\nthat are not provided here because Svelte already has the capability.\r\n\r\n### Transitions\r\n\r\nNothing prevents you to add transitions to anything.\r\n\r\n```svelte\r\n<Route key=\"users\" path=\"/users/:userId\">\r\n    {#snippet children(params)}\r\n        <div transition:fade>\r\n            ...\r\n        </div>\r\n    {/snippet}\r\n</Route>\r\n```\r\n\r\n> [!NOTE]\r\n> This one item might be worthwhile revisting for the cases where synchronized transitions are desired.  This, however, \r\n> won't be looked at until Svelte attachments become a thing.\r\n\r\n### Guarded Routes\r\n\r\nGuard routes however you wish.  Maybe with an `{#if}` block, or maybe using the route's `and` property that allows you \r\nto specify a predicate function.  There are probably many other ways.\r\n\r\n### `Exact` Property on Routes\r\n\r\nNot needed.  All matching is exact path matching, and if you want to opt out of the exact route matching, simply add \r\nthe `rest` parameter specifier (`/*`):\r\n\r\n```svelte\r\n<Route key=\"admin\" path=\"/admin/*\">\r\n    ...\r\n</Route>\r\n```\r\n\r\nNow route matching for this route will behave as \"starts with\".  If you don't care about the value of the parameter, \r\njust ignore it.\r\n\r\n### Lazy-Loading\r\n\r\nLazy-loading components is very simple:\r\n\r\n```svelte\r\n<script lang=\"ts\">\r\n    function loadUsersComponent() {\r\n        return import('./lib/Users.svelte').then(m => m.default);\r\n    }\r\n</script>\r\n\r\n<Route key=\"users\" path=\"/users\">\r\n    {#await loadUsersComponent()}\r\n        <span>Loading...</span>\r\n    {:then Users}\r\n        <Users />\r\n    {:catch}\r\n        <p>Ooops!</p>\r\n    {/await}\r\n</Route>\r\n```\r\n\r\n### Navigation Events\r\n\r\nThere are no navigation events defined.  Simply write effects or derived computations based on the global `location` \r\nobject's `url`, `state` or `hashPaths` properties, which are reactive.\r\n\r\n```typescript\r\nimport { location } from \"@wjfe/n-savant\";\r\n\r\n// Or $derived, whichever you need.\r\n$effect(() => {\r\n    // Read location.url to re-run on URL changes (navigation).\r\n    location.url;\r\n    // Read location.state to re-run on state changes.\r\n    location.state;\r\n    // Read location.hashPaths to re-run on hash changes (hash navigation).\r\n    // The route named \"single\" is the one you want if doing hash routing.\r\n    location.hashPaths.single;\r\n});\r\n```\r\n\r\n### Parameter Types\r\n\r\nThere is no parameter type specification.  All parameter values go through type parsing:\r\n\r\n+ If the value represents a number, then the parameter value will be a `number`.\r\n+ If the value is the word `'true'` or `'false'`, then the parameter value will be a `boolean`.\r\n+ If none of the above, the value will be a `string`.\r\n\r\nIf the demand for parameter value types grow, this might be reconsidered, but know that this is easily achievable with \r\nthe `and` property on routes, or by specifying the path as a regular expression.\r\n\r\nIn the context of the following code, the path `'/users/summary'` would match both routes, so the one that needs a \r\nnumeric parameter value uses the `and` property to type-check the value:\r\n\r\n```svelte\r\n<Route path=\"/users/:userId\" and={(rp) => typeof rp.userId === 'number'}>\r\n    {#snippet children(rp)}\r\n        <UserDetails userId={rp.userId} />\r\n    {/snippet}\r\n</Route>\r\n<Route path=\"/users/summary\">\r\n    <UsersSummary />\r\n</Route>\r\n```\r\n\r\nThis is the version using a regular expression for the `path` property:\r\n\r\n```svelte\r\n<Route path={/\\/users\\/(?<userId>\\d+)/i}>\r\n    {#snippet children(rp)}\r\n        <UserDetails userId={rp.userId} />\r\n    {/snippet}\r\n</Route>\r\n<Route path=\"/users/summary\">\r\n    <UsersSummary />\r\n</Route>\r\n```\r\n\r\n### Reacting to Route Matching Events\r\n\r\nIf you're interested in reacting whenever (a) particular route(~~s~~) match(es), you can get a hold of the `routeStatus` \r\nproperty of router engines (which is reactive) by binding to a router's `router` property:\r\n\r\n```svelte\r\n<script lang=\"ts\">\r\n    import { RouterEngine } from \"@wjfe/n-savant/core\";\r\n\r\n    let router: $state<RouterEngine>();\r\n\r\n    $effect(() => {\r\n        for (let [key, rs] of Object.entries(router.routeStatus)) {\r\n            // key: Route's key\r\n            // rs:  RouteStatus for the route.\r\n            if (rs.match) {\r\n                // Do stuff with rs.routeParams, for example.\r\n            }\r\n        }\r\n    });\r\n</script>\r\n\r\n<Router bind:router>\r\n    ...\r\n</Router>\r\n```\r\n\r\n## Navigation\r\n\r\nThe recommended way of navigating is to create `<Link>` component instances to render links on the document(s).  If \r\nneeded, however, there's a programmatic way of navigating:  `location.navigate()`.\r\n\r\n```typescript\r\nimport { location } from \"@wjfe/n-savant\";\r\n\r\n// Path routing navigation:\r\nlocation.navigate('/new/path', { replace: true, state: { custom: 'Hi' }});\r\n\r\n// Hash routing navigation:\r\nlocation.navigate('#/new/path', { replace: true, state: { custom: 'Hi' }});\r\n\r\n// Multi-hash routing navigation:\r\nlocation.navigate('/new/path', 'path1', { replace: true, state: { custom: 'Hi' }});\r\n```\r\n\r\nNavigation in multi-hash scenarios is tricky:  One must make sure other paths remain untouched, and the information \r\nabout these other paths is stored in `location.hashPaths`.  You could use the second form above for multi-hash routing \r\nas long as you understand that it is your responsibility to (possibly) ensure the integrity of other paths defined in \r\nthe URL's hash value.\r\n\r\nJust in case you are wondering:  The navigation logic is already there in `<Link>` components:\r\n\r\n```svelte\r\n<!-- Path Routing => https://example.com/new/path -->\r\n<Link hash=\"false\" href=\"/new/path\">Click Me!</Link>\r\n\r\n<!-- Hash Routing => https://example.com/#/new/path -->\r\n<Link hash=\"true\" href=\"/new/path\">Click Me!</Link>\r\n\r\n<!-- Multi Hash Routing => https://example.com/#path1=/new/path -->\r\n<!-- Will also preserve any other named paths -->\r\n<Link hash=\"path1\" href=\"/new/path\">Click Me!</Link>\r\n```\r\n\r\n> [!IMPORTANT]\r\n> Not setting the `hash` property is **not the same** as setting it to `false`.  When `hash` is `undefined`, either \r\n> because the property is not specified at all, or its value is set to `undefined` explicitly, the value of the \r\n> `implicitMode` routing option, which is set when the library is initialized, will be used to resolve a `true` or \r\n> `false` value.\r\n>\r\n> This is true for all components.\r\n\r\n## Playing with Fire\r\n\r\nAt your own risk, you could use exported API like `getRouterContext()` and `setRouterContext()` to perform unholy acts \r\non the router layouts, again, **at your own risk**.\r\n\r\n---\r\n\r\n[Full Documentation @ Hashnode Space](https://wjfe-n-savant.hashnode.space)\r\n\r\nIf you would like to report a bug or request a feature, head to the [Issues page](https://github.com/WJSoftware/wjfe-n-savant/issues).\r\n",
	"legacy_svelte": false,
	"downloads_history": [
		[4058, 156],
		[4065, 103],
		[4072, 10],
		[4079, 162],
		[4086, 25],
		[4093, 20],
		[4100, 44],
		[4107, 24],
		[4114, 11],
		[4121, 28],
		[4128, 34],
		[4135, 45]
	],
	"esm": true,
	"cjs": false
}
