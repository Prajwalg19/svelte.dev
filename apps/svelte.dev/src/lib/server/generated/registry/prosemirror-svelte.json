{
	"name": "prosemirror-svelte",
	"description": "Provides Svelte bindings for the ProseMirror editor.",
	"repo_url": "https://github.com/christianheine/prosemirror-svelte",
	"authors": ["christianheine"],
	"homepage": "https://github.com/christianheine/prosemirror-svelte#readme",
	"downloads": 70,
	"updated": "2021-10-01T07:20:25.036Z",
	"tags": ["ui"],
	"github_stars": 112,
	"typescript": false,
	"version": "0.2.4",
	"svelte_range": "^3.0.0",
	"last_rune_check_version": "0.2.4",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "prosemirror-svelte",
				"version": "0.2.4",
				"size": 31065
			},
			{
				"name": "prosemirror-commands",
				"version": "1.7.1",
				"size": 132701
			},
			{
				"name": "prosemirror-model",
				"version": "1.25.1",
				"size": 524300
			},
			{
				"name": "orderedmap",
				"version": "2.1.1",
				"size": 14835
			},
			{
				"name": "prosemirror-transform",
				"version": "1.10.4",
				"size": 317199
			},
			{
				"name": "prosemirror-state",
				"version": "1.4.3",
				"size": 183382
			},
			{
				"name": "prosemirror-view",
				"version": "1.39.2",
				"size": 909536,
				"isCircular": true,
				"circularTarget": 6
			},
			{
				"name": "prosemirror-state",
				"version": "^1.0.0",
				"isCircular": true,
				"circularTarget": 5
			},
			{
				"name": "prosemirror-dropcursor",
				"version": "1.8.2",
				"size": 34065
			},
			{
				"name": "prosemirror-gapcursor",
				"version": "1.3.2",
				"size": 40931
			},
			{
				"name": "prosemirror-keymap",
				"version": "1.2.3",
				"size": 26164
			},
			{
				"name": "w3c-keyname",
				"version": "2.2.8",
				"size": 8381
			},
			{
				"name": "prosemirror-history",
				"version": "1.4.1",
				"size": 67836
			},
			{
				"name": "rope-sequence",
				"version": "1.3.4",
				"size": 27917
			},
			{
				"name": "prosemirror-inputrules",
				"version": "1.5.0",
				"size": 47800
			},
			{
				"name": "prosemirror-schema-basic",
				"version": "1.2.4",
				"size": 30028
			},
			{
				"name": "prosemirror-schema-list",
				"version": "1.5.1",
				"size": 54555
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2],
			[2, 3],
			[1, 4],
			[4, 2],
			[1, 5],
			[5, 2],
			[5, 4],
			[5, 6],
			[6, 2],
			[6, 7],
			[6, 4],
			[0, 8],
			[8, 5],
			[8, 6],
			[6, 5],
			[8, 4],
			[0, 9],
			[9, 10],
			[10, 11],
			[10, 5],
			[9, 2],
			[9, 5],
			[9, 6],
			[0, 12],
			[12, 5],
			[12, 4],
			[12, 6],
			[12, 13],
			[0, 14],
			[14, 5],
			[14, 4],
			[0, 10],
			[0, 2],
			[0, 15],
			[15, 2],
			[0, 16],
			[16, 2],
			[16, 4],
			[16, 5],
			[0, 5],
			[0, 6]
		],
		"circular": [
			[6, 5],
			[5, 6]
		]
	},
	"readme": "# Prosemirror Svelte\n [Svelte](https://svelte.dev) bindings for the [Prosemirror editor](https://prosemirror.net/).\n\nThe key motivation of this component is to provide a gentle wrapper around prosemirror - while trying to embrace its \ncore concept (such as the EditorState and Transactions). \n\nIf you only need a basic editor you can use the included helpers to create your editor state (see below). They will get you started with a working single-line or multi-line editor.\nIf you are in need of rich-text editing, I strongly recommend to implement you custom schema. You may \nalso use the schema provided by prosemirror-basic-schema, of course. In case you are just getting started with Prosemirror and want to see a working implementation, have a look at the [examples](examples). \n\nNote: Before the release of version 1.0, the API (especially of the helpers) will be undergoing changes. The same applies to this documentation. \n\n## Installation\n\n```bash\nyarn add prosemirror-svelte\n```\n\nor \n```bash\nnpm install --save prosemirror-svelte\n```\n\n## Essential usage\n\n```html\n<script>\n   // import the core component\n  import ProsemirrorEditor from 'prosemirror-svelte';\n\n  // import helpers to work with prosemirror state\n  import { createSingleLineEditor, toPlainText } from 'prosemirror-svelte/state';  \n\n  // create the initial editor state\n  let editorState = createSingleLineEditor('Hello world!'); \n\n  function handleChange(event) {\n    // get the new editor state from event.detail\n    editorState = event.detail.editorState;\n  }\n\n  // log the text content of the editor state, just for fun\n  $: console.log(toPlainText(editorState)); \n\n</script>\n\n<ProsemirrorEditor \n  placeholder=\"Go ahead and type something\" \n  {editorState} \n  on:change={handleChange}\n/>\n```\n\n## Props\n- **editorState** [[EditorState](https://prosemirror.net/docs/ref/#state.EditorState)]: \nThe state of the editor. If no state is provided, the component will create a very basic single-line editor state with some core plugins (e.g. key bindings)   \n- **placeholder** [String]: Placeholder text which is shown if the editor is empty\n- **className** [String]: CSS class to be used for the container div on which the Prosemirror editor will be mounted. Defaults to \"ui-editor\".\n- **debounceChangeEventsInterval** [Number]: Advanced setting to set how often change events are emitted. In milliseconds. Defaults to 50(ms).\n\n## Props intended to be bound\nThe following two props are intended to be used with bind:editor={yourVariable}. Don't change them in your code.\n- **view** [[EditorView](https://prosemirror.net/docs/ref/#view.EditorView)]: reference to the Prosemirror editor view\n- **editor** [HTMLDivElement]: Reference to the DOM element on which the prosemirror editor is mounted\n\n## Instance functions\n- **focus**: Focus the editor. It's recommended to use this function instead of focusing the DOM node directly (to ensure the proper selection is applied to your editor)\n- **blur**: Blur the editor\n\n## Events\n- **change**: Emitted when the content of the editor has changed (not when the selection changes). Also, by default, it is debounced by 50ms. This behavior can be altered with the \"debounceChangeEventsInterval\" prop.\nThe new state of the editor can be found in event.detail.editorState\n- **transaction**: Emitted whenever a transaction is executed on the editor view. This includes changes to the selection. event.detail contains four fields: \n    - view [EditorView]: Reference to the editor view\n    - editorState [EditorState]: Reference to the new editor state\n    - isDirty [boolean]: Whether the component has changes which need to be dispatched via change event\n    - contentHasChanged[boolean]: Whether the document content has changed (via !editorState.doc.eq(view.state.doc))\n- **focus**: (Forwarded) focus event\n- **blur**: (Forwarded) blur event\n- **keydown**: (Forwarded) keydown event\n\nTo support the plugin system provided by Prosemirror, the component also listens for events of type \"custom\". If such an event is submitted by a plugin, the component will look for a \"type\" attribute on the event.detail and then dispatch a new event of that type (essentially forwarding the event from native DOM into the Svelte world).  \n\n## Example\nThe example app which is included in the repository can be also be found here: http://prosemirror-svelte.surge.sh  \n\n## State helper methods \n```JS\n  import { ... } from 'prosemirror-svelte/state';\n```\n### Creating and serializing editor state\n- **createSingleLineEditor** [(content = \"\", plugins = []) -> EditorState]: Creates an editor state with a single-line schema and optional text content\n- **createMultiLineEditor** [(content = \"\", plugins = []) -> EditorState]: Creates an editor state with a multi-line schema and optional text content\n- **createRichTextEditor** [(html = \"\", plugins = []) -> EditorState]: Creates an editor state with a rich text schema which can be initialized with HTML content\n- **toHTML** [(EditorState)->String]: Returns the HTML representation of the given editor state \n- **toPlainText** [(EditorState)->String]: Returns the plain text representation of the given editor state \n- **toJSON** [(EditorState)->Object]: Serialize the editor state as JSON\n- **fromJSON** [(json, schema = multiLineSchema, plugins = corePlugins)]: Create editor state from a JSON object \n\n### Modifying editor state\n- **split** [(EditorState) -> EditorState]: splits the text at the current selection. If the selection is not collapsed, it will be split around it.\n- **selectText** [(editorState: EditorState, from: number, to: number) => EditorState]: returns a new editor state with the the selection around from and to.\n- **clear** [(EditorState) -> EditorState]: returns a new editor state where all content was removed.\n- **selectAll** [(EditorState) -> EditorState]: returns a new editor state with all text selected.\n- **deleteSelection** [(EditorState) -> EditorState]: returns a new editor state where the selection was deleted.\n- **replaceTextAtPosition** [(editorState: EditorState, from: Number, to: Number, newText: String, setSelection: Boolean = false) -> EditorState]: returns a new editor state where the text between \"from\" and \"to\" was replaced by a new one, optionally setting a selection for that inserted text.\n- **toggleMark** [(editorState: EditorState, type: String, attrs) -> EditorState]: Toggle the mark of the given type for the current selection (or sets the stored marks if the selection is collapsed)\n- **toggleBold** [(EditorState) -> EditorState]: Specialized version of toggleMark to toggle the \"strong\" mark\n- **toggleItalic** [(EditorState) -> EditorState]: Specialized version of toggleMark to toggle the \"em\" mark\n- **setBlockType** [(editorState: EditorState, type: String, attrs: Object) -> EditorState]: Set the block type for the current selection\n\n## General helpers\n```JS\n  import { ... } from 'prosemirror-svelte/helpers';\n```\n\n### Getting meta information about the current state\n- **getNodeTypeAtSelectionHead** [(editorState: EditorState)->{type:NodeType, attrs: Object}]: Returns the type of node at the head of the current selection, e.g. for activating menu buttons\n- **getCurrentMarks** [(editorState: EditorState)-> {{activeMarks: Object<string,Mark>, marksInSelection: Object<string,Mark>, marksAtHead: Object<string,Mark>, storedMarks: Object}}]: Returns information about the marks inside the current selection (i.e. whether the text is marked as bold or italic). *Active marks* is what you might want to use for setting menu buttons active/inactive. Have a look at the examples to guide you in the right direction.\n\n### Plugins\n- **corePlugins**\n- **richTextKeyMapPlugin**\n\n## License\n[MIT](LICENSE)\n",
	"legacy_svelte": true,
	"downloads_history": [
		[3589, 27],
		[3596, 18],
		[3603, 42],
		[3610, 20],
		[3617, 22],
		[3624, 41],
		[3631, 21],
		[3638, 23],
		[3645, 5],
		[3652, 16],
		[3659, 82],
		[3666, 131],
		[3673, 92],
		[3680, 13],
		[3687, 49],
		[3694, 31],
		[3701, 47],
		[3708, 7],
		[3715, 76],
		[3722, 77],
		[3729, 47],
		[3736, 53],
		[3743, 62],
		[3750, 56],
		[3757, 44],
		[3764, 154],
		[3771, 94],
		[3778, 135],
		[3785, 223],
		[3792, 184],
		[3799, 136],
		[3806, 74],
		[3813, 15],
		[3820, 67],
		[3827, 11],
		[3834, 3],
		[3841, 48],
		[3848, 85],
		[3855, 32],
		[3862, 62],
		[3869, 35],
		[3876, 28],
		[3883, 67],
		[3890, 59],
		[3897, 45],
		[3904, 96],
		[3911, 209],
		[3918, 220],
		[3925, 238],
		[3932, 229],
		[3939, 309],
		[3946, 203],
		[3953, 183],
		[3960, 103],
		[3967, 253],
		[3974, 247],
		[3981, 155],
		[3988, 169],
		[3995, 222],
		[4002, 178],
		[4009, 115],
		[4016, 101],
		[4023, 271],
		[4030, 242],
		[4037, 122],
		[4044, 185],
		[4051, 154],
		[4058, 94],
		[4065, 112],
		[4072, 155],
		[4079, 204],
		[4086, 137],
		[4093, 160],
		[4100, 124],
		[4107, 46],
		[4114, 70],
		[4121, 61],
		[4128, 47]
	],
	"esm": false,
	"cjs": true
}
