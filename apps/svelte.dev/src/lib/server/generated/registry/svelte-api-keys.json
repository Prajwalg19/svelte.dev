{
	"name": "svelte-api-keys",
	"description": "Generate, validate, and rate limit API keys for SvelteKit.",
	"repo_url": "https://github.com/captaincodeman/svelte-api-keys",
	"authors": ["captaincodeman"],
	"homepage": "https://captaincodeman.github.io/svelte-api-keys/",
	"downloads": 5,
	"updated": "2024-04-29T20:32:00.462Z",
	"tags": ["server", "auth"],
	"github_stars": 37,
	"typescript": true,
	"version": "0.1.4",
	"svelte_range": "5.0.0-next.85",
	"kit_range": "^2.5.7",
	"last_rune_check_version": "0.1.4",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "svelte-api-keys",
				"version": "0.1.4",
				"size": 37964
			},
			{
				"name": "@robloche/chartjs-plugin-streaming",
				"version": "3.1.0",
				"size": 79725
			},
			{
				"name": "bad-words-next",
				"version": "2.3.2",
				"size": 65860
			},
			{
				"name": "moize",
				"version": "6.1.6",
				"size": 811511
			},
			{
				"name": "fast-equals",
				"version": "3.0.3",
				"size": 162075
			},
			{
				"name": "micro-memoize",
				"version": "4.1.3",
				"size": 90138
			},
			{
				"name": "confusables",
				"version": "1.1.1",
				"size": 107866
			},
			{
				"name": "base-x",
				"version": "4.0.1",
				"size": 9606
			},
			{
				"name": "chart.js",
				"version": "4.4.9",
				"size": 4961506
			},
			{
				"name": "@kurkle/color",
				"version": "0.3.4",
				"size": 78965
			},
			{
				"name": "chartjs-adapter-date-fns",
				"version": "3.0.0",
				"size": 287582
			},
			{
				"name": "date-fns",
				"version": "3.6.0",
				"size": 22153202
			},
			{
				"name": "firebase-admin",
				"version": "12.7.0",
				"size": 1397399
			},
			{
				"name": "uuid",
				"version": "10.0.0",
				"size": 168173
			},
			{
				"name": "jwks-rsa",
				"version": "3.2.0",
				"size": 28089
			},
			{
				"name": "jose",
				"version": "4.15.9",
				"size": 548521
			},
			{
				"name": "debug",
				"version": "4.4.0",
				"size": 42798
			},
			{
				"name": "ms",
				"version": "2.1.3",
				"size": 6721
			},
			{
				"name": "limiter",
				"version": "1.1.5",
				"size": 23166
			},
			{
				"name": "lru-memoizer",
				"version": "2.3.0",
				"size": 71693
			},
			{
				"name": "lru-cache",
				"version": "6.0.0",
				"size": 15643
			},
			{
				"name": "yallist",
				"version": "4.0.0",
				"size": 14752
			},
			{
				"name": "lodash.clonedeep",
				"version": "4.5.0"
			},
			{
				"name": "@types/express",
				"version": "4.17.21",
				"size": 7863
			},
			{
				"name": "@types/qs",
				"version": "6.9.18",
				"size": 7457
			},
			{
				"name": "@types/body-parser",
				"version": "1.19.5",
				"size": 7648
			},
			{
				"name": "@types/node",
				"version": "22.15.3",
				"size": 2350386
			},
			{
				"name": "undici-types",
				"version": "6.21.0",
				"size": 83680
			},
			{
				"name": "@types/connect",
				"version": "3.4.38",
				"size": 5907
			},
			{
				"name": "@types/serve-static",
				"version": "1.15.7",
				"size": 7790
			},
			{
				"name": "@types/send",
				"version": "0.17.4",
				"size": 9849
			},
			{
				"name": "@types/mime",
				"version": "1.3.5",
				"size": 3781
			},
			{
				"name": "@types/http-errors",
				"version": "2.0.4",
				"size": 6587
			},
			{
				"name": "@types/express-serve-static-core",
				"version": "4.19.6",
				"size": 46221
			},
			{
				"name": "@types/range-parser",
				"version": "1.2.7",
				"size": 4615
			},
			{
				"name": "@types/jsonwebtoken",
				"version": "9.0.9",
				"size": 13677
			},
			{
				"name": "@types/ms",
				"version": "2.1.0",
				"size": 5101
			},
			{
				"name": "node-forge",
				"version": "1.3.1",
				"size": 1657079
			},
			{
				"name": "jsonwebtoken",
				"version": "9.0.2",
				"size": 43482
			},
			{
				"name": "jws",
				"version": "3.2.2",
				"size": 17682
			},
			{
				"name": "jwa",
				"version": "1.4.1",
				"size": 13688
			},
			{
				"name": "safe-buffer",
				"version": "5.2.1",
				"size": 32101
			},
			{
				"name": "ecdsa-sig-formatter",
				"version": "1.0.11",
				"size": 20588
			},
			{
				"name": "buffer-equal-constant-time",
				"version": "1.0.1"
			},
			{
				"name": "semver",
				"version": "7.7.1",
				"size": 96674
			},
			{
				"name": "lodash.once",
				"version": "4.1.1"
			},
			{
				"name": "lodash.includes",
				"version": "4.3.0"
			},
			{
				"name": "lodash.isnumber",
				"version": "3.0.3"
			},
			{
				"name": "lodash.isstring",
				"version": "4.0.1"
			},
			{
				"name": "lodash.isboolean",
				"version": "3.0.3"
			},
			{
				"name": "lodash.isinteger",
				"version": "4.0.4"
			},
			{
				"name": "lodash.isplainobject",
				"version": "4.0.6"
			},
			{
				"name": "@fastify/busboy",
				"version": "3.1.1",
				"size": 80126
			},
			{
				"name": "farmhash-modern",
				"version": "1.1.0",
				"size": 116757
			},
			{
				"name": "@firebase/database-types",
				"version": "1.0.5",
				"size": 6265
			},
			{
				"name": "@firebase/util",
				"version": "1.10.0",
				"size": 1149587
			},
			{
				"name": "tslib",
				"version": "2.8.1",
				"size": 90359
			},
			{
				"name": "@firebase/app-types",
				"version": "0.9.2",
				"size": 9558
			},
			{
				"name": "@firebase/database-compat",
				"version": "1.0.8",
				"size": 2573185
			},
			{
				"name": "@firebase/logger",
				"version": "0.4.2",
				"size": 85947
			},
			{
				"name": "@firebase/database",
				"version": "1.0.8",
				"size": 10605341
			},
			{
				"name": "faye-websocket",
				"version": "0.11.4",
				"size": 30789
			},
			{
				"name": "websocket-driver",
				"version": "0.7.4",
				"size": 67439
			},
			{
				"name": "http-parser-js",
				"version": "0.5.10",
				"size": 26471
			},
			{
				"name": "websocket-extensions",
				"version": "0.1.4",
				"size": 55037
			},
			{
				"name": "@firebase/component",
				"version": "0.6.9",
				"size": 176752
			},
			{
				"name": "@firebase/auth-interop-types",
				"version": "0.2.3",
				"size": 1966
			},
			{
				"name": "@firebase/app-check-interop-types",
				"version": "0.3.2",
				"size": 2902
			},
			{
				"name": "redis",
				"version": "4.7.0",
				"size": 43927
			},
			{
				"name": "@redis/json",
				"version": "1.0.7",
				"size": 25384
			},
			{
				"name": "@redis/bloom",
				"version": "1.2.0",
				"size": 61924
			},
			{
				"name": "@redis/graph",
				"version": "1.1.1",
				"size": 24158
			},
			{
				"name": "@redis/client",
				"version": "1.6.0",
				"size": 613566
			},
			{
				"name": "generic-pool",
				"version": "3.9.0",
				"size": 67069
			},
			{
				"name": "cluster-key-slot",
				"version": "1.1.2",
				"size": 12180
			},
			{
				"name": "@redis/search",
				"version": "1.2.0",
				"size": 78720
			},
			{
				"name": "@redis/time-series",
				"version": "1.1.0",
				"size": 49726
			},
			{
				"name": "svelte-web-storage",
				"version": "0.0.8",
				"size": 11152
			},
			{
				"name": "esm-env",
				"version": "1.2.2",
				"size": 3784
			}
		],
		"dependencies": [
			[0, 1],
			[0, 2],
			[2, 3],
			[3, 4],
			[3, 5],
			[2, 6],
			[0, 7],
			[0, 8],
			[8, 9],
			[0, 10],
			[0, 11],
			[0, 12],
			[12, 13],
			[12, 14],
			[14, 15],
			[14, 16],
			[16, 17],
			[14, 18],
			[14, 19],
			[19, 20],
			[20, 21],
			[19, 22],
			[14, 23],
			[23, 24],
			[23, 25],
			[25, 26],
			[26, 27],
			[25, 28],
			[28, 26],
			[23, 29],
			[29, 26],
			[29, 30],
			[30, 31],
			[30, 26],
			[29, 32],
			[23, 33],
			[33, 24],
			[33, 26],
			[33, 30],
			[33, 34],
			[14, 35],
			[35, 36],
			[35, 26],
			[12, 37],
			[12, 26],
			[12, 38],
			[38, 17],
			[38, 39],
			[39, 40],
			[40, 41],
			[40, 42],
			[42, 41],
			[40, 43],
			[39, 41],
			[38, 44],
			[38, 45],
			[38, 46],
			[38, 47],
			[38, 48],
			[38, 49],
			[38, 50],
			[38, 51],
			[12, 52],
			[12, 53],
			[12, 54],
			[54, 55],
			[55, 56],
			[54, 57],
			[12, 58],
			[58, 56],
			[58, 55],
			[58, 59],
			[59, 56],
			[58, 60],
			[60, 56],
			[60, 55],
			[60, 61],
			[61, 62],
			[62, 63],
			[62, 41],
			[62, 64],
			[60, 59],
			[60, 65],
			[65, 56],
			[65, 55],
			[60, 66],
			[60, 67],
			[58, 65],
			[58, 54],
			[0, 68],
			[68, 69],
			[68, 70],
			[68, 71],
			[68, 72],
			[72, 21],
			[72, 73],
			[72, 74],
			[68, 75],
			[68, 76],
			[0, 77],
			[77, 78]
		],
		"circular": []
	},
	"readme": "# svelte-api-keys\n\nSecure API Key Generation, Validation, and Rate Limiting for SvelteKit projects. Create fine-grained access tokens to grant programatic access to your API.\n\n## Overview\n\nIf you have any kind of API publicly accessible on the internet then you need to protect it. You can [block unwanted bots and automated requests](https://www.npmjs.com/package/svelte-kit-bot-block) but at some point, you may receive valid requests from legitimate users ... you just don't want them making too many requests too quickly as it can overload your backend and you want to ensure availability to other users by sharing out capacity evenly.\n\nThat's where rate limiting comes in. By defining a limit for how many requests a user makes, you can protect your backend resources. If you allow anonymous requests the throttling could be based on the IP address otherwise you'll likely want to provide API keys to identify the requestor and apply the limits based on those.\n\nWhich is the second part - how do you securely generate, store, and validate these keys? How do you protect against keys being exposed? Can you link API keys to accounts and apply different limits based on the account tier that should apply? How do you actually apply the limits and send the appropriate HTTP headers and response to inform the caller when limits are applied?\n\nThese are the things this package can help with.\n\n## Features\n\n- ✅ Designed to integrate with SvelteKit projects with fluent API\n- ✅ Generate secure API keys in Base62 format for compactness and easy copy-paste\n- ✅ Avoid accidental bad-words in generated keys (taking homoglyphs into account)\n- ✅ Use SHA256 hashing when storing key info, generated keys themselves are never stored (display once)\n- ✅ Attach name, description, permissions, and expiry to keys (for self-service management of keys)\n- ✅ Extract API key from the request searchParams, HTTP headers, cookies, or use a custom function\n- ✅ Validate keys and return saved info for authorization\n- ✅ Authorize requests based on validated key permissions\n- ✅ Easy to-implement key store interface: In-Memory, Redis, and Firestore implementations provided\n- ✅ LRU Cache with TTL ensures low-overhead for high performance APIs\n- ✅ Token-Bucket Rate-limiting of API requests: In-memory and Redis implementations provided\n- ✅ Define different rate limits based on account tiers (e.g. basic, premium, or enterprise)\n\n## Usage\n\n### Installation\n\nAdd to your project using your package manager of choice (tip: [`pnpm`](https://pnpm.io/) is _excellent_):\n\n    pnpm install svelte-api-keys\n\n### Create a key store\n\nThe key store persists the information associated with an API key which is only ever accessed using the SHA256 hash of the key, for security purposes.\n\nProvided implementations include an in-memory store, Firestore, and Redis. Other stores such as any popular RDBMS can be created by implementing a simple `KeyStore` interface.\n\nWe'll use `src/lib/api_keys.ts` to to store the code in all the following examples:\n\n#### In Memory Key Store\n\nThis uses an internal `Map` which is _not_ persisted so is suitable for development, testing and demonstration purposes only!\n\n```ts\nimport { InMemoryKeyStore } from 'svelte-api-keys'\n\nconst storage = new InMemoryKeyStore()\n```\n\n#### Firestore Key Store\n\nFirestore is a popular cloud data store from Google. Use the `firebase-admin/firestore` lib to create a Firestore instance and pass it to the `FirestoreKeyStore` constructor. By default, key information is stored in a collection called `api` but this can be overridden in the constructor. To save read costs and improve performance, wrap the store in an `LruCacheKeyStore` instance:\n\n```ts\nimport { initializeApp } from 'firebase-admin/app'\nimport { getFirestore } from 'firebase-admin/firestore'\nimport { FirestoreKeyStore, LruCacheKeyStore } from 'svelte-api-keys'\nimport { env } from '$env/dynamic/private'\n\nconst app = initializeApp({ projectId: env.FIREBASE_PROJECT_ID })\nconst firestore = getFirestore(app)\nconst storage = new LruCacheKeyStore(new FirestoreKeyStore(firestore))\n```\n\n#### Redis Key Store\n\nRedis is a fast persistable cache and makes for an excellent store. Use the node `redis` package to create a redis client instance and pass it to the `RedisKeyStore` static `create` method, which is used to ensure a search index exists. By default, key information is stored in a hash structure with the prefix `api:` but this can be overridden in the constructor:\n\n```ts\nimport { createClient } from 'redis'\nimport { RedisKeyStore } from 'svelte-api-keys'\nimport { env } from '$env/dynamic/private'\n\nconst redis = createClient({ url: env.REDIS_URL })\nawait redis.connect()\nconst storage = await RedisKeyStore.create(redis)\n```\n\n### Create a Token Bucket store\n\nThe token bucket store maintains the state of each token bucket.\n\nProvided implementations include an in-memory store, and Redis. Other stores such as any popular RDBMS can be created by extending a base `TokenBucket` class and implementing a `consume` method.\n\n#### In Memory Token Buckets\n\nThis uses an internal `Map` which is _not_ persisted or shared so is suitable for single-server use where potentially allowing excess requests in the event of a process restart would be acceptable, or for development, testing and demonstration purposes only!\n\n```ts\nimport { InMemoryTokenBucket } from 'svelte-api-keys'\n\nconst buckets = new InMemoryTokenBucket()\n```\n\n#### Redis Token Buckets\n\nThe Redis implementation uses a server-side javascript function to handle the token bucket update logic, so Redis Stack Server is recommended. This function is created automatically when the redis client instance is passed to the `RedisTokenBucket` static `create` method. You can also override the default storage prefix (`bucket:`), module name (`TokenBucket`), and function name (`consume`) if needed.\n\nThe key store and token bucket implementations are independent of each other and can be mix-and-matched as required, but it's likely that if you're using redis you'll use the Redis implementations of both so they can be created using the same redis client instance:\n\n```ts\nimport { createClient } from 'redis'\nimport { RedisKeyStore, RedisTokenBucket } from 'svelte-api-keys'\nimport { env } from '$env/dynamic/private'\n\nconst redis = createClient({ url: env.REDIS_URL })\nawait redis.connect()\nconst storage = await RedisKeyStore.create(redis)\nconst buckets = await RedisTokenBucket.create(redis)\n```\n\n### Create an ApiKeys Manager\n\nThe `ApiKeys` manager provides the interface to generate, validate, and manage API keys. It uses the API Key Store internally, and applies SHA256 hashing to keys for security when storing and retrieving them (you can never leak keys if you don't store them!). Normally, you should never access the key store directly - aways use the key manager to do so. When generating keys, it will ensure a key doesn't contain any 'bad words' (which could otherwise be unfortunate and embarrassing!).\n\nThe simplest use just requires the key store and token bucket implementations be passed to it:\n\n```ts\nexport const api_keys = new ApiKeys(storage, buckets)\n```\n\nThere is an optional parameters object that can also control it's behavior by passing:\n\n`cookie` (default `api-key`) sets the name of a cookie to inspect for an API Key on any incoming request.\n\n`httpHeader` (default `x-api-key`) sets the name of an http header to inspect for an API Key on any incoming request. A request containing the http header `x-api-key: my-api-key` would find the key `my-api-key` automatically. Any key found in the http header will override a key found from a cookie.\n\n`searchParam` (default `key`) sets the name of a URL search parameter to inspect for an API Key on any incoming request. A request for `POST /my-endpoint?key=my-api-key` would find the key `my-api-key` automatically. Any key found in the search param will override a key found from an http header or cookie.\n\n`custom` (default undefined) sets a custom key extraction & transform function that allows you to perform your own key lookups, perhaps via an existing session cookie or similar, and also allows you to transform any existing key that has been extracted using the previous settings - you might [prefix keys to indicate their usage as Stripe does](https://docs.stripe.com/docs/api/authentication) for instance. This will override all other methods if specified.\n\n`key_length` (default 32) sets the length, in bytes, of the API key to generate. If you want shorter API keys you could consider setting it to a lower value such as 24 or 16 (but too low risks conflicts when generating new keys). Keys are converted to human-readable format using Base62 for compactness and easy copy-paste.\n\nSo as a more complete example your `src/lib/api_keys.ts` may end up looking something like this, but using whatever key store and token bucket implementations make sense for you:\n\n```ts\nimport { ApiKeys, InMemoryKeyStore, InMemoryTokenBucket } from 'svelte-api-keys'\n\nconst storage = new InMemoryKeyStore()\nconst buckets = new InMemoryTokenBucket()\n\nexport const api_keys = new ApiKeys(storage, buckets, { searchParam: 'api-key', key_length: 16 })\n```\n\n### Hook into the SvelteKit Request\n\nThe `ApiKeys` instance we created provides a `.handle` property that can be used to hook it into the SvelteKit request pipeline. Just return this from `hooks.server.ts`:\n\n```ts\nimport { api_keys } from '$lib/api_keys`\n\nexport const handle = api_keys.handle\n```\n\nIf you already have a `handle` function you can chain them together using the [`sequence`](https://kit.svelte.dev/docs/modules#sveltejs-kit-hooks-sequence) helper function.\n\n### Use the API in endpoints\n\nNow our API Key manager is hooked into the SvelteKit pipeline, any request will have an `api` object available on `locals`. This will have a `key`, and `info` property depending on whether an API Key was sent with the request and whether it was valid. It also provides a fluent API that any endpoint can use to `limit()` the request by passing in the refill rate to apply.\n\n#### Simple Global Limit\n\nThe simplest rate-limiting just requires awaiting a call to `locals.api.limit(rate)` where `rate` is a token-bucket refill rate and size:\n\n```ts\nimport { json } from '@sveltejs/kit'\nimport { MINUTE } from 'svelte-api-keys'\nimport { fetchData } from '$lib/database'\n\nconst rate = { rate: 30 / MINUTE, size: 10 }\n\nexport async function POST({ locals }) {\n  await locals.api.limit(rate)\n\n  const data = await fetchData()\n\n  return json(data)\n}\n```\n\nThe `rate` property is the rate-per-second that the token bucket refills. Read it like a fraction - numerator per denominator. To make it easier to define them, we've provided `SECOND`, `MINUTE`, `HOUR`, `DAY`, and `WEEK` constants for the denominator. In the example above, `30 / MINUTE` would equate to a rate of 0.5 per second ... meaning a new token would be added every 2 seconds.\n\nThe `size` property is the token bucket capacity. This provides both the initial size when a token-bucket is created and the total capacity that the bucket will ever fill upto. It will then allow a burst of that number of requests without any limiting being applied, at which point the requests have to wait for tokens to become available (at the refill rate).\n\nIf you don't want to hard-code the limits into the app, you can fetch them from a datastore or environment variables. They can be stored as a string and parsed. Note the units are case insensitive:\n\n```ts\nimport { env } from '$env/dynamic/private'\nimport { parseRefill } from 'svelte-api-keys'\n\n// SOME_ENDPOINT_RATE_LIMIT=\"30 / minute, 10\"\nconst rate = parseRefill(env.SOME_ENDPOINT_RATE_LIMIT)\n\n// identical to { rate: 30 / MINUTE, size: 10 }\n```\n\nWith no other parameters, this applies rate limiting globally to the app - the limit would be shared for any endpoints using it (a separate count is kept for each API key though). If the call is approved, the endpoint request will complete as normal. If there are insufficient tokens in the bucket, the server will send a `429 Too Many Requests` response to indicate that the client needs to back-off and wait. Appropriate HTTP headers will be added to each response to communicate the limits to the caller - this can be used to avoid making a request that would not be approved, by waiting for the indicated time (how long before the token bucket will refill enough to allow it).\n\nBut we can do more ...\n\n#### Cost Per Endpoint\n\nNot all API calls are equal, some may be more expensive and you want to account for this in the rate limiting. One easy way to do that is to just apply a different cost - consuming more tokens from the bucket. By default, 1 token is consumed per call, but this can be overridden:\n\n```ts\nawait locals.api.cost(5).limit(rate)\n```\n\nIf the refill rate was 3 per second, with a size capacity of 10, this would allow 2 initial calls to be made after which they would need to wait 1⅔ seconds between each. Again, this limit would be shared, so more of the smaller cost endpoints could be called in the same period of time.\n\nBut we can do more ...\n\n#### Independent Limit per Endpoint / Group\n\nMaybe you want to have different independent rate limits for different endpoints or groups of endpoints? By adding a name, the token-buckets will be separated:\n\n```ts\nawait locals.api.name(`comments`).limit(rate)\n```\n\nBut we can do more ...\n\n#### Check Granular Permissions\n\nGood practice is to not give too many permissions to a single key, but instead to limit it's use for a specific purpose. When generating an API key we can define a set of permissions that it has. Then, any endpoint can include the permissions when asking for approval - if the API key info doesn't have the necessary permissions the request will be denied with a `403` response.\n\n```ts\n// require a single permission:\nawait locals.api.has(`get`).limit(rate)\n\n// require a complete set of permissions:\nawait locals.api.all([`get`, 'comments']).limit(rate)\n\n// require any of the permissions specified:\nawait locals.api.all([`get`, 'read', 'search']).limit(rate)\n```\n\nBut we can do more ...\n\n#### Anonymous / Public APIs\n\nOK, last one, I promise. If you have an anonymous endpoint, there won't be any API key provided, and no KEY info to check against, so the permission checks won't be used. But we can still apply rate limiting and allow a call to be made without a key (otherwise, a missing key would result in a `401` response and an invalid or expired key would return `403`):\n\n```ts\nawait locals.api.anonymous().limit(rate)\n```\n\nAll of these options can be combined into a single call, just make sure that the `.limit(rate)` call is last:\n\n```ts\nawait locals.api.name('posts').has('get').cost(2).limit(rate)\n```\n\n#### Change Limits based on tiers\n\nSometimes, the rate limit that should apply will depend on the user account that the key belongs to. You may have different usage tiers such as `free`, `basic`, `premium`, `enterprise`, and so on. This can be accomplished by using a `sequence` of hooks to lookup the appropriate tier based on the user (available in KEY info).\n\nFirst, add the appropriate tiers to `App.Locals` in `src/app.d.ts`:\n\n```ts\ninterface Locals extends ApiLocals {\n  tier: 'basic' | 'premium' | 'enterprise'\n}\n```\n\nAdd an additional handler to `src/hooks.server.ts`:\n\n```ts\nimport { sequence } from '@sveltejs/kit/hooks'\nimport type { Handle } from '@sveltejs/kit'\nimport { fetchTierForUser } from '$lib/database'\nimport { api_keys } from '$lib/api_keys`\n\n// this handle could set the locals.tier based on the api.info.user\nconst handleTiers: Handle = async ({ event, resolve }) => {\n  const { locals } = event\n\n  // fetchTierForUser is an example API that will return the appropriate tier based on the key info user\n  // tip: this would benefit from an in-memory LRU + TTL cache to avoid slowing down repeated lookups...\n  locals.tier = await fetchTierForUser(locals.api.info)\n\n  return await resolve(event)\n}\n\n// the handle we export is now a sequence of our api_keys handler and this one\nexport const handle = sequence(api_keys.handle, handleTiers)\n```\n\nNow our endpoints have access to a `locals.tier` value which can be used to select an appropriate token-bucket refill rate:\n\n```ts\nimport { json } from '@sveltejs/kit'\nimport { MINUTE } from 'svelte-api-keys'\nimport { fetchData } from '$lib/database'\n\nconst rates = {\n  basic: { rate: 10 / MINUTE, size: 1 },\n  premium: { rate: 60 / MINUTE, size: 20 },\n  enterprise: { rate: 300 / MINUTE, size: 60 },\n}\n\nexport async function POST({ locals }) {\n  const { tier } = locals\n  const rate = rates[tier]\n  await locals.api.limit(rate)\n\n  const data = await fetchData()\n\n  return json(data)\n}\n```\n\nFinally, should you need them for whatever reason, the `.limit(rate)` method returns details about the result of the call which are also set as HTTP Response headers - these will allow well-behaved clients to automatically back off when they hit rate limits.\n\n## TODO\n\nPossible enhancements:\n\n- Warn if an endpoint fails to call `.limit(rate)`, at least after any other api methods\n- Provide a ready-to-go UI for managing keys\n",
	"legacy_svelte": false,
	"downloads_history": [
		[3715, 51],
		[3722, 5],
		[3729, 196],
		[3736, 89],
		[3743, 7],
		[3750, 199],
		[3757, 34],
		[3764, 18],
		[3771, 64],
		[3778, 10],
		[3785, 7],
		[3792, 4],
		[3806, 10],
		[3813, 4],
		[3820, 5],
		[3827, 25],
		[3834, 58],
		[3841, 5],
		[3848, 14],
		[3855, 31],
		[3862, 28],
		[3869, 20],
		[3876, 8],
		[3883, 9],
		[3890, 17],
		[3897, 16],
		[3904, 9],
		[3911, 4],
		[3918, 5],
		[3925, 5],
		[3932, 5],
		[3939, 2],
		[3946, 5],
		[3953, 3],
		[3960, 13],
		[3967, 4],
		[3974, 5],
		[3981, 1],
		[3988, 2],
		[3995, 12],
		[4002, 1],
		[4009, 1],
		[4016, 23],
		[4037, 17],
		[4044, 11],
		[4051, 5],
		[4058, 1],
		[4065, 1],
		[4072, 1],
		[4093, 1],
		[4100, 11],
		[4107, 23],
		[4114, 5],
		[4121, 12],
		[4128, 16]
	],
	"esm": true,
	"cjs": false
}
